---
phase: 22-web-remote-mcp
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - apps/web/app/api/mcp/[transport]/route.ts
autonomous: true

must_haves:
  truths:
    - "POST to /api/mcp/mcp with valid bearer token and MCP JSON-RPC returns tool results"
    - "POST with invalid/missing bearer token returns 401"
    - "list_skills, search_skills, deploy_skill, server_info tools all work over HTTP"
    - "CORS headers allow https://claude.ai and https://claude.com origins"
    - "Rate limiting returns 429 when exceeded (60 req/min per key)"
    - "Deploy over HTTP returns content with browser-friendly message, no file system instructions"
  artifacts:
    - path: "apps/web/app/api/mcp/[transport]/route.ts"
      provides: "MCP Streamable HTTP endpoint"
      exports: ["GET", "POST", "OPTIONS"]
      min_lines: 80
  key_links:
    - from: "apps/web/app/api/mcp/[transport]/route.ts"
      to: "@everyskill/db/services/api-keys"
      via: "validateApiKey in withMcpAuth callback"
      pattern: "validateApiKey"
    - from: "apps/web/app/api/mcp/[transport]/route.ts"
      to: "apps/mcp/src/tools/*"
      via: "Inline tool logic calling DB directly (not cross-app import)"
      pattern: "server\\.tool|db\\.query\\.skills"
    - from: "apps/web/app/api/mcp/[transport]/route.ts"
      to: "trackUsage equivalent"
      via: "Direct DB insert for usage tracking"
      pattern: "usageEvents|trackUsage"
---

<objective>
Create the MCP Streamable HTTP route handler at /api/mcp/[transport] using mcp-handler. This is the core of Phase 22: the endpoint that Claude.ai will connect to. It registers all four tools (list_skills, search_skills, deploy_skill, server_info), validates bearer tokens using the existing validateApiKey service, adds CORS headers for Claude.ai, and implements in-memory rate limiting.

Purpose: This is THE endpoint that makes Relay accessible from Claude.ai browser. Without it, skills are only available via local stdio MCP.
Output: A single route file that handles the full MCP protocol over HTTP.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/22-web-remote-mcp/22-01-SUMMARY.md
@packages/db/src/services/api-keys.ts
@apps/mcp/src/tracking/events.ts
@packages/db/src/schema/usage-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP HTTP route with auth, tools, CORS, and rate limiter</name>
  <files>apps/web/app/api/mcp/[transport]/route.ts</files>
  <action>
    Create `apps/web/app/api/mcp/[transport]/route.ts` with the following components:

    **1. Imports:**
    ```typescript
    import { createMcpHandler, withMcpAuth } from "mcp-handler";
    import { z } from "zod";
    import { validateApiKey } from "@everyskill/db/services/api-keys";
    import { db } from "@everyskill/db";
    import { usageEvents } from "@everyskill/db/schema/usage-events";
    import { incrementSkillUses } from "@everyskill/db/services/skill-metrics";
    ```

    **2. CORS configuration:**
    ```typescript
    const ALLOWED_ORIGINS = ["https://claude.ai", "https://claude.com"];
    ```

    **3. Rate limiter (in-memory sliding window):**
    Create a `checkRateLimit(keyId: string, maxPerMinute = 60): boolean` function using a Map<string, { count: number; resetAt: number }>. Returns false when rate exceeded. Lazy cleanup on each check (if resetAt passed, reset counter).

    **4. trackUsage helper** (inline, since we cannot import from apps/mcp):
    ```typescript
    async function trackUsage(event: { toolName: string; skillId?: string; userId?: string; metadata?: Record<string, unknown> }) {
      try {
        if (!db) return;
        await db.insert(usageEvents).values(event);
        if (event.skillId) await incrementSkillUses(event.skillId);
      } catch (e) {
        console.error("Failed to track usage:", e);
      }
    }
    ```

    **5. createMcpHandler** with tool registrations:

    Register four tools inside the createMcpHandler callback:

    a) **list_skills** - Same logic as handleListSkills but inline:
       - Input: { category?: enum, limit: number(1-50, default 20) }
       - Fetches skills from db.query.skills.findMany(), filters by category if provided
       - Tracks usage with userId from authInfo
       - Returns JSON with { count, skills }
       - NO nudge logic (HTTP requires auth)

    b) **search_skills** - Same logic as handleSearchSkills but inline:
       - Input: { query: string, category?: enum, limit: number(1-25, default 10) }
       - Fetches all skills, filters by query (case-insensitive match on name/description) and category
       - Tracks usage
       - Returns JSON with { query, count, skills }

    c) **deploy_skill** - Same logic as handleDeploySkill but with HTTP response:
       - Input: { skillId: string }
       - Looks up skill by ID
       - Tracks usage (with skillId)
       - Returns JSON with { success, skill: { id, name, category, content, hoursSaved }, message: "This skill is now available in this conversation. You can use it directly." }
       - NO file system instructions (this is browser context)

    d) **server_info** - New tool:
       - Input: {} (no params)
       - Returns JSON with { name: "Relay Skills", version: "1.0.0", categories: ["prompt", "workflow", "agent", "mcp"], user: { id: userId } }
       - userId extracted from authInfo

    For each tool, extract userId from extra.authInfo:
    ```typescript
    const userId = (extra.authInfo as { extra?: { userId?: string } })?.extra?.userId;
    ```

    Check rate limit after extracting userId, before tool logic. If rate limited, return MCP error content:
    ```typescript
    { content: [{ type: "text", text: JSON.stringify({ error: "Rate limit exceeded. Try again in 60 seconds." }) }], isError: true }
    ```

    **6. Handler options:**
    ```typescript
    {}, // serverOptions (defaults)
    { basePath: "/api/mcp", maxDuration: 60 }
    ```

    **7. withMcpAuth wrapper:**
    ```typescript
    const authHandler = withMcpAuth(
      handler,
      async (_req: Request, bearerToken?: string) => {
        if (!bearerToken) return undefined;
        const result = await validateApiKey(bearerToken);
        if (!result) return undefined;
        return {
          token: bearerToken,
          clientId: result.keyId,
          scopes: [],
          extra: { userId: result.userId },
        };
      },
      { required: true }
    );
    ```

    **8. OPTIONS handler for CORS preflight:**
    ```typescript
    export async function OPTIONS(request: Request) {
      const origin = request.headers.get("Origin") ?? "";
      const allowedOrigin = ALLOWED_ORIGINS.includes(origin) ? origin : "";
      return new Response(null, {
        status: 204,
        headers: {
          "Access-Control-Allow-Origin": allowedOrigin,
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS, DELETE",
          "Access-Control-Allow-Headers": "Content-Type, Authorization, Mcp-Session-Id",
          "Access-Control-Expose-Headers": "Mcp-Session-Id",
          "Access-Control-Max-Age": "86400",
        },
      });
    }
    ```

    **9. Exports:**
    ```typescript
    export { authHandler as GET, authHandler as POST, authHandler as DELETE };
    ```
    Note: DELETE is needed by MCP protocol for session termination.

    **IMPORTANT DECISIONS:**
    - Inline the tool logic rather than importing from apps/mcp (cross-app imports are fragile in this monorepo setup where apps/mcp uses NodeNext module resolution with .js extensions). The tool logic is straightforward DB queries.
    - Skip anonymous nudge entirely for HTTP (auth is required, so anonymous is impossible).
    - Skip getFirstAuthMessage for HTTP (it's a stdio-specific one-time message).
    - Rate limit check happens inside each tool handler after userId extraction.
  </action>
  <verify>
    Run `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit` to confirm no type errors.
    Run `cd /home/dev/projects/relay/apps/web && npx next build 2>&1 | tail -20` to confirm the route compiles in the Next.js build.
    Verify the file exports GET, POST, DELETE, and OPTIONS.
  </verify>
  <done>
    Route file exists at apps/web/app/api/mcp/[transport]/route.ts.
    Exports GET, POST, DELETE (via authHandler) and OPTIONS (CORS preflight).
    Four tools registered: list_skills, search_skills, deploy_skill, server_info.
    Bearer token auth via validateApiKey.
    Rate limiting at 60 req/min per API key.
    CORS allows claude.ai and claude.com.
    TypeScript and Next.js build pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Smoke test the MCP endpoint with curl</name>
  <files>apps/web/app/api/mcp/[transport]/route.ts</files>
  <action>
    Start the dev server and test the endpoint manually:

    1. Start dev server: `cd /home/dev/projects/relay/apps/web && npm run dev` (background)
    2. Wait for server ready

    3. Test OPTIONS (CORS preflight):
       ```
       curl -s -o /dev/null -w "%{http_code}" -X OPTIONS http://localhost:2000/api/mcp/mcp -H "Origin: https://claude.ai"
       ```
       Expected: 204

    4. Test POST without auth (should fail):
       ```
       curl -s -w "\n%{http_code}" -X POST http://localhost:2000/api/mcp/mcp -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"initialize","id":1,"params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}'
       ```
       Expected: 401

    5. If there's an API key in the database, test with auth:
       - Look for a test key or create one
       - Test initialize + tool call

    Fix any issues found during smoke testing. Common issues:
    - Import resolution errors (check @everyskill/db imports work from the route)
    - CORS headers not appearing (check OPTIONS handler)
    - Auth callback not receiving token (check withMcpAuth configuration)

    If the dev server can't start due to build errors, fix those first.
  </action>
  <verify>
    OPTIONS to /api/mcp/mcp with Origin: https://claude.ai returns 204 with correct CORS headers.
    POST to /api/mcp/mcp without Authorization returns 401.
    The route file compiles and the dev server starts without errors.
  </verify>
  <done>
    MCP endpoint responds correctly to CORS preflight.
    Unauthenticated requests are rejected with 401.
    Dev server starts and serves the route without errors.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit` passes
2. Route file exists with GET, POST, DELETE, OPTIONS exports
3. CORS preflight returns proper headers for Claude.ai origin
4. Unauthenticated POST returns 401
5. Rate limiter function exists and limits to 60/min
</verification>

<success_criteria>
- MCP Streamable HTTP endpoint at /api/mcp/[transport] is functional
- Bearer token auth validates rlk_ API keys via existing validateApiKey
- Four tools registered: list_skills, search_skills, deploy_skill, server_info
- Deploy returns browser-friendly message (no file system instructions)
- CORS allows claude.ai and claude.com origins
- Rate limiting at 60 req/min per API key
- Smoke test confirms 401 on unauth and 204 on CORS preflight
</success_criteria>

<output>
After completion, create `.planning/phases/22-web-remote-mcp/22-02-SUMMARY.md`
</output>
