---
phase: 14-mobile-accessibility-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/hooks/use-roving-tabindex.ts
  - apps/web/lib/accessibility.ts
autonomous: true

must_haves:
  truths:
    - "Hook provides keyboard navigation for grid-like components"
    - "Arrow keys move focus between rows and cells"
    - "Live region announcer can broadcast messages to screen readers"
  artifacts:
    - path: "apps/web/hooks/use-roving-tabindex.ts"
      provides: "Roving tabindex hook for grid navigation"
      exports: ["useRovingTabindex"]
    - path: "apps/web/lib/accessibility.ts"
      provides: "Screen reader announcement utilities"
      exports: ["announceToScreenReader"]
  key_links:
    - from: "use-roving-tabindex.ts"
      to: "skills-table.tsx"
      via: "imported and used for keyboard nav"
      pattern: "useRovingTabindex"
    - from: "accessibility.ts"
      to: "sortable-column-header.tsx"
      via: "imported for sort announcements"
      pattern: "announceToScreenReader"
---

<objective>
Create accessibility infrastructure: a roving tabindex hook for grid keyboard navigation and a utility for screen reader live region announcements.

Purpose: Provides foundation for A11Y-01 (keyboard navigation) and A11Y-03 (sort announcements)
Output: Two reusable accessibility modules
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-mobile-accessibility-polish/14-CONTEXT.md
@.planning/phases/14-mobile-accessibility-polish/14-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRovingTabindex hook</name>
  <files>apps/web/hooks/use-roving-tabindex.ts</files>
  <action>
Create a new hook implementing the W3C APG Grid Pattern for keyboard navigation.

```typescript
"use client";

import { useState, useCallback, useRef, KeyboardEvent } from "react";

interface UseRovingTabindexOptions {
  rowCount: number;
  colCount: number;
  onFocusChange?: (rowIndex: number, colIndex: number) => void;
  wrap?: boolean;
}

interface UseRovingTabindexReturn {
  activeRow: number;
  activeCol: number;
  getTabIndex: (row: number, col: number) => 0 | -1;
  handleKeyDown: (e: KeyboardEvent) => void;
  registerCell: (row: number, col: number, element: HTMLElement | null) => void;
  setActiveCell: (row: number, col: number) => void;
}

export function useRovingTabindex({
  rowCount,
  colCount,
  onFocusChange,
  wrap = false,
}: UseRovingTabindexOptions): UseRovingTabindexReturn {
  const [activeRow, setActiveRow] = useState(0);
  const [activeCol, setActiveCol] = useState(0);
  const cellRefs = useRef<Map<string, HTMLElement>>(new Map());

  const focusCell = useCallback((row: number, col: number) => {
    const key = `${row}-${col}`;
    const element = cellRefs.current.get(key);
    if (element) {
      element.focus();
    }
  }, []);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      let newRow = activeRow;
      let newCol = activeCol;
      let handled = true;

      switch (e.key) {
        case "ArrowDown":
          newRow = wrap
            ? (activeRow + 1) % rowCount
            : Math.min(activeRow + 1, rowCount - 1);
          break;
        case "ArrowUp":
          newRow = wrap
            ? (activeRow - 1 + rowCount) % rowCount
            : Math.max(activeRow - 1, 0);
          break;
        case "ArrowRight":
          newCol = wrap
            ? (activeCol + 1) % colCount
            : Math.min(activeCol + 1, colCount - 1);
          break;
        case "ArrowLeft":
          newCol = wrap
            ? (activeCol - 1 + colCount) % colCount
            : Math.max(activeCol - 1, 0);
          break;
        case "Home":
          if (e.ctrlKey) {
            newRow = 0;
            newCol = 0;
          } else {
            newCol = 0;
          }
          break;
        case "End":
          if (e.ctrlKey) {
            newRow = rowCount - 1;
            newCol = colCount - 1;
          } else {
            newCol = colCount - 1;
          }
          break;
        default:
          handled = false;
      }

      if (handled) {
        e.preventDefault();
        setActiveRow(newRow);
        setActiveCol(newCol);
        focusCell(newRow, newCol);
        onFocusChange?.(newRow, newCol);
      }
    },
    [activeRow, activeCol, rowCount, colCount, wrap, focusCell, onFocusChange]
  );

  const getTabIndex = useCallback(
    (row: number, col: number): 0 | -1 =>
      row === activeRow && col === activeCol ? 0 : -1,
    [activeRow, activeCol]
  );

  const registerCell = useCallback(
    (row: number, col: number, element: HTMLElement | null) => {
      const key = `${row}-${col}`;
      if (element) {
        cellRefs.current.set(key, element);
      } else {
        cellRefs.current.delete(key);
      }
    },
    []
  );

  const setActiveCell = useCallback((row: number, col: number) => {
    setActiveRow(row);
    setActiveCol(col);
  }, []);

  return {
    activeRow,
    activeCol,
    getTabIndex,
    handleKeyDown,
    registerCell,
    setActiveCell,
  };
}
```

Key features:
- Arrow keys navigate between rows (Up/Down) and columns (Left/Right)
- Home/End move to first/last cell in row (Ctrl+Home/End for grid corners)
- Single tab stop (tabindex=0) on active cell, -1 on others
- Cell registration via refs for programmatic focus
- Optional wrap mode for circular navigation
- Callback for parent component to react to focus changes
  </action>
  <verify>
File exists: `ls apps/web/hooks/use-roving-tabindex.ts`
TypeScript compiles: `cd /home/claude/projects/relay && pnpm exec tsc --noEmit`
Exports useRovingTabindex: `grep -n "export function useRovingTabindex" apps/web/hooks/use-roving-tabindex.ts`
  </verify>
  <done>
useRovingTabindex hook is available for grid keyboard navigation with arrow keys, Home/End support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create accessibility announcer utility</name>
  <files>apps/web/lib/accessibility.ts</files>
  <action>
Create a utility module for screen reader announcements using ARIA live regions.

```typescript
/**
 * Accessibility utilities for screen reader support
 */

const ANNOUNCER_ID = "relay-sr-announcer";

/**
 * Get or create a visually-hidden live region for screen reader announcements.
 * Uses aria-live="polite" so announcements don't interrupt current speech.
 */
function getAnnouncer(): HTMLElement {
  let announcer = document.getElementById(ANNOUNCER_ID);

  if (!announcer) {
    announcer = document.createElement("div");
    announcer.id = ANNOUNCER_ID;
    announcer.setAttribute("aria-live", "polite");
    announcer.setAttribute("aria-atomic", "true");
    // Tailwind sr-only equivalent styles
    announcer.style.cssText = `
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    `;
    document.body.appendChild(announcer);
  }

  return announcer;
}

/**
 * Announce a message to screen readers via ARIA live region.
 *
 * @param message - The message to announce
 * @param clearDelay - Time in ms before clearing the region (default: 1000)
 *
 * @example
 * announceToScreenReader("Table sorted by Days Saved, descending");
 */
export function announceToScreenReader(
  message: string,
  clearDelay: number = 1000
): void {
  // Skip if running on server (SSR)
  if (typeof window === "undefined") return;

  const announcer = getAnnouncer();
  announcer.textContent = message;

  // Clear after delay to allow re-announcement of same message
  setTimeout(() => {
    announcer.textContent = "";
  }, clearDelay);
}
```

Key features:
- Lazily creates live region on first use
- Uses aria-live="polite" to not interrupt screen reader
- aria-atomic="true" ensures full message is read
- Visually hidden but accessible to screen readers
- Clears after announcement to allow repeated messages
- SSR-safe with window check
  </action>
  <verify>
File exists: `ls apps/web/lib/accessibility.ts`
TypeScript compiles: `cd /home/claude/projects/relay && pnpm exec tsc --noEmit`
Exports announceToScreenReader: `grep -n "export function announceToScreenReader" apps/web/lib/accessibility.ts`
  </verify>
  <done>
announceToScreenReader utility is available for broadcasting messages to screen readers via ARIA live region.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `pnpm exec tsc --noEmit` passes
2. Both files exist with correct exports
3. Hook provides arrow key navigation capability
4. Announcer utility handles SSR gracefully
</verification>

<success_criteria>
- useRovingTabindex hook exists with arrow key support
- announceToScreenReader utility exists for live region announcements
- Both modules compile without TypeScript errors
- No runtime dependencies on other phase 14 code (pure infrastructure)
</success_criteria>

<output>
After completion, create `.planning/phases/14-mobile-accessibility-polish/14-02-SUMMARY.md`
</output>
