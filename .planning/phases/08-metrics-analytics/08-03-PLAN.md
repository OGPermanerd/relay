---
phase: 08-metrics-analytics
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/trending.ts
autonomous: true

must_haves:
  truths:
    - "getTrendingSkills returns skills ordered by trending score"
    - "Trending score uses time-decay formula from research"
    - "Only skills with 3+ uses in 7 days appear in trending"
    - "Only published skills appear in trending"
  artifacts:
    - path: "apps/web/lib/trending.ts"
      provides: "Time-decay trending algorithm implementation"
      exports: ["getTrendingSkills", "TrendingSkill"]
      min_lines: 50
  key_links:
    - from: "apps/web/lib/trending.ts"
      to: "@everyskill/db"
      via: "Raw SQL CTE query"
      pattern: "db\\.execute\\(sql"
---

<objective>
Create trending skills algorithm using time-decay formula

Purpose: Surface skills with high recent usage velocity using Hacker News-style time decay
Output: apps/web/lib/trending.ts with getTrendingSkills function
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-metrics-analytics/08-RESEARCH.md

# Key existing patterns
@apps/web/lib/usage-trends.ts
@packages/db/src/schema/skills.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trending skills service</name>
  <files>apps/web/lib/trending.ts</files>
  <action>
Create trending.ts following research Pattern 3 (Time-Decay Trending Algorithm).

Implementation:
1. Export TrendingSkill interface with:
   - id: string
   - name: string
   - slug: string
   - description: string
   - category: string
   - recentUses: number
   - trendingScore: number
   - totalUses: number

2. Export async function getTrendingSkills(limit: number = 10): Promise<TrendingSkill[]>

3. Handle null db case - return empty array

4. Use raw SQL with db.execute(sql`...`) for the CTE query:

```sql
WITH skill_recent_usage AS (
  SELECT
    ue.skill_id,
    COUNT(*) as recent_uses,
    EXTRACT(EPOCH FROM (NOW() - MIN(s.created_at))) / 3600 as age_hours
  FROM usage_events ue
  JOIN skills s ON s.id = ue.skill_id
  WHERE ue.created_at >= NOW() - INTERVAL '7 days'
    AND s.published_version_id IS NOT NULL
  GROUP BY ue.skill_id
  HAVING COUNT(*) >= 3  -- minimum threshold
)
SELECT
  s.id,
  s.name,
  s.slug,
  s.description,
  s.category,
  sru.recent_uses::integer,
  ((sru.recent_uses - 1) / POWER(sru.age_hours + 2, 1.8))::double precision as trending_score,
  s.total_uses
FROM skill_recent_usage sru
JOIN skills s ON s.id = sru.skill_id
ORDER BY trending_score DESC
LIMIT ${limit}
```

5. Return results.rows cast to TrendingSkill[]

The formula (recent_uses - 1) / (age_hours + 2)^1.8 is the Hacker News algorithm:
- recent_uses - 1: Subtracting 1 to avoid initial spike bias
- age_hours + 2: Add 2 to prevent division by zero for brand new skills
- ^1.8: Gravity factor - higher values cause faster decay
  </action>
  <verify>
Run `cd /home/claude/projects/relay && pnpm tsc --noEmit -p apps/web/tsconfig.json` - no type errors
  </verify>
  <done>
getTrendingSkills function exists, compiles without errors, uses time-decay formula with 7-day window and 3-use minimum threshold
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `pnpm tsc --noEmit -p apps/web/tsconfig.json`
2. File exists at apps/web/lib/trending.ts
3. Exports getTrendingSkills and TrendingSkill type
</verification>

<success_criteria>
- Trending service created with Hacker News time-decay formula
- Uses 7-day lookback window
- Requires minimum 3 uses to qualify for trending
- Only includes published skills
- Handles null db gracefully (returns empty array)
</success_criteria>

<output>
After completion, create `.planning/phases/08-metrics-analytics/08-03-SUMMARY.md`
</output>
