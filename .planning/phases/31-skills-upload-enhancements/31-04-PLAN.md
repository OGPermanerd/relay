---
phase: 31-skills-upload-enhancements
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/skill-messages.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/relations/index.ts
  - packages/db/src/services/skill-messages.ts
  - packages/db/src/services/index.ts
  - packages/db/src/migrations/0010_create_skill_messages.sql
autonomous: true

must_haves:
  truths:
    - "skill_messages table exists in the database with RLS tenant isolation"
    - "CRUD service functions exist for creating and querying skill messages"
    - "Relations are defined between skill_messages and users/skills"
  artifacts:
    - path: "packages/db/src/schema/skill-messages.ts"
      provides: "skill_messages table schema with RLS policy"
      exports: ["skillMessages", "SkillMessage", "NewSkillMessage"]
    - path: "packages/db/src/services/skill-messages.ts"
      provides: "Service functions for skill message CRUD"
      exports: ["sendSkillMessage", "getMessagesForUser", "markMessageRead"]
    - path: "packages/db/src/migrations/0010_create_skill_messages.sql"
      provides: "SQL migration creating skill_messages table with indexes and RLS"
  key_links:
    - from: "packages/db/src/schema/skill-messages.ts"
      to: "packages/db/src/schema/skills.ts"
      via: "FK references to skills.id"
      pattern: "references.*skills\\.id"
    - from: "packages/db/src/schema/index.ts"
      to: "packages/db/src/schema/skill-messages.ts"
      via: "re-export"
      pattern: 'export.*skill-messages'
---

<objective>
Create the skill_messages database table, schema, migration, and service functions (SKILL-04 foundation).

Purpose: Enables the "message author" feature by establishing the data layer for proposing skill grouping.
Output: New DB table, Drizzle schema, migration, and service module.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@packages/db/src/schema/index.ts
@packages/db/src/relations/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill_messages schema and migration</name>
  <files>
    packages/db/src/schema/skill-messages.ts
    packages/db/src/schema/index.ts
    packages/db/src/migrations/0010_create_skill_messages.sql
  </files>
  <action>
    1. Create `packages/db/src/schema/skill-messages.ts`:
       ```typescript
       import { pgTable, text, timestamp, index, pgPolicy } from "drizzle-orm/pg-core";
       import { sql } from "drizzle-orm";
       import { tenants } from "./tenants";
       import { users } from "./users";
       import { skills } from "./skills";

       export const skillMessages = pgTable("skill_messages", {
         id: text("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
         tenantId: text("tenant_id").notNull().references(() => tenants.id),
         fromUserId: text("from_user_id").notNull().references(() => users.id),
         toUserId: text("to_user_id").notNull().references(() => users.id),
         subjectSkillId: text("subject_skill_id").notNull().references(() => skills.id, { onDelete: "cascade" }),
         proposedParentSkillId: text("proposed_parent_skill_id").references(() => skills.id, { onDelete: "set null" }),
         message: text("message").notNull(),
         status: text("status").notNull().default("pending"), // pending | accepted | declined
         createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
         readAt: timestamp("read_at", { withTimezone: true }),
       }, (table) => [
         index("skill_messages_to_user_idx").on(table.toUserId),
         index("skill_messages_tenant_id_idx").on(table.tenantId),
         index("skill_messages_from_user_idx").on(table.fromUserId),
         pgPolicy("tenant_isolation", {
           as: "restrictive",
           for: "all",
           using: sql`tenant_id = current_setting('app.current_tenant_id', true)`,
           withCheck: sql`tenant_id = current_setting('app.current_tenant_id', true)`,
         }),
       ]);

       export type SkillMessage = typeof skillMessages.$inferSelect;
       export type NewSkillMessage = typeof skillMessages.$inferInsert;
       ```

    2. Add to `packages/db/src/schema/index.ts`:
       ```typescript
       export * from "./skill-messages";
       ```

    3. Create `packages/db/src/migrations/0010_create_skill_messages.sql`:
       ```sql
       -- Create skill_messages table for author-to-author grouping proposals
       CREATE TABLE IF NOT EXISTS skill_messages (
         id text PRIMARY KEY,
         tenant_id text NOT NULL REFERENCES tenants(id),
         from_user_id text NOT NULL REFERENCES users(id),
         to_user_id text NOT NULL REFERENCES users(id),
         subject_skill_id text NOT NULL REFERENCES skills(id) ON DELETE CASCADE,
         proposed_parent_skill_id text REFERENCES skills(id) ON DELETE SET NULL,
         message text NOT NULL,
         status text NOT NULL DEFAULT 'pending',
         created_at timestamptz NOT NULL DEFAULT now(),
         read_at timestamptz
       );

       -- Indexes
       CREATE INDEX IF NOT EXISTS skill_messages_to_user_idx ON skill_messages(to_user_id);
       CREATE INDEX IF NOT EXISTS skill_messages_tenant_id_idx ON skill_messages(tenant_id);
       CREATE INDEX IF NOT EXISTS skill_messages_from_user_idx ON skill_messages(from_user_id);

       -- RLS
       ALTER TABLE skill_messages ENABLE ROW LEVEL SECURITY;
       CREATE POLICY tenant_isolation ON skill_messages
         AS RESTRICTIVE FOR ALL
         USING (tenant_id = current_setting('app.current_tenant_id', true))
         WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));
       ```

    4. Run the migration: `cd packages/db && psql "$DATABASE_URL" -f src/migrations/0010_create_skill_messages.sql`
  </action>
  <verify>
    - `psql "$DATABASE_URL" -c "\d skill_messages"` shows all columns
    - `psql "$DATABASE_URL" -c "SELECT polname FROM pg_policy WHERE polrelid = 'skill_messages'::regclass"` shows tenant_isolation
    - `cd packages/db && npx tsc --noEmit` passes
  </verify>
  <done>
    - skill_messages table exists with all columns, FKs, indexes, and RLS policy
    - Schema exported from packages/db/src/schema/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create relations and service functions</name>
  <files>
    packages/db/src/relations/index.ts
    packages/db/src/services/skill-messages.ts
    packages/db/src/services/index.ts
  </files>
  <action>
    1. In `packages/db/src/relations/index.ts`:
       - Import `skillMessages` from `"../schema"`
       - Add skillMessages relations:
         ```typescript
         export const skillMessagesRelations = relations(skillMessages, ({ one }) => ({
           tenant: one(tenants, { fields: [skillMessages.tenantId], references: [tenants.id] }),
           fromUser: one(users, { fields: [skillMessages.fromUserId], references: [users.id], relationName: "sentMessages" }),
           toUser: one(users, { fields: [skillMessages.toUserId], references: [users.id], relationName: "receivedMessages" }),
           subjectSkill: one(skills, { fields: [skillMessages.subjectSkillId], references: [skills.id], relationName: "subjectMessages" }),
           proposedParentSkill: one(skills, { fields: [skillMessages.proposedParentSkillId], references: [skills.id], relationName: "parentMessages" }),
         }));
         ```

    2. Create `packages/db/src/services/skill-messages.ts`:
       ```typescript
       import { eq, desc, and, isNull } from "drizzle-orm";
       import { db } from "../client";
       import { skillMessages } from "../schema";
       import type { NewSkillMessage } from "../schema";

       export async function sendSkillMessage(data: Omit<NewSkillMessage, "id" | "createdAt" | "readAt" | "status">): Promise<string | null> {
         if (!db) return null;
         const [row] = await db.insert(skillMessages).values(data).returning({ id: skillMessages.id });
         return row?.id ?? null;
       }

       export async function getMessagesForUser(userId: string): Promise<(typeof skillMessages.$inferSelect)[]> {
         if (!db) return [];
         return db.select().from(skillMessages)
           .where(eq(skillMessages.toUserId, userId))
           .orderBy(desc(skillMessages.createdAt))
           .limit(50);
       }

       export async function getUnreadCountForUser(userId: string): Promise<number> {
         if (!db) return 0;
         const results = await db.select({ id: skillMessages.id }).from(skillMessages)
           .where(and(eq(skillMessages.toUserId, userId), isNull(skillMessages.readAt)));
         return results.length;
       }

       export async function markMessageRead(messageId: string): Promise<void> {
         if (!db) return;
         await db.update(skillMessages)
           .set({ readAt: new Date() })
           .where(eq(skillMessages.id, messageId));
       }

       export async function updateMessageStatus(messageId: string, status: "accepted" | "declined"): Promise<void> {
         if (!db) return;
         await db.update(skillMessages)
           .set({ status })
           .where(eq(skillMessages.id, messageId));
       }
       ```

    3. In `packages/db/src/services/index.ts`, add:
       ```typescript
       export * from "./skill-messages";
       ```
  </action>
  <verify>
    - `cd packages/db && npx tsc --noEmit` passes
    - `cd apps/web && npx tsc --noEmit` passes (no breakage from new exports)
  </verify>
  <done>
    - skillMessages relations defined linking to users, skills, tenants
    - Service functions: sendSkillMessage, getMessagesForUser, getUnreadCountForUser, markMessageRead, updateMessageStatus
    - All exported from packages/db/src/services/index.ts
  </done>
</task>

</tasks>

<verification>
1. `psql "$DATABASE_URL" -c "SELECT count(*) FROM skill_messages"` -- returns 0 (table exists)
2. `cd packages/db && npx tsc --noEmit` -- clean compilation
3. `cd apps/web && pnpm build` -- successful build
</verification>

<success_criteria>
- skill_messages table created with RLS
- Schema, relations, and services all export cleanly
- No compilation errors across the monorepo
</success_criteria>

<output>
After completion, create `.planning/phases/31-skills-upload-enhancements/31-04-SUMMARY.md`
</output>
