---
phase: 67-skills-resume
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/resume-shares.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/relations/index.ts
  - packages/db/src/migrations/0036_add_resume_shares.sql
  - apps/web/middleware.ts
  - apps/web/lib/resume-queries.ts
  - apps/web/app/actions/resume-share.ts
autonomous: true

must_haves:
  truths:
    - "resume_shares table exists with token, userId, tenantId, includeCompanySkills, expiresAt, revokedAt columns"
    - "getResumeData(userId, includeCompanySkills) returns skills with quality badges, impact stats, and people helped"
    - "createResumeShare server action generates a unique token and stores it in resume_shares"
    - "revokeResumeShare server action sets revokedAt on the active share"
    - "getResumeByToken(token) returns resume data for valid, non-revoked, non-expired tokens"
    - "/r/ paths bypass middleware auth check"
  artifacts:
    - path: "packages/db/src/schema/resume-shares.ts"
      provides: "resume_shares table definition"
      contains: "pgTable"
    - path: "apps/web/lib/resume-queries.ts"
      provides: "getResumeData and getResumeByToken functions"
      exports: ["getResumeData", "getResumeByToken"]
    - path: "apps/web/app/actions/resume-share.ts"
      provides: "createResumeShare and revokeResumeShare server actions"
      exports: ["createResumeShare", "revokeResumeShare", "getActiveShare"]
  key_links:
    - from: "apps/web/lib/resume-queries.ts"
      to: "apps/web/lib/portfolio-queries.ts"
      via: "reuses query patterns for stats, skills"
      pattern: "getResumeData"
    - from: "apps/web/lib/resume-queries.ts"
      to: "apps/web/lib/quality-score.ts"
      via: "calculateQualityScore for badge computation"
      pattern: "calculateQualityScore"
    - from: "apps/web/app/actions/resume-share.ts"
      to: "packages/db/src/schema/resume-shares.ts"
      via: "INSERT/UPDATE on resume_shares table"
      pattern: "resume_shares"
---

<objective>
Create the data foundation for Skills Resume: schema for shareable resume tokens, data aggregation queries, server actions for share management, and middleware exemption for public access.

Purpose: All resume data fetching and share token management must exist before the UI can be built.
Output: resume_shares table, getResumeData/getResumeByToken queries, create/revoke server actions, /r/ middleware exemption.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/lib/portfolio-queries.ts
@apps/web/lib/quality-score.ts
@apps/web/lib/my-leverage.ts
@apps/web/middleware.ts
@packages/db/src/schema/index.ts
@packages/db/src/relations/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: resume_shares schema, migration, and middleware exemption</name>
  <files>
    packages/db/src/schema/resume-shares.ts
    packages/db/src/schema/index.ts
    packages/db/src/relations/index.ts
    packages/db/src/migrations/0036_add_resume_shares.sql
    apps/web/middleware.ts
  </files>
  <action>
1. Create `packages/db/src/schema/resume-shares.ts`:
   - Define `resumeShares` pgTable("resume_shares") with columns:
     - `id` text PK with $defaultFn(() => crypto.randomUUID())
     - `tenantId` text NOT NULL FK to tenants.id
     - `userId` text NOT NULL FK to users.id
     - `token` text NOT NULL with .unique()
     - `includeCompanySkills` boolean NOT NULL default false
     - `createdAt` timestamp NOT NULL defaultNow()
     - `expiresAt` timestamp (nullable -- null means never expires)
     - `revokedAt` timestamp (nullable -- null means active)
   - Follow exact pattern from `packages/db/src/schema/api-keys.ts` for FK references and imports.

2. Add `export * from "./resume-shares"` to `packages/db/src/schema/index.ts`.

3. Add `resumeShares` relations in `packages/db/src/relations/index.ts`:
   - Import `resumeShares` from schema.
   - Add `resumeSharesRelations = relations(resumeShares, ({ one }) => ({ user: one(users, { fields: [resumeShares.userId], references: [users.id] }), tenant: one(tenants, { fields: [resumeShares.tenantId], references: [tenants.id] }) }))`.

4. Create migration `packages/db/src/migrations/0036_add_resume_shares.sql`:
   ```sql
   CREATE TABLE IF NOT EXISTS resume_shares (
     id TEXT PRIMARY KEY,
     tenant_id TEXT NOT NULL REFERENCES tenants(id),
     user_id TEXT NOT NULL REFERENCES users(id),
     token TEXT NOT NULL UNIQUE,
     include_company_skills BOOLEAN NOT NULL DEFAULT false,
     created_at TIMESTAMP NOT NULL DEFAULT NOW(),
     expires_at TIMESTAMP,
     revoked_at TIMESTAMP
   );
   CREATE INDEX idx_resume_shares_token ON resume_shares(token);
   CREATE INDEX idx_resume_shares_user_id ON resume_shares(user_id);
   ```

5. Run migration: `cd /home/dev/projects/relay && pnpm db:migrate`

6. Add middleware exemption in `apps/web/middleware.ts`:
   - Add `pathname.startsWith("/r/")` to the exempt paths block (after the existing pathname checks, before the closing paren).
   - This allows `/r/[token]` pages to load without authentication.
  </action>
  <verify>
    - `pnpm db:migrate` completes without errors
    - `cd apps/web && npx tsc --noEmit` passes (schema exports + relations compile)
    - Verify middleware change: grep for `/r/` in middleware.ts
  </verify>
  <done>resume_shares table exists in DB, schema/relations exported, /r/ paths exempted from auth</done>
</task>

<task type="auto">
  <name>Task 2: Resume data queries and share server actions</name>
  <files>
    apps/web/lib/resume-queries.ts
    apps/web/app/actions/resume-share.ts
  </files>
  <action>
1. Create `apps/web/lib/resume-queries.ts`:

   Define interfaces:
   ```typescript
   export interface ResumeSkill {
     id: string;
     name: string;
     category: string;
     totalUses: number;
     hoursSaved: number;
     totalHoursSaved: number;
     avgRating: string | null;
     visibility: string;
     createdAt: string;
     qualityTier: string; // "Gold", "Silver", "Bronze", "Unrated", "No Badge"
     qualityScore: number;
     totalRatings: number;
   }

   export interface ResumeData {
     userName: string;
     skillsAuthored: number;
     totalHoursSaved: number;
     peopleHelped: number;
     estimatedValue: number; // totalHoursSaved * HOURLY_RATE
     skills: ResumeSkill[];
     qualityAchievements: { gold: number; silver: number; bronze: number };
     contributionSpan: { first: string | null; latest: string | null }; // ISO dates
   }
   ```

   Implement `getResumeData(userId: string, includeCompanySkills: boolean = false): Promise<ResumeData>`:
   - Build visibility filter: if includeCompanySkills is false, add `AND s.visibility = 'personal'`; if true, no filter (include all).
   - Run 3 parallel queries via Promise.all:
     a) Stats query (pattern from getPortfolioStats but with visibility filter):
        ```sql
        SELECT COUNT(*)::integer AS skills_authored,
               COALESCE(SUM(total_uses * COALESCE(hours_saved, 1)), 0)::double precision AS total_hours_saved
        FROM skills s
        WHERE s.author_id = $userId AND s.published_version_id IS NOT NULL AND s.status = 'published' ${visibilityFilter}
        ```
     b) Skills list query (pattern from getPortfolioSkills but with visibility filter and additional total_ratings subquery):
        ```sql
        SELECT s.id, s.name, s.category, COALESCE(s.total_uses, 0)::integer AS total_uses,
               COALESCE(s.hours_saved, 1)::integer AS hours_saved,
               (COALESCE(s.total_uses, 0) * COALESCE(s.hours_saved, 1))::double precision AS total_hours_saved,
               CASE WHEN s.average_rating IS NOT NULL AND s.average_rating > 0 THEN (s.average_rating / 100.0)::numeric(3,1)::text ELSE NULL END AS avg_rating,
               s.visibility, s.created_at, s.description,
               (SELECT COUNT(*)::integer FROM ratings r WHERE r.skill_id = s.id) AS total_ratings
        FROM skills s
        WHERE s.author_id = $userId AND s.published_version_id IS NOT NULL AND s.status = 'published' ${visibilityFilter}
        ORDER BY total_hours_saved DESC
        ```
     c) People helped query (pattern from my-leverage.ts getSkillsCreatedStats):
        ```sql
        SELECT COUNT(DISTINCT ue.user_id)::integer AS people_helped
        FROM usage_events ue JOIN skills s ON s.id = ue.skill_id
        WHERE s.author_id = $userId AND s.published_version_id IS NOT NULL AND s.status = 'published' ${visibilityFilter}
        ```
   - Also query user name: `SELECT name FROM users WHERE id = $userId LIMIT 1`
   - For each skill, compute quality tier using `calculateQualityScore()` from `@/lib/quality-score.ts`:
     ```typescript
     const result = calculateQualityScore({
       totalUses: skill.totalUses,
       averageRating: skill.avgRatingRaw, // raw integer value from DB (not divided by 100)
       totalRatings: skill.totalRatings,
       hasDescription: !!skill.description,
       hasCategory: !!skill.category,
     });
     ```
     Map tier to display label: gold -> "Gold", silver -> "Silver", bronze -> "Bronze", unrated -> "Unrated", none -> "No Badge".
     Use `QUALITY_TIERS` from quality-score.ts for label lookup.
   - Count qualityAchievements: { gold: count of gold skills, silver: count of silver skills, bronze: count of bronze skills }.
   - Compute contributionSpan from skills list: first = earliest createdAt, latest = most recent createdAt.
   - Import `HOURLY_RATE` from `@/lib/ip-valuation` for estimatedValue calculation.
   - Use `sql.raw()` for the visibility filter string interpolation (safe since it's a static string, not user input). Pattern: `const visibilityClause = includeCompanySkills ? sql`` : sql`AND s.visibility = 'personal'`;`

   Implement `getResumeByToken(token: string): Promise<ResumeData | null>`:
   - First query resume_shares to find a valid share: `SELECT user_id, tenant_id, include_company_skills FROM resume_shares WHERE token = $token AND revoked_at IS NULL AND (expires_at IS NULL OR expires_at > NOW()) LIMIT 1`
   - If no result, return null.
   - Call `getResumeData(userId, includeCompanySkills)` with the values from the share record.

2. Create `apps/web/app/actions/resume-share.ts`:
   - Add `"use server"` at top.
   - Import `auth` from `@/auth`, `db` from `@everyskill/db`, `sql` from `drizzle-orm`.

   Implement `createResumeShare(includeCompanySkills: boolean = false)`:
   - Get session, require auth.
   - Generate token via `crypto.randomUUID()`.
   - First revoke any existing active share for the user: `UPDATE resume_shares SET revoked_at = NOW() WHERE user_id = $userId AND revoked_at IS NULL`
   - Then insert new share: `INSERT INTO resume_shares (id, tenant_id, user_id, token, include_company_skills) VALUES ($id, $tenantId, $userId, $token, $includeCompanySkills)`
   - Return `{ token, url: \`/r/\${token}\` }`.

   Implement `revokeResumeShare()`:
   - Get session, require auth.
   - `UPDATE resume_shares SET revoked_at = NOW() WHERE user_id = $userId AND revoked_at IS NULL`

   Implement `getActiveShare()`:
   - Get session, require auth.
   - `SELECT token, include_company_skills FROM resume_shares WHERE user_id = $userId AND revoked_at IS NULL AND (expires_at IS NULL OR expires_at > NOW()) ORDER BY created_at DESC LIMIT 1`
   - Return `{ token, includeCompanySkills, url }` or null if no active share.
  </action>
  <verify>
    - `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit` compiles without errors
    - Verify resume-queries.ts exports: grep for "getResumeData" and "getResumeByToken"
    - Verify server actions: grep for "createResumeShare" and "revokeResumeShare" and "getActiveShare"
  </verify>
  <done>getResumeData returns skills with quality badges and people helped; getResumeByToken resolves public tokens; server actions create/revoke share tokens</done>
</task>

</tasks>

<verification>
- resume_shares table created via migration
- Schema and relations compile (`tsc --noEmit`)
- Middleware allows /r/ paths without auth (grep confirmation)
- resume-queries.ts exports ResumeData, ResumeSkill, getResumeData, getResumeByToken
- resume-share.ts exports createResumeShare, revokeResumeShare, getActiveShare
</verification>

<success_criteria>
- resume_shares table exists with all required columns (token, userId, tenantId, includeCompanySkills, expiresAt, revokedAt)
- getResumeData returns aggregated resume data with quality badges computed via calculateQualityScore
- Server actions manage share tokens (create with revoke-and-replace, revoke, get active)
- /r/ paths bypass auth middleware
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/67-skills-resume/67-01-SUMMARY.md`
</output>
