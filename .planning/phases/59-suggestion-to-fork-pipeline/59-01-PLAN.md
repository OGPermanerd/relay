---
phase: 59-suggestion-to-fork-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/skill-feedback.ts
  - packages/db/src/migrations/0034_add_implemented_by_skill_id.sql
  - packages/db/src/services/skill-feedback.ts
  - apps/web/app/actions/skill-feedback.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "skill_feedback table has implemented_by_skill_id column referencing skills(id)"
    - "acceptAndForkSuggestion server action creates a fork pre-populated with suggestion content and links suggestion to fork"
    - "applyInlineSuggestion server action updates skill content directly and creates a version record"
    - "autoImplementLinkedSuggestions DB function transitions accepted->implemented for linked suggestions"
  artifacts:
    - path: "packages/db/src/schema/skill-feedback.ts"
      provides: "implementedBySkillId column on skillFeedback table"
      contains: "implementedBySkillId"
    - path: "packages/db/src/migrations/0034_add_implemented_by_skill_id.sql"
      provides: "Migration adding the new column and index"
      contains: "implemented_by_skill_id"
    - path: "packages/db/src/services/skill-feedback.ts"
      provides: "autoImplementLinkedSuggestions() and linkSuggestionToSkill()"
      exports: ["autoImplementLinkedSuggestions", "linkSuggestionToSkill"]
    - path: "apps/web/app/actions/skill-feedback.ts"
      provides: "acceptAndForkSuggestion() and applyInlineSuggestion() server actions"
      exports: ["acceptAndForkSuggestion", "applyInlineSuggestion"]
  key_links:
    - from: "apps/web/app/actions/skill-feedback.ts"
      to: "packages/db/src/services/skill-feedback.ts"
      via: "autoImplementLinkedSuggestions import"
      pattern: "autoImplementLinkedSuggestions"
    - from: "apps/web/app/actions/skill-feedback.ts"
      to: "packages/db/src/schema/skill-feedback.ts"
      via: "implementedBySkillId column used in fork linking"
      pattern: "implementedBySkillId"
---

<objective>
Add the `implementedBySkillId` column to skill_feedback, create DB service functions for linking suggestions to forks, and build two server actions: "Accept & Fork" (creates fork pre-populated with suggestion content) and "Apply Inline" (updates skill content + creates version record).

Purpose: Backend foundation for the suggestion-to-fork pipeline. All schema, DB service, and server action work lives here so Plan 02 can wire UI and publish hooks cleanly.
Output: Migration 0034, updated schema, DB services, and two new server actions.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-suggestion-to-fork-pipeline/59-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration and DB service functions</name>
  <files>
    packages/db/src/schema/skill-feedback.ts
    packages/db/src/migrations/0034_add_implemented_by_skill_id.sql
    packages/db/src/services/skill-feedback.ts
    packages/db/src/relations/index.ts
  </files>
  <action>
1. **Schema** (`packages/db/src/schema/skill-feedback.ts`):
   Add `implementedBySkillId` column to the `skillFeedback` table:
   ```ts
   implementedBySkillId: text("implemented_by_skill_id").references(() => skills.id),
   ```
   Add an index in the table's third argument array:
   ```ts
   index("skill_feedback_implemented_by_idx").on(table.implementedBySkillId),
   ```

2. **Migration** (`packages/db/src/migrations/0034_add_implemented_by_skill_id.sql`):
   ```sql
   -- Add implemented_by_skill_id column to skill_feedback for suggestion-to-fork traceability
   ALTER TABLE skill_feedback ADD COLUMN implemented_by_skill_id TEXT REFERENCES skills(id);
   CREATE INDEX skill_feedback_implemented_by_idx ON skill_feedback(implemented_by_skill_id);
   ```

3. **Relations** (`packages/db/src/relations/index.ts`):
   In `skillFeedbackRelations`, add:
   ```ts
   implementedBySkill: one(skills, {
     fields: [skillFeedback.implementedBySkillId],
     references: [skills.id],
     relationName: "implementedBySuggestion",
   }),
   ```

4. **DB Service** (`packages/db/src/services/skill-feedback.ts`):
   Add two new exported functions:

   a) `linkSuggestionToSkill(params: { feedbackId: string; skillId: string; reviewerId: string })`:
      - Updates skill_feedback row: set `implementedBySkillId = skillId`, `status = "accepted"`, `reviewedBy = reviewerId`, `reviewedAt = new Date()`
      - Returns `{ success: boolean }`

   b) `autoImplementLinkedSuggestions(skillId: string)`:
      - Queries skill_feedback where `implementedBySkillId = skillId` AND `status = 'accepted'`
      - For each match, updates status to `"implemented"` and `reviewedAt = new Date()`
      - Returns count of updated rows (for logging)
      - This is designed to be called fire-and-forget after publish

   Also update `SuggestionWithUser` interface to include `implementedBySkillId: string | null`.

   Update `getSuggestionsForSkill` query to select `skillFeedback.implementedBySkillId`.

5. Run migration: `cd /home/dev/projects/relay && pnpm db:migrate`
  </action>
  <verify>
    - `pnpm db:migrate` completes without error
    - `cd /home/dev/projects/relay && pnpm --filter @everyskill/db typecheck` passes
    - Query the column exists: `psql everyskill -c "SELECT column_name FROM information_schema.columns WHERE table_name='skill_feedback' AND column_name='implemented_by_skill_id';"` returns 1 row
  </verify>
  <done>
    - `implemented_by_skill_id` column exists on skill_feedback with FK to skills and index
    - `linkSuggestionToSkill()` and `autoImplementLinkedSuggestions()` are exported from skill-feedback service
    - `SuggestionWithUser` includes `implementedBySkillId`
    - `getSuggestionsForSkill` returns the new field
  </done>
</task>

<task type="auto">
  <name>Task 2: Accept & Fork and Apply Inline server actions</name>
  <files>
    apps/web/app/actions/skill-feedback.ts
  </files>
  <action>
Add two new server actions to `apps/web/app/actions/skill-feedback.ts`:

1. **`acceptAndForkSuggestion`** server action:
   - Signature: `async function acceptAndForkSuggestion(feedbackId: string): Promise<{ error?: string }>`
   - NOT a useActionState form action -- it's called directly via async handler (matching the existing pattern in suggestion-card.tsx where handleStatusUpdate calls server actions directly).
   - Steps:
     a. `auth()` check, get session.user.id and tenantId
     b. Fetch the suggestion: `db.query.skillFeedback.findFirst({ where: eq(skillFeedback.id, feedbackId), columns: { skillId, suggestedContent, comment, status, feedbackType } })`
     c. Validate: feedbackType === "suggestion", status === "pending" or "accepted"
     d. Fetch the parent skill: `db.query.skills.findFirst({ where: eq(skills.id, suggestion.skillId), columns: { id, name, description, category, content, tags, visibility, authorId, hoursSaved } })`
     e. Verify `skill.authorId === session.user.id` (or isAdmin)
     f. Strip frontmatter from parent content using the same regex pattern as `fork-skill.ts`: `content.match(/^---\n[\s\S]*?\n---\n/)` then slice
     g. Determine fork content: if `suggestion.suggestedContent` exists and is non-empty, use it as raw body; otherwise use stripped parent content
     h. Generate slug: `await generateUniqueSlug(forkName, db)` where `forkName = \`${skill.name} (Fork)\``
     i. Compute `forkedAtContentHash` from stripped parent body (same as fork-skill.ts pattern)
     j. Insert new skill with: `tenantId`, `name: forkName`, `slug`, `description: skill.description`, `category: skill.category`, `content: forkContent` (raw, no frontmatter -- frontmatter gets added during publish), `tags: skill.tags`, `hoursSaved: skill.hoursSaved || 0`, `forkedFromId: skill.id`, `forkedAtContentHash`, `authorId: session.user.id`, `status: "draft"`, `visibility: "personal"`
     k. Create skill_versions record: `version: 1`, `contentUrl: ""`, `contentHash` from fork content, `name: forkName`, `description: skill.description`, `createdBy: session.user.id`
     l. Set `publishedVersionId` on the new skill
     m. Link suggestion: update skill_feedback row with `implementedBySkillId: newSkill.id`, `status: "accepted"`, `reviewedBy: session.user.id`, `reviewedAt: new Date()`
     n. Fire-and-forget: `generateSkillEmbedding(newSkill.id, forkName, skill.description, tenantId).catch(() => {})`
     o. `revalidatePath("/skills")` and `revalidatePath(\`/skills/${newSkill.slug}\`)`
     p. `redirect(\`/skills/${newSkill.slug}?improve=1\`)` -- MUST be outside try/catch (Next.js redirect throws)

   - Imports needed: `auth` from "@/auth", `isAdmin` from "@/lib/admin", `db, skills, skillFeedback` from "@everyskill/db", `skillVersions` from "@everyskill/db/schema/skill-versions", `eq` from "drizzle-orm", `revalidatePath` from "next/cache", `redirect` from "next/navigation", `generateUniqueSlug` from "@/lib/slug", `generateSkillEmbedding` from "@/lib/embedding-generator", `hashContent` from "@/lib/content-hash"

2. **`applyInlineSuggestion`** server action:
   - Signature: `async function applyInlineSuggestion(feedbackId: string): Promise<{ success?: boolean; error?: string }>`
   - Steps:
     a. `auth()` check
     b. Fetch suggestion (must have feedbackType "suggestion", status "pending" or "accepted", suggestedContent non-empty)
     c. Fetch the skill, verify author owns it
     d. Strip existing frontmatter from `suggestedContent` using the same regex
     e. Rebuild full content: `buildEverySkillFrontmatter({ skillId: skill.id, name: skill.name, category: skill.category, hoursSaved: skill.hoursSaved || 0 }) + strippedSuggestedContent`
     f. Update `skills.content` with new content
     g. Compute content hash
     h. Query max version: `SELECT MAX(version) FROM skill_versions WHERE skill_id = ?`, then increment
     i. Insert new `skill_versions` record with `version: maxVersion + 1`, `contentUrl: ""`, `contentHash`, `name: skill.name`, `description: skill.description`, `createdBy: session.user.id`
     j. Update `skills.publishedVersionId` to new version id
     k. Update skill_feedback: `status: "implemented"`, `implementedBySkillId: skill.id`, `reviewedBy: session.user.id`, `reviewedAt: new Date()`
     l. `revalidatePath(\`/skills/${skillSlug}\`)`
     m. Return `{ success: true }`

   - The `buildEverySkillFrontmatter` function is in `apps/web/app/actions/skills.ts` but is NOT exported. Rather than modifying that file, copy the frontmatter helpers (`buildEverySkillFrontmatter` and `stripEverySkillFrontmatter`) into a shared utility at `apps/web/lib/frontmatter.ts` and import from there. Update `apps/web/app/actions/skills.ts` to import from the new location too (remove its local copies). This avoids duplicating the frontmatter logic.
   - Actually, simpler approach per project conventions: just import the strip pattern inline (regex) and for buildEverySkillFrontmatter, extract to `apps/web/lib/frontmatter.ts` exporting both functions, then update `apps/web/app/actions/skills.ts` to import from there.

   Additional file: `apps/web/lib/frontmatter.ts` (new file with extracted frontmatter helpers)
   Update file: `apps/web/app/actions/skills.ts` (replace local definitions with imports from frontmatter.ts)
  </action>
  <verify>
    - `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit` passes (typecheck the web app)
    - `pnpm build` succeeds (or at minimum `next lint` passes)
  </verify>
  <done>
    - `acceptAndForkSuggestion(feedbackId)` is exported from skill-feedback.ts server actions
    - `applyInlineSuggestion(feedbackId)` is exported from skill-feedback.ts server actions
    - Both actions link the suggestion to the resulting skill via `implementedBySkillId`
    - `acceptAndForkSuggestion` redirects to the new fork with `?improve=1`
    - `applyInlineSuggestion` creates a version record and marks suggestion as "implemented"
    - Frontmatter helpers extracted to `apps/web/lib/frontmatter.ts` (no duplication)
  </done>
</task>

</tasks>

<verification>
- Migration 0034 applied, column exists in database
- DB service typecheck passes
- Web app typecheck passes
- Both new server actions are exported and importable
- No duplicate frontmatter logic (extracted to shared util)
</verification>

<success_criteria>
- `implemented_by_skill_id` column exists on skill_feedback with proper FK and index
- `acceptAndForkSuggestion` creates fork with suggestion content pre-populated and links suggestion
- `applyInlineSuggestion` updates skill content, creates version record, marks suggestion implemented
- `autoImplementLinkedSuggestions` exists for use by publish hooks (Plan 02)
- All typechecks pass
</success_criteria>

<output>
After completion, create `.planning/phases/59-suggestion-to-fork-pipeline/59-01-SUMMARY.md`
</output>
