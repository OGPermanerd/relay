---
phase: 25-multi-tenancy-schema-audit
plan: 06
type: execute
wave: 3
depends_on: ["25-05"]
files_modified:
  - packages/db/src/migrations/0005_enforce_tenant_id.sql
  - packages/db/src/migrations/0006_create_audit_logs.sql
  - packages/db/src/migrations/meta/_journal.json
autonomous: true

must_haves:
  truths:
    - "Migration 0005 enforces NOT NULL, adds FKs, replaces slug unique with composite, enables RLS"
    - "Migration 0006 creates audit_logs table with a protective trigger preventing UPDATE/DELETE"
    - "Drizzle migration journal includes entries for migrations 0005-0006"
  artifacts:
    - path: "packages/db/src/migrations/0005_enforce_tenant_id.sql"
      provides: "NOT NULL + FK + composite unique + RLS policies"
    - path: "packages/db/src/migrations/0006_create_audit_logs.sql"
      provides: "Audit logs table + trigger protection"
    - path: "packages/db/src/migrations/meta/_journal.json"
      provides: "Drizzle migration journal with entries for 0005-0006"
  key_links:
    - from: "packages/db/src/migrations/0005_enforce_tenant_id.sql"
      to: "packages/db/src/migrations/0004_backfill_tenant_id.sql"
      via: "depends on backfill completing before enforcing NOT NULL"
      pattern: "ALTER TABLE.*ALTER COLUMN.*SET NOT NULL"
---

<objective>
Create the final 2 SQL migration files: enforce NOT NULL + FK + RLS constraints on all tenant_id columns, and create the append-only audit_logs table. Also update the Drizzle migration journal.

Purpose: These migrations complete the database transformation. Migration 0005 locks down tenant isolation at the database level with NOT NULL constraints, foreign keys, composite unique indexes, and Row Level Security policies. Migration 0006 creates the SOC2 compliance audit trail with trigger-based append-only protection.
Output: 2 SQL migration files and updated migration journal.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@packages/db/drizzle.config.ts
@.planning/phases/25-multi-tenancy-schema-audit/25-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration files 0005-0006 and update journal</name>
  <files>
    packages/db/src/migrations/0005_enforce_tenant_id.sql
    packages/db/src/migrations/0006_create_audit_logs.sql
    packages/db/src/migrations/meta/_journal.json
  </files>
  <action>
Create two SQL migration files for constraint enforcement and audit logging.

**File: `0005_enforce_tenant_id.sql`**
```sql
-- Enforce NOT NULL on all tenant_id columns
ALTER TABLE users ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE skills ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE ratings ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE usage_events ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE skill_versions ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE skill_embeddings ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE skill_reviews ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE api_keys ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE site_settings ALTER COLUMN tenant_id SET NOT NULL;

-- Add foreign key constraints
ALTER TABLE users ADD CONSTRAINT users_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE skills ADD CONSTRAINT skills_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE ratings ADD CONSTRAINT ratings_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE usage_events ADD CONSTRAINT usage_events_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE skill_versions ADD CONSTRAINT skill_versions_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE skill_embeddings ADD CONSTRAINT skill_embeddings_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE skill_reviews ADD CONSTRAINT skill_reviews_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE api_keys ADD CONSTRAINT api_keys_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE site_settings ADD CONSTRAINT site_settings_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);

-- Replace global unique constraints with composite unique constraints
-- Skills: slug is unique per tenant (not globally)
ALTER TABLE skills DROP CONSTRAINT IF EXISTS skills_slug_unique;
ALTER TABLE skills ADD CONSTRAINT skills_tenant_slug_unique UNIQUE (tenant_id, slug);

-- Skill embeddings: skill_id is unique per tenant
ALTER TABLE skill_embeddings DROP CONSTRAINT IF EXISTS skill_embeddings_skill_id_unique;
ALTER TABLE skill_embeddings ADD CONSTRAINT skill_embeddings_tenant_skill_unique UNIQUE (tenant_id, skill_id);

-- Skill reviews: skill_id is unique per tenant
ALTER TABLE skill_reviews DROP CONSTRAINT IF EXISTS skill_reviews_skill_id_unique;
ALTER TABLE skill_reviews ADD CONSTRAINT skill_reviews_tenant_skill_unique UNIQUE (tenant_id, skill_id);

-- Add tenant_id indexes for query performance
CREATE INDEX IF NOT EXISTS users_tenant_id_idx ON users (tenant_id);
CREATE INDEX IF NOT EXISTS skills_tenant_id_idx ON skills (tenant_id);
CREATE INDEX IF NOT EXISTS ratings_tenant_id_idx ON ratings (tenant_id);
CREATE INDEX IF NOT EXISTS usage_events_tenant_id_idx ON usage_events (tenant_id);
CREATE INDEX IF NOT EXISTS skill_versions_tenant_id_idx ON skill_versions (tenant_id);
CREATE INDEX IF NOT EXISTS skill_embeddings_tenant_id_idx ON skill_embeddings (tenant_id);
CREATE INDEX IF NOT EXISTS skill_reviews_tenant_id_idx ON skill_reviews (tenant_id);
CREATE INDEX IF NOT EXISTS api_keys_tenant_id_idx ON api_keys (tenant_id);
CREATE INDEX IF NOT EXISTS site_settings_tenant_id_idx ON site_settings (tenant_id);

-- Enable RLS on all tenant-scoped tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE usage_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE skill_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE skill_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE skill_reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE site_settings ENABLE ROW LEVEL SECURITY;

-- FORCE RLS so even table owners see filtered rows
ALTER TABLE users FORCE ROW LEVEL SECURITY;
ALTER TABLE skills FORCE ROW LEVEL SECURITY;
ALTER TABLE ratings FORCE ROW LEVEL SECURITY;
ALTER TABLE usage_events FORCE ROW LEVEL SECURITY;
ALTER TABLE skill_versions FORCE ROW LEVEL SECURITY;
ALTER TABLE skill_embeddings FORCE ROW LEVEL SECURITY;
ALTER TABLE skill_reviews FORCE ROW LEVEL SECURITY;
ALTER TABLE api_keys FORCE ROW LEVEL SECURITY;
ALTER TABLE site_settings FORCE ROW LEVEL SECURITY;

-- Create RLS policies for tenant isolation
-- Policy: rows are visible/writable only when tenant_id matches the session variable
CREATE POLICY tenant_isolation ON users FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON skills FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON ratings FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON usage_events FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON skill_versions FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON skill_embeddings FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON skill_reviews FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON api_keys FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON site_settings FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));
```

**File: `0006_create_audit_logs.sql`**
```sql
-- Create append-only audit_logs table
CREATE TABLE IF NOT EXISTS audit_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  actor_id text,
  tenant_id text,
  action text NOT NULL,
  resource_type text,
  resource_id text,
  ip_address text,
  metadata jsonb,
  created_at timestamptz DEFAULT now() NOT NULL
);

-- Indexes for efficient querying
CREATE INDEX IF NOT EXISTS audit_logs_tenant_created_idx ON audit_logs (tenant_id, created_at DESC);
CREATE INDEX IF NOT EXISTS audit_logs_actor_idx ON audit_logs (actor_id, created_at DESC);
CREATE INDEX IF NOT EXISTS audit_logs_action_idx ON audit_logs (action, created_at DESC);

-- Make append-only: create trigger to prevent UPDATE/DELETE
-- Using trigger approach (works regardless of database role setup)
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Direct modification of audit_logs is forbidden';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER no_audit_update
  BEFORE UPDATE OR DELETE ON audit_logs
  FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();

-- NOTE: When an app_user role is created in a later deployment phase,
-- add: REVOKE UPDATE, DELETE ON audit_logs FROM app_user;
```

**Important note on the REVOKE approach:** The current database likely runs as the postgres superuser (or the database owner role), so REVOKE won't be effective until a separate app_user role is created in a later phase. For now, the trigger-based protection is the reliable approach.

**Update `packages/db/src/migrations/meta/_journal.json`:**
Read the existing journal (which should already have entries for 0002-0004 from Plan 25-05), then append entries for migrations 0005 and 0006 following the same format. Set appropriate sequential idx values and timestamps.
  </action>
  <verify>
Verify all files exist:
```bash
ls -la packages/db/src/migrations/000{5,6}_*.sql
```
Verify SQL is syntactically reasonable (check for balanced parentheses, no obvious typos).
Verify the journal has entries for 0005-0006:
```bash
grep "0005\|0006" packages/db/src/migrations/meta/_journal.json
```
  </verify>
  <done>
Migration 0005 enforces NOT NULL + FK constraints, replaces global unique with composite unique, adds indexes, enables RLS + creates tenant isolation policies on all 9 tables. Migration 0006 creates audit_logs table with trigger-based append-only protection. Migration journal updated with entries for 0005-0006.
  </done>
</task>

</tasks>

<verification>
- 2 migration files exist in packages/db/src/migrations/
- 0005 enforces NOT NULL, FKs, composite uniques, indexes, RLS
- 0006 creates audit_logs with trigger protection
- Drizzle migration journal updated with entries for 0005-0006
</verification>

<success_criteria>
All 5 migration files (across Plans 25-05 and 25-06) are ready to run sequentially against the database. The migration journal references all of them. They implement the complete multi-step migration from single-tenant to multi-tenant with RLS and audit logging.
</success_criteria>

<output>
After completion, create `.planning/phases/25-multi-tenancy-schema-audit/25-06-SUMMARY.md`
</output>
