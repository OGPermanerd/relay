---
phase: 25-multi-tenancy-schema-audit
plan: 04
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - packages/db/src/migrations/0002_add_tenants.sql
  - packages/db/src/migrations/0003_add_tenant_id_columns.sql
  - packages/db/src/migrations/0004_backfill_tenant_id.sql
  - packages/db/src/migrations/0005_enforce_tenant_id.sql
  - packages/db/src/migrations/0006_create_audit_logs.sql
autonomous: true

must_haves:
  truths:
    - "Migration 0002 creates the tenants table and inserts a default tenant row"
    - "Migration 0003 adds nullable tenant_id column to all 9 data tables"
    - "Migration 0004 backfills all existing rows with the default tenant's ID"
    - "Migration 0005 enforces NOT NULL, adds FKs, replaces slug unique with composite, enables RLS"
    - "Migration 0006 creates audit_logs table with REVOKE UPDATE/DELETE and a protective trigger"
  artifacts:
    - path: "packages/db/src/migrations/0002_add_tenants.sql"
      provides: "Tenants table DDL + default tenant seed"
    - path: "packages/db/src/migrations/0003_add_tenant_id_columns.sql"
      provides: "Add nullable tenant_id to 9 tables"
    - path: "packages/db/src/migrations/0004_backfill_tenant_id.sql"
      provides: "Backfill tenant_id with default tenant"
    - path: "packages/db/src/migrations/0005_enforce_tenant_id.sql"
      provides: "NOT NULL + FK + composite unique + RLS policies"
    - path: "packages/db/src/migrations/0006_create_audit_logs.sql"
      provides: "Audit logs table + REVOKE + trigger"
  key_links:
    - from: "packages/db/src/migrations/0004_backfill_tenant_id.sql"
      to: "packages/db/src/migrations/0002_add_tenants.sql"
      via: "references default tenant created in 0002"
      pattern: "SELECT id FROM tenants WHERE slug"
---

<objective>
Create the 5 custom SQL migration files that implement the multi-step migration: create tenants table, add nullable columns, backfill, enforce constraints + RLS, and create audit_logs with protection.

Purpose: These migrations transform the existing single-tenant database into a multi-tenant database with RLS policies and an append-only audit trail. The multi-step approach ensures zero data loss and safe rollback at each step.
Output: 5 sequential SQL migration files ready to be run against the database.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@packages/db/drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration files 0002-0004 (tenants + add columns + backfill)</name>
  <files>
    packages/db/src/migrations/0002_add_tenants.sql
    packages/db/src/migrations/0003_add_tenant_id_columns.sql
    packages/db/src/migrations/0004_backfill_tenant_id.sql
  </files>
  <action>
Create three SQL migration files. These are custom migrations (not Drizzle-generated) for the multi-step nullable-to-NOT-NULL pattern.

**File: `0002_add_tenants.sql`**
```sql
-- Create tenants table
CREATE TABLE IF NOT EXISTS tenants (
  id text PRIMARY KEY DEFAULT gen_random_uuid()::text,
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  domain text,
  logo text,
  is_active boolean NOT NULL DEFAULT true,
  plan text NOT NULL DEFAULT 'freemium',
  created_at timestamp NOT NULL DEFAULT now(),
  updated_at timestamp NOT NULL DEFAULT now()
);

-- Seed a default tenant for backfilling existing data
INSERT INTO tenants (id, name, slug, domain)
VALUES ('default-tenant-000-0000-000000000000', 'Default', 'default', NULL)
ON CONFLICT (slug) DO NOTHING;
```

**File: `0003_add_tenant_id_columns.sql`**
```sql
-- Add nullable tenant_id to all 9 data tables
ALTER TABLE users ADD COLUMN IF NOT EXISTS tenant_id text;
ALTER TABLE skills ADD COLUMN IF NOT EXISTS tenant_id text;
ALTER TABLE ratings ADD COLUMN IF NOT EXISTS tenant_id text;
ALTER TABLE usage_events ADD COLUMN IF NOT EXISTS tenant_id text;
ALTER TABLE skill_versions ADD COLUMN IF NOT EXISTS tenant_id text;
ALTER TABLE skill_embeddings ADD COLUMN IF NOT EXISTS tenant_id text;
ALTER TABLE skill_reviews ADD COLUMN IF NOT EXISTS tenant_id text;
ALTER TABLE api_keys ADD COLUMN IF NOT EXISTS tenant_id text;
ALTER TABLE site_settings ADD COLUMN IF NOT EXISTS tenant_id text;
```

**File: `0004_backfill_tenant_id.sql`**
```sql
-- Backfill all existing rows with the default tenant ID
-- WHERE tenant_id IS NULL makes this idempotent (safe to re-run)
UPDATE users SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
UPDATE skills SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
UPDATE ratings SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
UPDATE usage_events SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
UPDATE skill_versions SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
UPDATE skill_embeddings SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
UPDATE skill_reviews SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
UPDATE api_keys SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
UPDATE site_settings SET tenant_id = 'default-tenant-000-0000-000000000000' WHERE tenant_id IS NULL;
```

Note: Using a deterministic UUID ('default-tenant-000-0000-000000000000') for the default tenant so the backfill migration can reference it without a subquery.
  </action>
  <verify>
Verify all 3 files exist and contain valid SQL:
```bash
for f in packages/db/src/migrations/000{2,3,4}_*.sql; do echo "=== $f ==="; head -5 "$f"; done
```
  </verify>
  <done>
Three migration files exist: 0002 creates tenants table + default tenant row, 0003 adds nullable tenant_id to all 9 tables, 0004 backfills with default tenant ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create migration files 0005-0006 (enforce constraints + audit logs)</name>
  <files>
    packages/db/src/migrations/0005_enforce_tenant_id.sql
    packages/db/src/migrations/0006_create_audit_logs.sql
  </files>
  <action>
Create two more SQL migration files for constraint enforcement and audit logging.

**File: `0005_enforce_tenant_id.sql`**
```sql
-- Enforce NOT NULL on all tenant_id columns
ALTER TABLE users ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE skills ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE ratings ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE usage_events ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE skill_versions ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE skill_embeddings ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE skill_reviews ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE api_keys ALTER COLUMN tenant_id SET NOT NULL;
ALTER TABLE site_settings ALTER COLUMN tenant_id SET NOT NULL;

-- Add foreign key constraints
ALTER TABLE users ADD CONSTRAINT users_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE skills ADD CONSTRAINT skills_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE ratings ADD CONSTRAINT ratings_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE usage_events ADD CONSTRAINT usage_events_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE skill_versions ADD CONSTRAINT skill_versions_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE skill_embeddings ADD CONSTRAINT skill_embeddings_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE skill_reviews ADD CONSTRAINT skill_reviews_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE api_keys ADD CONSTRAINT api_keys_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);
ALTER TABLE site_settings ADD CONSTRAINT site_settings_tenant_id_fk FOREIGN KEY (tenant_id) REFERENCES tenants(id);

-- Replace global unique constraints with composite unique constraints
-- Skills: slug is unique per tenant (not globally)
ALTER TABLE skills DROP CONSTRAINT IF EXISTS skills_slug_unique;
ALTER TABLE skills ADD CONSTRAINT skills_tenant_slug_unique UNIQUE (tenant_id, slug);

-- Skill embeddings: skill_id is unique per tenant
ALTER TABLE skill_embeddings DROP CONSTRAINT IF EXISTS skill_embeddings_skill_id_unique;
ALTER TABLE skill_embeddings ADD CONSTRAINT skill_embeddings_tenant_skill_unique UNIQUE (tenant_id, skill_id);

-- Skill reviews: skill_id is unique per tenant
ALTER TABLE skill_reviews DROP CONSTRAINT IF EXISTS skill_reviews_skill_id_unique;
ALTER TABLE skill_reviews ADD CONSTRAINT skill_reviews_tenant_skill_unique UNIQUE (tenant_id, skill_id);

-- Site settings: id is unique per tenant (each tenant gets its own settings row)
-- Note: site_settings already has id as PK; add composite unique for (tenant_id, id)
-- Actually, since id is already PK, we just need tenant_id to be part of the lookup.
-- The singleton pattern changes: instead of WHERE id='default', use WHERE tenant_id=? AND id='default'

-- Add tenant_id indexes for query performance
CREATE INDEX IF NOT EXISTS users_tenant_id_idx ON users (tenant_id);
CREATE INDEX IF NOT EXISTS skills_tenant_id_idx ON skills (tenant_id);
CREATE INDEX IF NOT EXISTS ratings_tenant_id_idx ON ratings (tenant_id);
CREATE INDEX IF NOT EXISTS usage_events_tenant_id_idx ON usage_events (tenant_id);
CREATE INDEX IF NOT EXISTS skill_versions_tenant_id_idx ON skill_versions (tenant_id);
CREATE INDEX IF NOT EXISTS skill_embeddings_tenant_id_idx ON skill_embeddings (tenant_id);
CREATE INDEX IF NOT EXISTS skill_reviews_tenant_id_idx ON skill_reviews (tenant_id);
CREATE INDEX IF NOT EXISTS api_keys_tenant_id_idx ON api_keys (tenant_id);
CREATE INDEX IF NOT EXISTS site_settings_tenant_id_idx ON site_settings (tenant_id);

-- Enable RLS on all tenant-scoped tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE usage_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE skill_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE skill_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE skill_reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE site_settings ENABLE ROW LEVEL SECURITY;

-- FORCE RLS so even table owners see filtered rows
ALTER TABLE users FORCE ROW LEVEL SECURITY;
ALTER TABLE skills FORCE ROW LEVEL SECURITY;
ALTER TABLE ratings FORCE ROW LEVEL SECURITY;
ALTER TABLE usage_events FORCE ROW LEVEL SECURITY;
ALTER TABLE skill_versions FORCE ROW LEVEL SECURITY;
ALTER TABLE skill_embeddings FORCE ROW LEVEL SECURITY;
ALTER TABLE skill_reviews FORCE ROW LEVEL SECURITY;
ALTER TABLE api_keys FORCE ROW LEVEL SECURITY;
ALTER TABLE site_settings FORCE ROW LEVEL SECURITY;

-- Create RLS policies for tenant isolation
-- Policy: rows are visible/writable only when tenant_id matches the session variable
CREATE POLICY tenant_isolation ON users FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON skills FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON ratings FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON usage_events FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON skill_versions FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON skill_embeddings FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON skill_reviews FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON api_keys FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));

CREATE POLICY tenant_isolation ON site_settings FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));
```

**File: `0006_create_audit_logs.sql`**
```sql
-- Create append-only audit_logs table
CREATE TABLE IF NOT EXISTS audit_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  actor_id text,
  tenant_id text,
  action text NOT NULL,
  resource_type text,
  resource_id text,
  ip_address text,
  metadata jsonb,
  created_at timestamptz DEFAULT now() NOT NULL
);

-- Indexes for efficient querying
CREATE INDEX IF NOT EXISTS audit_logs_tenant_created_idx ON audit_logs (tenant_id, created_at DESC);
CREATE INDEX IF NOT EXISTS audit_logs_actor_idx ON audit_logs (actor_id, created_at DESC);
CREATE INDEX IF NOT EXISTS audit_logs_action_idx ON audit_logs (action, created_at DESC);

-- Make append-only: create trigger to prevent UPDATE/DELETE
-- Using trigger approach (works regardless of database role setup)
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Direct modification of audit_logs is forbidden';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER no_audit_update
  BEFORE UPDATE OR DELETE ON audit_logs
  FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();
```

**Important note on the REVOKE approach:** The research suggests `REVOKE UPDATE, DELETE ON audit_logs FROM app_user`. However, since the current database likely runs as the postgres superuser (or the database owner role), REVOKE won't be effective until a separate app_user role is created in a later phase (Phase 27 deployment). For now, the trigger-based protection is the reliable approach. Add a comment in the migration noting the REVOKE should be added when the app_user role is created.

Also update the Drizzle migration journal (meta/_journal.json) to include entries for migrations 0002-0006 so Drizzle knows about them. Read the existing journal first to understand the format, then append entries for each new migration.
  </action>
  <verify>
Verify all files exist:
```bash
ls -la packages/db/src/migrations/000{5,6}_*.sql
```
Verify SQL is syntactically reasonable (check for balanced parentheses, no obvious typos).
  </verify>
  <done>
Migration 0005 enforces NOT NULL + FK constraints, replaces global unique with composite unique, adds indexes, enables RLS + creates tenant isolation policies on all 9 tables. Migration 0006 creates audit_logs table with trigger-based append-only protection.
  </done>
</task>

</tasks>

<verification>
- 5 migration files exist in packages/db/src/migrations/
- 0002 creates tenants table and seeds default tenant
- 0003 adds nullable tenant_id to all 9 tables
- 0004 backfills with default tenant ID
- 0005 enforces NOT NULL, FKs, composite uniques, indexes, RLS
- 0006 creates audit_logs with trigger protection
- Drizzle migration journal updated with entries for 0002-0006
</verification>

<success_criteria>
All 5 migration files are ready to run sequentially against the database. The migration journal references them. They implement the complete multi-step migration from single-tenant to multi-tenant with RLS and audit logging.
</success_criteria>

<output>
After completion, create `.planning/phases/25-multi-tenancy-schema-audit/25-04-SUMMARY.md`
</output>
