---
phase: 25-multi-tenancy-schema-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/tenant-context.ts
autonomous: true

must_haves:
  truths:
    - "A withTenant() helper exists that wraps DB operations in a transaction with SET LOCAL app.current_tenant_id"
    - "The helper throws an error if tenantId is empty/undefined"
    - "SET LOCAL ensures the session variable is cleared when the transaction ends (safe for connection pooling)"
  artifacts:
    - path: "packages/db/src/tenant-context.ts"
      provides: "withTenant() helper for tenant-scoped DB transactions"
      exports: ["withTenant"]
  key_links:
    - from: "packages/db/src/tenant-context.ts"
      to: "packages/db/src/client.ts"
      via: "imports db from client"
      pattern: "import.*db.*from.*client"
---

<objective>
Create the withTenant() helper that wraps all database operations in a tenant-scoped transaction using SET LOCAL.

Purpose: This is the core mechanism for tenant isolation at the application layer. Every DB operation in a multi-tenant context will use this helper. SET LOCAL ensures the session variable is transaction-scoped and safe for connection pooling.
Output: A new tenant-context module exporting the withTenant() function.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/db/src/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create withTenant() helper module</name>
  <files>
    packages/db/src/tenant-context.ts
  </files>
  <action>
Create `packages/db/src/tenant-context.ts` with the following implementation:

```typescript
import { sql } from "drizzle-orm";
import { db } from "./client";

/**
 * Execute a callback within a tenant-scoped transaction.
 * Sets LOCAL session variable so RLS policies can read it.
 * SET LOCAL scoping means the variable is automatically cleared
 * when the transaction ends -- safe for connection pooling.
 */
export async function withTenant<T>(
  tenantId: string,
  callback: (tx: typeof db) => Promise<T>
): Promise<T> {
  if (!tenantId) {
    throw new Error("withTenant requires a non-empty tenantId");
  }
  if (!db) {
    throw new Error("Database not configured");
  }

  return db.transaction(async (tx) => {
    await tx.execute(
      sql`SET LOCAL app.current_tenant_id = ${tenantId}`
    );
    return callback(tx as unknown as typeof db);
  });
}
```

Key design decisions:
- Validates tenantId is non-empty before starting a transaction (fail fast)
- Uses `SET LOCAL` (not `SET`) so the variable is transaction-scoped and safe for connection pooling
- Casts `tx` to `typeof db` so callers can use the full Drizzle query API
- The `db` null check prevents runtime errors when DATABASE_URL is not configured

Also update `packages/db/src/index.ts` (the package's main export) to re-export from tenant-context, but ONLY if it already re-exports from client. Check the file first. If the main index doesn't exist or doesn't export client utilities, skip this step â€” downstream plans will handle wiring.
  </action>
  <verify>
Run: `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json 2>&1 | head -20`
The file should compile without errors. Verify the withTenant function is exported.

Then run a functional test to verify SET LOCAL actually works within a transaction. Create and run a temporary script:
```bash
cd /home/dev/projects/relay
node -e "
const { db } = require('./packages/db/src/client');
const { sql } = require('drizzle-orm');
(async () => {
  // Test: SET LOCAL inside a transaction sets the variable, and it's cleared after
  const result = await db.transaction(async (tx) => {
    await tx.execute(sql\`SET LOCAL app.current_tenant_id = 'test-tenant-123'\`);
    const row = await tx.execute(sql\`SELECT current_setting('app.current_tenant_id', true) AS tid\`);
    return row.rows[0].tid;
  });
  if (result !== 'test-tenant-123') {
    console.error('FAIL: Expected test-tenant-123 but got', result);
    process.exit(1);
  }
  // After transaction ends, the variable should be cleared (or return empty/null)
  const after = await db.execute(sql\`SELECT current_setting('app.current_tenant_id', true) AS tid\`);
  const afterVal = after.rows[0].tid;
  if (afterVal === 'test-tenant-123') {
    console.error('FAIL: SET LOCAL leaked outside transaction, got', afterVal);
    process.exit(1);
  }
  console.log('PASS: SET LOCAL works correctly within transaction scope');
  process.exit(0);
})().catch(e => { console.error('FAIL:', e.message); process.exit(1); });
"
```
If the project uses ESM imports, adjust to use dynamic import or tsx. The key assertions:
1. Inside the transaction, `current_setting('app.current_tenant_id')` returns `'test-tenant-123'`
2. Outside the transaction, the variable is NOT `'test-tenant-123'` (SET LOCAL is transaction-scoped)
  </verify>
  <done>
withTenant() is exported from packages/db/src/tenant-context.ts, validates tenantId, uses SET LOCAL inside db.transaction(), and casts tx for full Drizzle API compatibility. Functional test confirms SET LOCAL sets the variable inside the transaction and it is cleared after the transaction ends.
  </done>
</task>

</tasks>

<verification>
- `packages/db/src/tenant-context.ts` exists and exports withTenant
- TypeScript compiles without errors
- Function validates tenantId before starting transaction
- Uses `SET LOCAL` (not `SET`) for connection pool safety
- Functional test confirms SET LOCAL sets current_setting inside transaction and is cleared after transaction ends
</verification>

<success_criteria>
withTenant() helper is available for import by downstream services and server actions. It correctly sets the PostgreSQL session variable within a transaction scope.
</success_criteria>

<output>
After completion, create `.planning/phases/25-multi-tenancy-schema-audit/25-02-SUMMARY.md`
</output>
