---
phase: 25-multi-tenancy-schema-audit
plan: 03
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - packages/db/src/schema/skills.ts
  - packages/db/src/schema/users.ts
  - packages/db/src/schema/ratings.ts
  - packages/db/src/schema/usage-events.ts
  - packages/db/src/schema/skill-versions.ts
  - packages/db/src/schema/skill-embeddings.ts
  - packages/db/src/schema/skill-reviews.ts
  - packages/db/src/schema/api-keys.ts
  - packages/db/src/schema/site-settings.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/relations/index.ts
autonomous: true

must_haves:
  truths:
    - "All 9 data tables have a tenantId column referencing tenants.id"
    - "skills table has a composite unique index on (tenantId, slug) instead of a global slug unique"
    - "Schema index re-exports tenants and auditLogs"
    - "Relations include tenant references for skills and users"
  artifacts:
    - path: "packages/db/src/schema/skills.ts"
      provides: "Skills table with tenantId column and composite unique"
      contains: "tenantId"
    - path: "packages/db/src/schema/users.ts"
      provides: "Users table with tenantId column"
      contains: "tenantId"
    - path: "packages/db/src/schema/index.ts"
      provides: "Re-exports all schema including tenants and auditLogs"
      contains: "tenants"
  key_links:
    - from: "packages/db/src/schema/skills.ts"
      to: "packages/db/src/schema/tenants.ts"
      via: "tenantId FK reference"
      pattern: "references.*tenants\\.id"
---

<objective>
Add tenant_id column to all 9 data tables, update composite unique constraints, update schema index exports, and add tenant relations.

Purpose: Every data table needs tenant isolation. This plan modifies all schema definitions to include tenant_id references, preparing for the SQL migrations that will add the actual columns to the database.
Output: All 9 schema files updated with tenantId, schema index updated, relations updated.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@packages/db/src/schema/index.ts
@packages/db/src/relations/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tenantId to all 9 schema files and update index</name>
  <files>
    packages/db/src/schema/skills.ts
    packages/db/src/schema/users.ts
    packages/db/src/schema/ratings.ts
    packages/db/src/schema/usage-events.ts
    packages/db/src/schema/skill-versions.ts
    packages/db/src/schema/skill-embeddings.ts
    packages/db/src/schema/skill-reviews.ts
    packages/db/src/schema/api-keys.ts
    packages/db/src/schema/site-settings.ts
    packages/db/src/schema/index.ts
  </files>
  <action>
For each of the 9 data tables, add a `tenantId` column with a foreign key to the tenants table. Read each file first to understand its current structure.

**Pattern for all tables** (add this column after the `id` column):
```typescript
import { tenants } from "./tenants";

// Add this column to each table:
tenantId: text("tenant_id").notNull().references(() => tenants.id),
```

**Special cases:**

1. **skills.ts** — Replace the `.unique()` on slug with a composite unique index:
   - Remove `.unique()` from the slug column definition
   - Add to the table's third argument (alongside existing search index):
   ```typescript
   import { uniqueIndex } from "drizzle-orm/pg-core";
   // In the table extras array:
   uniqueIndex("skills_tenant_slug_unique").on(table.tenantId, table.slug),
   index("skills_tenant_id_idx").on(table.tenantId),
   ```

2. **users.ts** — Keep `.unique()` on email (email is a global login identity). Just add tenantId column. Add a tenant_id index:
   ```typescript
   import { index } from "drizzle-orm/pg-core";
   // Add index in table extras:
   (table) => [index("users_tenant_id_idx").on(table.tenantId)]
   ```

3. **skill-embeddings.ts** — If it has a unique constraint on skill_id, change to composite `(tenant_id, skill_id)`.

4. **skill-reviews.ts** — If it has a unique constraint on skill_id, change to composite `(tenant_id, skill_id)`.

5. **site-settings.ts** — The singleton pattern uses `id = 'default'`. Keep the `id` column but add tenant_id. The effective unique key becomes `(tenant_id, id)` so each tenant gets its own settings row. Add a composite unique index.

6. **api-keys.ts** — Keep key_hash globally unique (it's an auth identity). Just add tenantId column.

**Update `packages/db/src/schema/index.ts`:**
Add these two exports:
```typescript
export * from "./tenants";
export * from "./audit-logs";
```
  </action>
  <verify>
Run: `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json 2>&1 | head -30`
All 9 modified files plus the index should compile without errors.
Verify: grep for "tenantId" in each of the 9 schema files to confirm it was added.
  </verify>
  <done>
All 9 data tables have tenantId column referencing tenants.id. Skills has composite unique on (tenantId, slug). Schema index exports tenants and auditLogs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update relations to include tenant references</name>
  <files>
    packages/db/src/relations/index.ts
  </files>
  <action>
Update `packages/db/src/relations/index.ts` to add tenant relations:

1. Import `tenants` from the schema
2. Add a `tenantsRelations` definition with `many` relations to users, skills, etc:
```typescript
import { tenants, auditLogs } from "../schema";

export const tenantsRelations = relations(tenants, ({ many }) => ({
  users: many(users),
  skills: many(skills),
  apiKeys: many(apiKeys),
}));
```

3. Add `tenant` relation to existing `usersRelations`:
```typescript
// Add to usersRelations:
tenant: one(tenants, {
  fields: [users.tenantId],
  references: [tenants.id],
}),
```

4. Add `tenant` relation to existing `skillsRelations`:
```typescript
// Add to skillsRelations:
tenant: one(tenants, {
  fields: [skills.tenantId],
  references: [tenants.id],
}),
```

Import `tenants` at the top of the file alongside other schema imports.
  </action>
  <verify>
Run: `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json 2>&1 | head -20`
Relations file should compile without errors.
  </verify>
  <done>
Relations include tenantsRelations (many users, skills, apiKeys), and usersRelations and skillsRelations include a tenant one-relation.
  </done>
</task>

</tasks>

<verification>
- All 9 schema files contain `tenantId: text("tenant_id").notNull().references(() => tenants.id)`
- skills.ts has `uniqueIndex("skills_tenant_slug_unique").on(table.tenantId, table.slug)` and no `.unique()` on slug
- schema/index.ts exports tenants and auditLogs
- relations/index.ts has tenantsRelations and tenant back-references on users and skills
- TypeScript compiles without errors across the entire packages/db project
</verification>

<success_criteria>
All Drizzle schema definitions reflect the multi-tenant structure. The database schema files are ready for migration generation. TypeScript compilation succeeds.
</success_criteria>

<output>
After completion, create `.planning/phases/25-multi-tenancy-schema-audit/25-03-SUMMARY.md`
</output>
