---
phase: 15-embeddings-foundation
plan: 04
type: execute
wave: 3
depends_on: ["15-03"]
files_modified:
  - packages/db/src/scripts/backfill-embeddings.ts
  - packages/db/package.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All existing skills have embeddings after backfill"
    - "Backfill script handles errors by failing fast"
    - "Backfill respects API rate limits with throttling"
  artifacts:
    - path: "packages/db/src/scripts/backfill-embeddings.ts"
      provides: "One-time migration script for existing skills"
      min_lines: 50
    - path: "packages/db/package.json"
      provides: "db:backfill-embeddings script"
      contains: "backfill-embeddings"
  key_links:
    - from: "packages/db/src/scripts/backfill-embeddings.ts"
      to: "apps/web/lib/embeddings.ts"
      via: "import generateEmbeddingsBatch"
      pattern: "generateEmbeddingsBatch"
---

<objective>
Create backfill script to generate embeddings for all existing skills.

Purpose: Ensure 100% embedding coverage before Phase 16 (Similarity Detection) goes live.
Output: Executable script that processes all skills without embeddings and generates vectors.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-embeddings-foundation/15-CONTEXT.md
@.planning/phases/15-embeddings-foundation/15-RESEARCH.md
@packages/db/src/seed.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backfill script</name>
  <files>packages/db/src/scripts/backfill-embeddings.ts</files>
  <action>
Create a one-time migration script to backfill embeddings for existing skills.

File: packages/db/src/scripts/backfill-embeddings.ts

Script structure:

1. Load environment:
   ```typescript
   import { config } from "dotenv";
   config({ path: "../../.env.local" });
   ```

2. Import dependencies:
   - db from "../client"
   - skills, skillEmbeddings from "../schema"
   - eq, isNull, sql from "drizzle-orm"
   - generateEmbeddingsBatch, EMBEDDING_MODEL, EMBEDDING_VERSION from web app
     Note: Since this is a script, import the embeddings module path directly:
     ```typescript
     // Import from web app - works because we're in a monorepo
     import { generateEmbeddingsBatch, EMBEDDING_MODEL, EMBEDDING_VERSION } from "../../../apps/web/lib/embeddings";
     import { hashContent } from "../../../apps/web/lib/content-hash";
     ```

3. Main function:
   ```typescript
   async function backfillEmbeddings() {
     if (!db) {
       console.error("Database not configured");
       process.exit(1);
     }

     // Find skills without embeddings
     const skillsWithoutEmbeddings = await db
       .select({
         id: skills.id,
         name: skills.name,
         description: skills.description,
         content: skills.content,
         tags: skills.tags,
       })
       .from(skills)
       .leftJoin(skillEmbeddings, eq(skills.id, skillEmbeddings.skillId))
       .where(isNull(skillEmbeddings.id));

     console.log(`Found ${skillsWithoutEmbeddings.length} skills without embeddings`);

     if (skillsWithoutEmbeddings.length === 0) {
       console.log("All skills already have embeddings");
       return;
     }

     // Build embedding inputs
     const inputs = skillsWithoutEmbeddings.map(skill => {
       return [
         skill.name,
         skill.description,
         skill.content,
         ...(skill.tags || [])
       ].join(" ");
     });

     // Generate embeddings in batches (150ms delay between batches)
     console.log("Generating embeddings...");
     const embeddings = await generateEmbeddingsBatch(inputs, 150);

     // Insert embeddings in a transaction
     console.log("Storing embeddings...");
     await db.transaction(async (tx) => {
       for (let i = 0; i < skillsWithoutEmbeddings.length; i++) {
         const skill = skillsWithoutEmbeddings[i];
         const inputHash = await hashContent(inputs[i]);

         await tx.insert(skillEmbeddings).values({
           skillId: skill.id,
           embedding: embeddings[i],
           modelName: EMBEDDING_MODEL,
           modelVersion: EMBEDDING_VERSION,
           inputHash,
         });

         console.log(`  [${i + 1}/${skillsWithoutEmbeddings.length}] ${skill.name}`);
       }
     });

     console.log("Backfill complete!");
   }

   backfillEmbeddings()
     .then(() => process.exit(0))
     .catch((error) => {
       console.error("Backfill failed:", error);
       process.exit(1);
     });
   ```

4. Key behaviors per CONTEXT.md:
   - If any embedding fails, the transaction rolls back (all or nothing)
   - 150ms delay between batches to respect rate limits
   - Progress logging for visibility
   - Exit with code 1 on failure (for CI/deployment scripts)
  </action>
  <verify>
- File exists at packages/db/src/scripts/backfill-embeddings.ts
- Imports generateEmbeddingsBatch from web app
- Uses transaction for atomic insert
- Has progress logging
  </verify>
  <done>Backfill script created with batch processing, throttling, and transaction safety</done>
</task>

<task type="auto">
  <name>Task 2: Add npm script</name>
  <files>packages/db/package.json</files>
  <action>
Add a script to run the backfill migration.

In packages/db/package.json, add to "scripts":
```json
"db:backfill-embeddings": "tsx src/scripts/backfill-embeddings.ts"
```

This follows the existing pattern of db:seed using tsx.
  </action>
  <verify>
- `pnpm --filter @relay/db db:backfill-embeddings --help` doesn't error on tsx not found
- Script is in package.json
  </verify>
  <done>npm script added for running backfill</done>
</task>

<task type="auto">
  <name>Task 3: Run backfill on existing skills</name>
  <files>None (database operation)</files>
  <action>
Execute the backfill script to generate embeddings for all existing skills.

Command:
```bash
pnpm --filter @relay/db db:backfill-embeddings
```

Expected output:
- "Found N skills without embeddings"
- Progress for each skill
- "Backfill complete!"

If it fails:
- Check VOYAGE_API_KEY is set in .env.local
- Check database connection
- Check for rate limit errors (429)

After completion, verify with Drizzle Studio:
```bash
pnpm --filter @relay/db db:studio
```
Check skill_embeddings table has rows matching skills count.
  </action>
  <verify>
- Backfill script completes without errors
- skill_embeddings table has one row per skill
- `SELECT COUNT(*) FROM skill_embeddings` equals `SELECT COUNT(*) FROM skills`
  </verify>
  <done>All existing skills have embeddings, 100% coverage verified</done>
</task>

</tasks>

<verification>
1. Backfill script is executable: `pnpm --filter @relay/db db:backfill-embeddings`
2. All skills have embeddings: `SELECT s.id, se.id FROM skills s LEFT JOIN skill_embeddings se ON s.id = se.skill_id WHERE se.id IS NULL` returns 0 rows
3. TypeScript compilation passes: `pnpm --filter @relay/db typecheck`
</verification>

<success_criteria>
- Backfill script runs successfully
- Every skill in database has corresponding embedding
- Script handles errors by failing the entire operation (transaction rollback)
- Script respects rate limits with 150ms delay between batches
</success_criteria>

<output>
After completion, create `.planning/phases/15-embeddings-foundation/15-04-SUMMARY.md`
</output>
