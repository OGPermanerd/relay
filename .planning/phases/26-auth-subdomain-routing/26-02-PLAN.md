---
phase: 26-auth-subdomain-routing
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - apps/web/auth.ts
autonomous: true

must_haves:
  truths:
    - "Google SSO signIn callback rejects users whose email domain has no matching active tenant"
    - "Google SSO signIn callback allows users whose email domain matches an active tenant"
    - "JWT token contains tenantId after initial sign-in"
    - "Session object exposes tenantId via session.user.tenantId"
    - "User's tenantId is updated in DB during first sign-in to correct tenant"
    - "Redirect callback allows cross-subdomain redirects within root domain"
  artifacts:
    - path: "apps/web/auth.ts"
      provides: "Auth.js configuration with tenant-aware callbacks"
      exports: ["handlers", "auth", "signIn", "signOut"]
      contains: "getTenantByDomain"
  key_links:
    - from: "apps/web/auth.ts"
      to: "packages/db/src/services/tenant.ts"
      via: "import getTenantByDomain"
      pattern: "getTenantByDomain"
    - from: "apps/web/auth.ts signIn callback"
      to: "tenants table"
      via: "email domain lookup"
      pattern: "email.*split.*@"
    - from: "apps/web/auth.ts jwt callback"
      to: "session"
      via: "token.tenantId propagation"
      pattern: "token\\.tenantId"
---

<objective>
Rewrite Auth.js callbacks in auth.ts to support multi-tenant authentication: signIn validates email domain against tenant DB records, jwt injects tenantId into token, session exposes tenantId, and redirect allows cross-subdomain navigation.

Purpose: This is the core auth logic that maps Google SSO users to their correct tenant based on email domain (TENANT-07), injects tenantId into JWT (TENANT-10), and enables cross-subdomain redirects (TENANT-08).

Output: Updated apps/web/auth.ts with tenant-aware callbacks
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@apps/web/auth.ts
@apps/web/auth.config.ts
@packages/db/src/schema/tenants.ts
@packages/db/src/services/tenant.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite auth.ts callbacks for multi-tenant authentication</name>
  <files>apps/web/auth.ts</files>
  <action>
Rewrite `apps/web/auth.ts` to replace single-domain auth with multi-tenant email-domain-based auth.

**Remove:**
- The `ALLOWED_DOMAIN` constant and all `AUTH_ALLOWED_DOMAIN` env var usage
- The old signIn callback that checks `endsWith(@ALLOWED_DOMAIN)`

**Add imports:**
- `import { getTenantByDomain } from "@everyskill/db/services/tenant";` (or from the package path that resolves to packages/db/src/services/tenant.ts -- check the existing import pattern, currently uses `@everyskill/db` for schema)
- `import { eq } from "drizzle-orm";`
- `import { users } from "@everyskill/db/schema";` (already imported)

**Check how @everyskill/db exports work:** Look at `packages/db/package.json` exports to determine if services are exported. If not, add a `"./services/tenant"` export mapping. The existing pattern is `@everyskill/db/schema` mapping to `./src/schema/index.ts`. Add a similar export for `./services/tenant` -> `./src/services/tenant.ts`.

**Add `rootDomain` constant:**
```
const rootDomain = process.env.NEXT_PUBLIC_ROOT_DOMAIN || "everyskill.ai";
```

**Rewrite callbacks in createAuthConfig():**

1. **signIn callback:**
   ```
   async signIn({ account, profile }) {
     if (account?.provider !== "google") return false;
     if (!profile?.email_verified) return false;

     const emailDomain = profile.email?.split("@")[1];
     if (!emailDomain) return false;

     // Look up tenant by email domain
     const tenant = await getTenantByDomain(emailDomain);
     if (!tenant) return false;  // No tenant for this email domain

     return true;
   }
   ```

2. **jwt callback:**
   ```
   async jwt({ token, user, account, profile }) {
     if (user) {
       token.id = user.id;
     }

     // On initial sign-in (account present), resolve and inject tenantId
     if (account && profile?.email) {
       const emailDomain = profile.email.split("@")[1];
       const tenant = await getTenantByDomain(emailDomain);
       if (tenant) {
         token.tenantId = tenant.id;

         // Update user's tenantId in DB if it doesn't match
         // (handles first sign-in where DrizzleAdapter used default tenant)
         if (user?.id) {
           try {
             await db!.update(users)
               .set({ tenantId: tenant.id })
               .where(eq(users.id, user.id));
           } catch (e) {
             console.error("Failed to update user tenantId:", e);
           }
         }
       }
     }

     return token;
   }
   ```

3. **session callback:**
   ```
   async session({ session, token }) {
     if (session.user && token.id) {
       session.user.id = token.id as string;
     }
     if (token.tenantId) {
       session.user.tenantId = token.tenantId as string;
     }
     return session;
   }
   ```

4. **redirect callback (NEW):**
   ```
   async redirect({ url, baseUrl }) {
     // Allow redirects to any subdomain of the root domain
     try {
       const urlObj = new URL(url);
       if (urlObj.hostname.endsWith(rootDomain)) {
         return url;
       }
     } catch {}
     // Allow relative URLs
     if (url.startsWith("/")) return `${baseUrl}${url}`;
     return baseUrl;
   }
   ```

**Keep unchanged:**
- DrizzleAdapter setup
- The isDatabaseConfigured() guard and fallback exports pattern
- The handlers, auth, signIn, signOut exports

**Remove the `session: { strategy: "jwt" }` line** from createAuthConfig -- it's now in auth.config.ts (Plan 01). The spread of `...authConfig` will bring it in.

**Important:** Make sure to also import `users` for the DB update in the jwt callback. Verify the `db` import is available (it's already imported as `import { db, isDatabaseConfigured } from "@everyskill/db"`).
  </action>
  <verify>
1. Run `cd /home/dev/projects/relay && npx tsc --noEmit -p apps/web/tsconfig.json 2>&1 | head -40` -- should compile cleanly
2. Verify with grep that auth.ts no longer contains `AUTH_ALLOWED_DOMAIN` or `ALLOWED_DOMAIN`
3. Verify auth.ts contains `getTenantByDomain` and `token.tenantId`
4. Run `cd /home/dev/projects/relay/apps/web && npm run build 2>&1 | tail -20` -- should build successfully
  </verify>
  <done>
    - signIn callback validates email domain against tenants table (not hardcoded domain)
    - jwt callback injects tenantId into token on initial sign-in
    - jwt callback updates user.tenantId in DB on first sign-in
    - session callback exposes tenantId as session.user.tenantId
    - redirect callback allows cross-subdomain redirects within rootDomain
    - No references to AUTH_ALLOWED_DOMAIN remain
    - TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
1. `apps/web/auth.ts` compiles without TypeScript errors
2. signIn callback uses getTenantByDomain (not hardcoded domain check)
3. jwt callback sets token.tenantId from tenant lookup
4. session callback propagates tenantId to session.user
5. redirect callback allows *.everyskill.ai redirects
6. No AUTH_ALLOWED_DOMAIN references remain in auth.ts
7. Next.js build succeeds
</verification>

<success_criteria>
- Multi-tenant auth callbacks fully functional
- Email domain mapped to tenant via DB lookup
- JWT carries tenantId claim
- Session exposes tenantId
- Cross-subdomain redirects allowed
</success_criteria>

<output>
After completion, create `.planning/phases/26-auth-subdomain-routing/26-02-SUMMARY.md`
</output>
