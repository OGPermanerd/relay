---
phase: 50-gmail-oauth-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/gmail-tokens.ts
  - packages/db/src/schema/site-settings.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/lib/crypto.ts
  - packages/db/src/services/gmail-tokens.ts
  - packages/db/src/services/index.ts
  - packages/db/src/relations/index.ts
  - packages/db/src/migrations/0028_add_gmail_tokens.sql
autonomous: true
user_setup:
  - service: gmail-encryption
    why: "AES-256-GCM encryption of Gmail OAuth tokens at rest"
    env_vars:
      - name: GMAIL_ENCRYPTION_KEY
        source: "Generate with: openssl rand -hex 32 -- add to .env.local, .env.staging, .env.production"

must_haves:
  truths:
    - "gmail_tokens table exists with AES-256-GCM encrypted token columns"
    - "site_settings table has gmail_diagnostic_enabled boolean column"
    - "Token encryption/decryption round-trips correctly"
    - "Race-safe token refresh uses refreshing_at mutex"
    - "Tokens are upserted (one per user) and deletable"
  artifacts:
    - path: "packages/db/src/schema/gmail-tokens.ts"
      provides: "gmailTokens table definition with RLS policy"
      contains: "pgTable"
    - path: "packages/db/src/lib/crypto.ts"
      provides: "encryptToken and decryptToken using AES-256-GCM"
      exports: ["encryptToken", "decryptToken"]
    - path: "packages/db/src/services/gmail-tokens.ts"
      provides: "CRUD, encryption, and race-safe refresh service"
      exports: ["upsertGmailTokens", "getGmailTokenDecrypted", "deleteGmailTokens", "hasActiveGmailConnection", "getValidGmailToken"]
    - path: "packages/db/src/migrations/0028_add_gmail_tokens.sql"
      provides: "SQL migration for gmail_tokens table and site_settings column"
      contains: "CREATE TABLE"
  key_links:
    - from: "packages/db/src/services/gmail-tokens.ts"
      to: "packages/db/src/lib/crypto.ts"
      via: "import encryptToken/decryptToken"
      pattern: "import.*crypto"
    - from: "packages/db/src/services/gmail-tokens.ts"
      to: "packages/db/src/schema/gmail-tokens.ts"
      via: "import gmailTokens table"
      pattern: "import.*gmailTokens"
    - from: "packages/db/src/schema/index.ts"
      to: "packages/db/src/schema/gmail-tokens.ts"
      via: "re-export"
      pattern: "export.*gmail-tokens"
---

<objective>
Create the gmail_tokens schema, AES-256-GCM encryption utilities, and token service layer with race-safe refresh.

Purpose: Foundation for all Gmail OAuth functionality -- schema, encryption, and service must exist before API routes or UI.
Output: gmail_tokens table, crypto utils, token CRUD service, migration SQL, site_settings column for admin toggle.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/db/src/schema/site-settings.ts
@packages/db/src/services/site-settings.ts
@packages/db/src/schema/index.ts
@packages/db/src/services/index.ts
@packages/db/src/relations/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gmail tokens schema, crypto utils, migration, and wiring</name>
  <files>
    packages/db/src/schema/gmail-tokens.ts
    packages/db/src/schema/site-settings.ts
    packages/db/src/schema/index.ts
    packages/db/src/lib/crypto.ts
    packages/db/src/relations/index.ts
    packages/db/src/migrations/0028_add_gmail_tokens.sql
  </files>
  <action>
    1. Create `packages/db/src/lib/crypto.ts` with AES-256-GCM encrypt/decrypt:
       - `encryptToken(plaintext: string): string` -- returns `iv_hex:authTag_hex:ciphertext_hex` format
       - `decryptToken(encryptedStr: string): string` -- parses format and decrypts
       - Use `createCipheriv`/`createDecipheriv` from `node:crypto`, algorithm "aes-256-gcm", IV length 12 bytes (randomBytes), authTag length 16 bytes
       - `getEncryptionKey()` reads `process.env.GMAIL_ENCRYPTION_KEY` (64-char hex = 32 bytes), throws if missing/wrong length

    2. Create `packages/db/src/schema/gmail-tokens.ts`:
       - Table `gmail_tokens` with columns: id (text PK, crypto.randomUUID default), tenant_id (text NOT NULL FK tenants), user_id (text NOT NULL FK users ON DELETE CASCADE, UNIQUE), encrypted_access_token (text NOT NULL), encrypted_refresh_token (text NOT NULL), expires_at (timestamp with timezone NOT NULL), scope (text NOT NULL), key_version (integer NOT NULL default 1), refreshing_at (timestamp with timezone nullable), connected_at (timestamp with timezone NOT NULL defaultNow), updated_at (timestamp with timezone NOT NULL defaultNow)
       - Indexes: gmail_tokens_user_id_idx, gmail_tokens_tenant_id_idx
       - RLS pgPolicy "tenant_isolation" using `tenant_id = current_setting('app.current_tenant_id', true)`
       - Export types: `GmailToken`, `NewGmailToken`
       - Import tenants and users from sibling schema files (follow existing pattern in skills.ts)

    3. Add `gmailDiagnosticEnabled` to site_settings schema:
       - Add `gmailDiagnosticEnabled: boolean("gmail_diagnostic_enabled").notNull().default(false)` to the siteSettings table columns, after `keyExpiryDays`

    4. Update `packages/db/src/schema/index.ts`:
       - Add `export * from "./gmail-tokens";` at the end

    5. Update `packages/db/src/relations/index.ts`:
       - Import `gmailTokens` from `"../schema"`
       - Add `gmailTokensRelations`: user relation (one, fields: [gmailTokens.userId], references: [users.id]), tenant relation (one, fields: [gmailTokens.tenantId], references: [tenants.id])
       - Add gmailTokens to usersRelations: `gmailToken: one(gmailTokens)` (one user = one gmail token)

    6. Create `packages/db/src/migrations/0028_add_gmail_tokens.sql`:
       - CREATE TABLE gmail_tokens with all columns, UNIQUE constraint on user_id, indexes, RLS policy
       - ALTER TABLE site_settings ADD COLUMN IF NOT EXISTS gmail_diagnostic_enabled BOOLEAN NOT NULL DEFAULT false
       - Follow exact SQL from RESEARCH.md Pattern (code example in research)
  </action>
  <verify>
    Run `cd /home/dev/projects/relay && pnpm build --filter @everyskill/db` to verify schema compiles.
    Run migration: `cd /home/dev/projects/relay && psql $DATABASE_URL -f packages/db/src/migrations/0028_add_gmail_tokens.sql`
    Verify table exists: `psql $DATABASE_URL -c "\d gmail_tokens"`
    Verify column exists: `psql $DATABASE_URL -c "SELECT gmail_diagnostic_enabled FROM site_settings LIMIT 1"`
  </verify>
  <done>
    gmail_tokens table exists in DB with all columns, indexes, and RLS policy. site_settings has gmail_diagnostic_enabled column. Schema compiles. crypto.ts exports encryptToken/decryptToken. Relations defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Gmail tokens service with CRUD, encryption, and race-safe refresh</name>
  <files>
    packages/db/src/services/gmail-tokens.ts
    packages/db/src/services/index.ts
  </files>
  <action>
    1. Create `packages/db/src/services/gmail-tokens.ts`:

       Import db from "../client", gmailTokens from "../schema/gmail-tokens", encryptToken/decryptToken from "../lib/crypto", eq/and/or/lt/isNull from "drizzle-orm".

       Define types:
       - `UpsertGmailTokensParams`: { userId, tenantId, accessToken, refreshToken, expiresAt (Date), scope }
       - `DecryptedGmailToken`: { id, userId, tenantId, accessToken, refreshToken, expiresAt (Date), scope, keyVersion, connectedAt (Date) }
       - Custom errors: `GmailNotConnectedError extends Error`, `GmailTokenRevokedError extends Error`

       Functions:
       a) `upsertGmailTokens(params: UpsertGmailTokensParams): Promise<void>`:
          - Encrypt accessToken and refreshToken using encryptToken()
          - INSERT into gmailTokens with encrypted values, ON CONFLICT (userId) DO UPDATE with new encrypted tokens, expiresAt, scope, updatedAt, refreshingAt: null
          - Use drizzle `.onConflictDoUpdate({ target: gmailTokens.userId, set: {...} })`

       b) `getGmailTokenDecrypted(userId: string): Promise<DecryptedGmailToken | null>`:
          - SELECT from gmailTokens WHERE userId = param
          - If no row, return null
          - Decrypt both encrypted fields using decryptToken()
          - Return DecryptedGmailToken object

       c) `deleteGmailTokens(userId: string): Promise<void>`:
          - DELETE from gmailTokens WHERE userId = param

       d) `hasActiveGmailConnection(userId: string): Promise<boolean>`:
          - SELECT id from gmailTokens WHERE userId = param, LIMIT 1
          - Return Boolean(row)

       e) `getValidGmailToken(userId: string): Promise<DecryptedGmailToken>`:
          - Call getGmailTokenDecrypted(userId). If null, throw GmailNotConnectedError.
          - Check if expiresAt > Date.now() + REFRESH_BUFFER_MS (5 min = 300000). If yes, return token.
          - Attempt lock: UPDATE gmailTokens SET refreshingAt = new Date() WHERE userId = userId AND (refreshingAt IS NULL OR refreshingAt < Date.now() - LOCK_TIMEOUT_MS (30000))
          - If 0 rows returned (lock held by another): wait 2 seconds, recursively call getValidGmailToken (max 3 retries to prevent infinite recursion -- add retryCount param defaulting to 0, throw if >= 3)
          - If lock acquired: create OAuth2Client (import from "google-auth-library"), setCredentials with refresh_token, call refreshAccessToken()
          - Update gmailTokens with new encrypted accessToken, optionally new refreshToken (Google may rotate), new expiresAt, refreshingAt: null
          - On error: release lock (set refreshingAt: null). If error message includes "invalid_grant", call deleteGmailTokens and throw GmailTokenRevokedError. Otherwise rethrow.
          - Return decrypted token with fresh values

    2. Update `packages/db/src/services/index.ts`:
       - Add exports: `export { upsertGmailTokens, getGmailTokenDecrypted, deleteGmailTokens, hasActiveGmailConnection, getValidGmailToken, GmailNotConnectedError, GmailTokenRevokedError, type UpsertGmailTokensParams, type DecryptedGmailToken } from "./gmail-tokens";`

    NOTE: The `getValidGmailToken` function imports `OAuth2Client` from "google-auth-library". This package will be installed in the web app (apps/web), but the service lives in packages/db. To avoid adding google-auth-library as a dependency of packages/db, make the refresh function accept an optional `refreshFn` callback parameter:
    ```
    getValidGmailToken(userId: string, refreshFn?: (refreshToken: string) => Promise<{accessToken: string, refreshToken?: string, expiryDate: number}>)
    ```
    If no refreshFn provided, do a dynamic import: `const { OAuth2Client } = await import("google-auth-library")`. This way the dependency is lazy and only needed at runtime when called from the web app context where the package is installed.

    Actually, simpler approach: just install google-auth-library in packages/db too. Run: `pnpm --filter @everyskill/db add google-auth-library`. This is cleaner than dynamic imports or callbacks.
  </action>
  <verify>
    Run `cd /home/dev/projects/relay && pnpm build --filter @everyskill/db` -- build succeeds with new service.
    Run `cd /home/dev/projects/relay && pnpm build` -- full monorepo build succeeds.
  </verify>
  <done>
    Gmail tokens service exports all 5 functions + 2 error classes + 2 types from packages/db. Full build passes. Service handles upsert with encryption, decrypted read, delete, connection check, and race-safe refresh with retry limit.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` passes across the monorepo
2. `psql $DATABASE_URL -c "\d gmail_tokens"` shows all expected columns
3. `psql $DATABASE_URL -c "SELECT gmail_diagnostic_enabled FROM site_settings LIMIT 1"` returns false
4. Schema, service, crypto, and relations all properly exported from @everyskill/db
</verification>

<success_criteria>
- gmail_tokens table exists with encrypted token columns, RLS, indexes, and ON DELETE CASCADE from users
- AES-256-GCM encryption round-trips: encrypt then decrypt returns original value
- site_settings has gmail_diagnostic_enabled boolean (default false)
- Token service provides upsert, read, delete, connection check, and race-safe refresh
- All new code exports from @everyskill/db barrel files
- Monorepo builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/50-gmail-oauth-infrastructure/50-01-SUMMARY.md`
</output>
