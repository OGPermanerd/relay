---
phase: 04-data-model-storage
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/db/src/validation/skill-formats.ts
  - packages/db/src/validation/index.ts
  - packages/db/package.json
  - packages/db/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Validation schemas accept all four skill formats: prompt, workflow, agent, mcp"
    - "Each format has specific metadata fields validated"
    - "Common base fields (name, description) are validated for all formats"
    - "Invalid skill data fails validation with descriptive errors"
  artifacts:
    - path: "packages/db/src/validation/skill-formats.ts"
      provides: "Zod schemas for skill format validation"
      exports: ["skillMetadataSchema", "validateSkillMetadata", "SkillFormat"]
    - path: "packages/db/src/validation/index.ts"
      provides: "Validation module exports"
      exports: ["skillMetadataSchema", "validateSkillMetadata"]
  key_links:
    - from: "packages/db/src/validation/skill-formats.ts"
      to: "zod"
      via: "import z from zod"
      pattern: "import.*z.*from.*zod"
---

<objective>
Create validation schemas for multi-format skill support

Purpose: SKIL-02 requires accepting Claude Code skills, prompts, workflows, and agent configs. Each format has different metadata requirements. Validation ensures data integrity before storage.
Output: Zod schemas for validating skill metadata by format type
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-data-model-storage/04-RESEARCH.md

@packages/db/src/schema/skills.ts
@packages/db/src/schema/skill-versions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zod and create validation schemas</name>
  <files>
    packages/db/package.json
    packages/db/src/validation/skill-formats.ts
  </files>
  <action>
Add zod to @relay/db dependencies:
```bash
pnpm --filter @relay/db add zod
```

Create packages/db/src/validation/ directory.

Create validation/skill-formats.ts:

```typescript
import { z } from "zod";

/**
 * Skill format types matching the category field in skills table
 */
export const skillFormats = ["prompt", "workflow", "agent", "mcp"] as const;
export type SkillFormat = (typeof skillFormats)[number];

/**
 * Base metadata common to all skill formats
 */
const baseMetadataSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().min(1).max(2000),
  tags: z.array(z.string().max(50)).max(10).optional(),
  usageInstructions: z.string().max(5000).optional(),
});

/**
 * Prompt-specific metadata
 * Prompts are simple text templates with optional variables
 */
const promptMetadataSchema = baseMetadataSchema.extend({
  format: z.literal("prompt"),
  variables: z
    .array(
      z.object({
        name: z.string(),
        description: z.string().optional(),
        required: z.boolean().default(true),
      })
    )
    .optional(),
});

/**
 * Workflow-specific metadata
 * Workflows are multi-step processes with defined stages
 */
const workflowMetadataSchema = baseMetadataSchema.extend({
  format: z.literal("workflow"),
  steps: z
    .array(
      z.object({
        name: z.string(),
        description: z.string().optional(),
      })
    )
    .optional(),
  estimatedDuration: z.string().optional(), // e.g., "5-10 minutes"
});

/**
 * Agent-specific metadata
 * Agents are Claude configurations with specific behaviors
 */
const agentMetadataSchema = baseMetadataSchema.extend({
  format: z.literal("agent"),
  systemPromptSummary: z.string().max(500).optional(),
  capabilities: z.array(z.string()).optional(),
  limitations: z.array(z.string()).optional(),
});

/**
 * MCP-specific metadata
 * MCP skills are server configurations for Claude Code
 */
const mcpMetadataSchema = baseMetadataSchema.extend({
  format: z.literal("mcp"),
  tools: z
    .array(
      z.object({
        name: z.string(),
        description: z.string().optional(),
      })
    )
    .optional(),
  resources: z.array(z.string()).optional(),
  requiredEnvVars: z.array(z.string()).optional(),
});

/**
 * Discriminated union of all skill format schemas
 * Use skillMetadataSchema.parse(data) to validate and get typed result
 */
export const skillMetadataSchema = z.discriminatedUnion("format", [
  promptMetadataSchema,
  workflowMetadataSchema,
  agentMetadataSchema,
  mcpMetadataSchema,
]);

export type SkillMetadata = z.infer<typeof skillMetadataSchema>;
export type PromptMetadata = z.infer<typeof promptMetadataSchema>;
export type WorkflowMetadata = z.infer<typeof workflowMetadataSchema>;
export type AgentMetadata = z.infer<typeof agentMetadataSchema>;
export type McpMetadata = z.infer<typeof mcpMetadataSchema>;

/**
 * Validate skill metadata with detailed error reporting
 * Returns { success: true, data } or { success: false, errors }
 */
export function validateSkillMetadata(data: unknown):
  | { success: true; data: SkillMetadata }
  | { success: false; errors: z.ZodError } {
  const result = skillMetadataSchema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, errors: result.error };
}

/**
 * Check if a string is a valid skill format
 */
export function isValidSkillFormat(format: string): format is SkillFormat {
  return skillFormats.includes(format as SkillFormat);
}
```

This uses Zod's discriminated union pattern so the format field determines which schema applies.
  </action>
  <verify>
    pnpm --filter @relay/db typecheck
  </verify>
  <done>
    zod installed, validation/skill-formats.ts exports schemas and validation function, TypeScript compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validation index and update package exports</name>
  <files>
    packages/db/src/validation/index.ts
    packages/db/src/index.ts
  </files>
  <action>
Create validation/index.ts:

```typescript
/**
 * Validation schemas for database entities
 */
export {
  skillFormats,
  skillMetadataSchema,
  validateSkillMetadata,
  isValidSkillFormat,
} from "./skill-formats";

export type {
  SkillFormat,
  SkillMetadata,
  PromptMetadata,
  WorkflowMetadata,
  AgentMetadata,
  McpMetadata,
} from "./skill-formats";
```

Update packages/db/src/index.ts to add validation export:

Add after existing exports:
```typescript
export * from "./validation";
```

This allows importing validation schemas from @relay/db:
```typescript
import { validateSkillMetadata, SkillMetadata } from "@relay/db";
```
  </action>
  <verify>
    pnpm --filter @relay/db typecheck && pnpm --filter @relay/db lint
  </verify>
  <done>
    validation/index.ts exports all validation utilities, packages/db/src/index.ts re-exports validation, typecheck and lint pass
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm --filter @relay/db typecheck` - should pass
2. Run `pnpm --filter @relay/db lint` - should pass
3. Verify skillMetadataSchema handles all four formats: prompt, workflow, agent, mcp
4. Verify validateSkillMetadata returns typed success/error result
5. Verify types are exported: SkillFormat, SkillMetadata, PromptMetadata, etc.
</verification>

<success_criteria>
- [ ] zod added to @relay/db dependencies
- [ ] validation/skill-formats.ts defines schemas for all four skill formats
- [ ] skillMetadataSchema is a discriminated union on format field
- [ ] validateSkillMetadata function returns typed result with success/error
- [ ] isValidSkillFormat type guard function exists
- [ ] All types are exported from validation/index.ts
- [ ] packages/db/src/index.ts exports validation module
- [ ] TypeScript compiles without errors
- [ ] ESLint passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-model-storage/04-04-SUMMARY.md`
</output>
