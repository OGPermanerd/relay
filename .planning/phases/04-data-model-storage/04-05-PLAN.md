---
phase: 04-data-model-storage
plan: 05
type: execute
wave: 3
depends_on: ["04-01", "04-03"]
files_modified:
  - packages/db/src/services/skill-metrics.ts
  - packages/db/src/services/index.ts
  - packages/db/src/index.ts
  - packages/db/src/seed.ts
autonomous: false

must_haves:
  truths:
    - "Skills table has denormalized totalUses updated from usageEvents"
    - "Skills table has denormalized averageRating updated from ratings"
    - "Database schema is pushed to PostgreSQL"
    - "Seed data includes skills with versions for testing"
  artifacts:
    - path: "packages/db/src/services/skill-metrics.ts"
      provides: "Functions to update denormalized skill metrics"
      exports: ["incrementSkillUses", "updateSkillRating"]
    - path: "packages/db/src/seed.ts"
      provides: "Updated seed script with versioned skills"
      contains: "skillVersions"
  key_links:
    - from: "packages/db/src/services/skill-metrics.ts"
      to: "packages/db/src/client.ts"
      via: "import db"
      pattern: "import.*db.*from"
    - from: "packages/db/src/services/skill-metrics.ts"
      to: "packages/db/src/schema/index.ts"
      via: "import schema tables"
      pattern: "import.*skills.*from"
---

<objective>
Wire usage tracking to skill metrics and push schema to database

Purpose: The denormalized totalUses and averageRating fields on skills need to be updated when usageEvents are recorded or ratings are added. This completes the data model by connecting usage tracking (MCP Phase 3) to skill metrics.
Output: Service functions for metric updates, updated seed data, and schema pushed to database
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-data-model-storage/04-RESEARCH.md

@packages/db/src/schema/skills.ts
@packages/db/src/schema/skill-versions.ts
@packages/db/src/schema/ratings.ts
@packages/db/src/schema/usage-events.ts
@packages/db/src/relations/index.ts
@packages/db/src/client.ts
@packages/db/src/seed.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill metrics service</name>
  <files>
    packages/db/src/services/skill-metrics.ts
    packages/db/src/services/index.ts
    packages/db/src/index.ts
  </files>
  <action>
Create packages/db/src/services/ directory.

Create services/skill-metrics.ts:

```typescript
import { eq, sql, avg } from "drizzle-orm";
import { db } from "../client";
import { skills, ratings } from "../schema";

/**
 * Increment the totalUses counter for a skill
 * Called when a usage event is recorded for this skill
 *
 * Uses SQL increment to avoid race conditions:
 * totalUses = totalUses + 1
 */
export async function incrementSkillUses(skillId: string): Promise<void> {
  if (!db) {
    console.warn("Database not configured, skipping incrementSkillUses");
    return;
  }

  await db
    .update(skills)
    .set({
      totalUses: sql`COALESCE(${skills.totalUses}, 0) + 1`,
      updatedAt: new Date(),
    })
    .where(eq(skills.id, skillId));
}

/**
 * Recalculate and update the averageRating for a skill
 * Called after a rating is added or modified
 *
 * Calculates average from all ratings and stores as integer (rating * 100)
 * e.g., 4.5 stars stored as 450
 */
export async function updateSkillRating(skillId: string): Promise<void> {
  if (!db) {
    console.warn("Database not configured, skipping updateSkillRating");
    return;
  }

  // Calculate average rating for this skill
  const result = await db
    .select({
      avgRating: avg(ratings.rating),
    })
    .from(ratings)
    .where(eq(ratings.skillId, skillId));

  const avgRating = result[0]?.avgRating;

  // Update skill with new average (multiply by 100 for precision)
  await db
    .update(skills)
    .set({
      averageRating: avgRating ? Math.round(Number(avgRating) * 100) : null,
      updatedAt: new Date(),
    })
    .where(eq(skills.id, skillId));
}

/**
 * Get formatted rating display value
 * Converts stored integer (e.g., 450) to display string (e.g., "4.5")
 */
export function formatRating(storedRating: number | null): string | null {
  if (storedRating === null) return null;
  return (storedRating / 100).toFixed(1);
}
```

Create services/index.ts:

```typescript
export {
  incrementSkillUses,
  updateSkillRating,
  formatRating,
} from "./skill-metrics";
```

Update packages/db/src/index.ts to add services export:

Add after existing exports:
```typescript
export * from "./services";
```
  </action>
  <verify>
    pnpm --filter @everyskill/db typecheck && pnpm --filter @everyskill/db lint
  </verify>
  <done>
    services/skill-metrics.ts exports incrementSkillUses and updateSkillRating, functions use SQL increment/aggregate patterns, typecheck and lint pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Update seed script with versioned skill data</name>
  <files>
    packages/db/src/seed.ts
  </files>
  <action>
Update seed.ts to include skillVersions and demonstrate the versioning model.

The seed script should:
1. Keep existing skills insert (for backward compatibility check)
2. Add skillVersions records for each skill
3. Update skills with publishedVersionId references
4. Add sample ratings

Structure:
```typescript
// After inserting skills, create versions for each
const skillVersionData = [
  {
    id: crypto.randomUUID(),
    skillId: skills[0].id,
    version: 1,
    contentUrl: `skills/${skills[0].id}/v1/content`,
    contentHash: "placeholder-hash-v1",
    contentType: "text/markdown",
    name: skills[0].name,
    description: skills[0].description,
    createdBy: testUser.id,
  },
  // ... more versions
];

// Insert versions
await db.insert(skillVersions).values(skillVersionData);

// Update skills with publishedVersionId
for (const skill of skillData) {
  const version = skillVersionData.find(v => v.skillId === skill.id);
  if (version) {
    await db.update(skills)
      .set({ publishedVersionId: version.id })
      .where(eq(skills.id, skill.id));
  }
}

// Add sample ratings
const ratingData = [
  {
    skillId: skills[0].id,
    userId: testUser.id,
    rating: 5,
    comment: "Excellent prompt, saved me hours!",
    hoursSavedEstimate: 2,
  },
  // ... more ratings
];

await db.insert(ratings).values(ratingData);
```

Also update the totalUses counters based on existing usage events or set initial values.

Keep the seed idempotent - check for existing data before inserting.
  </action>
  <verify>
    pnpm --filter @everyskill/db typecheck
  </verify>
  <done>
    seed.ts creates skills with versions, updates publishedVersionId references, adds sample ratings, typecheck passes
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Push schema and verify database</name>
  <what-built>
    Complete data model with:
    - skillVersions table (immutable version records)
    - ratings table (user ratings with comments)
    - Extended skills table (version references, denormalized metrics)
    - Drizzle relations for type-safe queries
    - Service functions for metric updates
  </what-built>
  <how-to-verify>
    1. Ensure Docker is running and database container is started:
       ```bash
       docker compose up -d db
       ```

    2. Push schema to database:
       ```bash
       pnpm --filter @everyskill/db db:push
       ```
       Expected: Schema changes applied, new tables created

    3. Verify tables exist:
       ```bash
       docker exec -it relay-db psql -U relay -d relay -c "\dt"
       ```
       Expected: skills, skill_versions, ratings, usage_events, users tables listed

    4. Run seed script:
       ```bash
       pnpm --filter @everyskill/db db:seed
       ```
       Expected: Seed data inserted with skills, versions, and ratings

    5. Open Drizzle Studio to visually verify:
       ```bash
       pnpm --filter @everyskill/db db:studio
       ```
       Expected: Studio opens at localhost:4983, can browse all tables
  </how-to-verify>
  <resume-signal>Type "approved" if schema pushed successfully and tables verified, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Run `pnpm --filter @everyskill/db typecheck` - should pass
2. Run `pnpm --filter @everyskill/db lint` - should pass
3. Verify services/skill-metrics.ts exports incrementSkillUses, updateSkillRating, formatRating
4. Verify seed.ts includes skillVersions and ratings data
5. Database push creates skill_versions and ratings tables
6. Seed script populates versioned data successfully
</verification>

<success_criteria>
- [ ] services/skill-metrics.ts exports metric update functions
- [ ] incrementSkillUses uses SQL COALESCE + increment pattern
- [ ] updateSkillRating calculates average from ratings table
- [ ] formatRating converts stored integer to display string
- [ ] seed.ts creates skills with versions and ratings
- [ ] Database push succeeds (skill_versions, ratings tables created)
- [ ] Seed script populates test data successfully
- [ ] TypeScript compiles without errors
- [ ] ESLint passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-model-storage/04-05-SUMMARY.md`
</output>
