---
phase: 21-employee-usage-tracking
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/my-leverage.ts
autonomous: true

must_haves:
  truths:
    - "Skills Used query returns paginated timeline entries for a userId"
    - "Skills Used stats return total skills, total hours saved, total actions, most-used skill"
    - "Skills Created query returns authored skills with impact metrics"
    - "Skills Created stats return skills published, hours saved by others, unique users, avg rating"
    - "FTE hours use COALESCE fallback (rating estimate -> creator estimate -> 1)"
  artifacts:
    - path: "apps/web/lib/my-leverage.ts"
      provides: "Usage analytics queries"
      exports: ["getSkillsUsed", "getSkillsUsedStats", "getSkillsCreated", "getSkillsCreatedStats"]
  key_links:
    - from: "apps/web/lib/my-leverage.ts"
      to: "@relay/db"
      via: "db.execute(sql`...`) with CTEs"
      pattern: "db\\.execute"
---

<objective>
Create usage analytics data-fetching functions for the My Leverage view.

Purpose: Server-side aggregation queries powering Skills Used and Skills Created sections (TRK-04).
Output: my-leverage.ts with 4 exported query functions.
</objective>

<context>
@apps/web/lib/leaderboard.ts
@packages/db/src/schema/usage-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create my-leverage.ts with aggregation queries</name>
  <files>apps/web/lib/my-leverage.ts</files>
  <action>
Create `apps/web/lib/my-leverage.ts` with these 4 functions. Follow the exact pattern from `leaderboard.ts`: import `db` from `@relay/db`, `sql` from `drizzle-orm`, use `db.execute(sql\`...\`)` for raw SQL, cast results as `unknown as Record<string, unknown>[]`.

1. `getSkillsUsed(userId: string, limit = 20, offset = 0)`:
   Returns `{ items: TimelineEntry[], total: number }`.
   SQL: SELECT from usage_events ue LEFT JOIN skills s ON s.id = ue.skill_id LEFT JOIN ratings r ON r.skill_id = ue.skill_id AND r.user_id = ue.user_id WHERE ue.user_id = userId, ORDER BY ue.created_at DESC, LIMIT/OFFSET. Use `COUNT(*) OVER()` window function for total. Return: skillId, skillName, category, action (toolName), timestamp (createdAt), hoursSaved (COALESCE(r.hours_saved_estimate, s.hours_saved, 1)). The LEFT JOIN to ratings enables user's own review estimate to take precedence over the creator's estimate.

2. `getSkillsUsedStats(userId: string)`:
   Returns `{ totalSkills: number, totalHoursSaved: number, totalActions: number, mostUsedSkill: string | null }`.
   SQL: Single query with subquery for most-used skill. COUNT(DISTINCT skill_id), SUM(COALESCE(r.hours_saved_estimate, s.hours_saved, 1)) with same ratings LEFT JOIN, COUNT(*).

3. `getSkillsCreated(userId: string)`:
   Returns `{ items: CreatedSkillEntry[] }`.
   SQL: SELECT from skills s LEFT JOIN usage_events ue ON ue.skill_id = s.id WHERE s.author_id = userId AND s.published_version_id IS NOT NULL. GROUP BY s.id. Include: skillId, name, category, totalUses, hoursPerUse (COALESCE(s.hours_saved, 1)), totalHoursSaved (totalUses * hoursPerUse), uniqueUsers (COUNT(DISTINCT ue.user_id)), avgRating (s.average_rating / 100.0). ORDER BY totalHoursSaved DESC.

4. `getSkillsCreatedStats(userId: string)`:
   Returns `{ skillsPublished: number, hoursSavedByOthers: number, uniqueUsers: number, avgRating: number }`.
   SQL: Aggregate across all published skills by this author.

Export TypeScript interfaces for TimelineEntry and CreatedSkillEntry at top of file. Handle `if (!db) return { items: [], total: 0 }` (or equivalent empty state) in every function.
  </action>
  <verify>
`cd /home/dev/projects/relay && npx tsc --noEmit -p apps/web/tsconfig.json` compiles.
Grep my-leverage.ts for "db.execute" -- should find 4 calls.
  </verify>
  <done>
4 query functions export from my-leverage.ts. Each handles null DB gracefully. SQL uses CTEs/window functions following leaderboard.ts pattern. FTE hours use COALESCE fallback.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles
- All 4 functions exported
- Each function handles null db
- SQL uses COALESCE for hours_saved fallback
</verification>

<success_criteria>
my-leverage.ts provides getSkillsUsed (paginated timeline), getSkillsUsedStats (summary cards), getSkillsCreated (authored skills impact), getSkillsCreatedStats (author summary cards). All queries use server-side SQL aggregation, not client-side JS.
</success_criteria>

<output>
After completion, create `.planning/phases/21-employee-usage-tracking/21-04-SUMMARY.md`
</output>
