---
phase: 45-hybrid-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/scripts/backfill-embeddings.ts
  - apps/web/lib/generate-skill-embedding.ts
autonomous: true

must_haves:
  truths:
    - "All published skills have embedding vectors in skill_embeddings table"
    - "site_settings row exists with semanticSimilarityEnabled=true"
    - "New skill creation automatically generates an embedding"
  artifacts:
    - path: "packages/db/src/scripts/backfill-embeddings.ts"
      provides: "One-time embedding backfill script"
      contains: "backfill"
    - path: "apps/web/lib/generate-skill-embedding.ts"
      provides: "Reusable embedding generation for skill create/update"
      contains: "generateSkillEmbedding"
  key_links:
    - from: "packages/db/src/scripts/backfill-embeddings.ts"
      to: "packages/db/src/services/skill-embeddings.ts"
      via: "upsertSkillEmbedding"
      pattern: "upsertSkillEmbedding"
    - from: "apps/web/lib/generate-skill-embedding.ts"
      to: "apps/web/lib/ollama.ts"
      via: "generateEmbedding call"
      pattern: "generateEmbedding"
---

<objective>
Backfill embeddings for all published skills and wire auto-generation on skill create/update.

Purpose: Hybrid search (Plan 02) requires populated embeddings to return semantic results. Currently 0 rows exist in skill_embeddings despite 145+ published skills.
Output: All skills have embeddings, site_settings enabled, and new skills auto-embed.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/db/src/services/skill-embeddings.ts
@packages/db/src/services/site-settings.ts
@packages/db/src/schema/skill-embeddings.ts
@apps/web/lib/ollama.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backfill script and run it</name>
  <files>packages/db/src/scripts/backfill-embeddings.ts</files>
  <action>
Create `packages/db/src/scripts/backfill-embeddings.ts` that:

1. Imports `db`, `skills` from `../client` and `../schema/skills`, `eq` from `drizzle-orm`
2. Imports `upsertSkillEmbedding` from `../services/skill-embeddings`
3. Uses `updateSiteSettings` from `../services/site-settings` to ensure a site_settings row exists with `semanticSimilarityEnabled: true`. Use tenant ID `"default-tenant-000-0000-000000000000"` and upsert via the existing `updateSiteSettings()` function.
4. Queries all published skills: `db.select({ id, name, description, tenantId }).from(skills).where(eq(skills.status, "published"))`
5. Processes skills sequentially (NOT Promise.all -- Ollama is single-threaded):
   - For each skill, compose text: `${skill.name} ${skill.description}`
   - Generate embedding via direct Ollama fetch: `POST http://localhost:11434/api/embed` with `{ model: "nomic-embed-text", input: text }`
   - Use a 10s timeout per request (backfill can be slower than real-time)
   - On success, call `upsertSkillEmbedding({ tenantId: skill.tenantId, skillId: skill.id, embedding, modelName: "nomic-embed-text", dimensions: 768, inputHash: createHash(text) })`
   - Use `crypto.createHash("sha256").update(text).digest("hex")` for inputHash
   - Log progress: `[N/total] Embedded: skill.name`
   - On failure, log warning and continue (don't abort the whole backfill)
6. At end, log summary: `Done. Embedded X/Y skills. Z failures.`

Make this script runnable with `npx tsx packages/db/src/scripts/backfill-embeddings.ts`.

After creating the script, run it:
```bash
cd /home/dev/projects/relay && npx tsx packages/db/src/scripts/backfill-embeddings.ts
```

Verify embeddings were created:
```bash
cd /home/dev/projects/relay && npx tsx -e "
  const { db } = require('./packages/db/src/client');
  const { sql } = require('drizzle-orm');
  const result = await db.execute(sql\`SELECT count(*) as cnt FROM skill_embeddings\`);
  console.log('Embeddings count:', result[0].cnt);
  process.exit(0);
"
```
  </action>
  <verify>Run `psql -d everyskill -c "SELECT count(*) FROM skill_embeddings;"` and confirm count > 100. Run `psql -d everyskill -c "SELECT semantic_similarity_enabled FROM site_settings;"` and confirm true.</verify>
  <done>All published skills have embedding rows in skill_embeddings. site_settings has semanticSimilarityEnabled=true.</done>
</task>

<task type="auto">
  <name>Task 2: Create reusable embedding generator and wire to skill creation</name>
  <files>apps/web/lib/generate-skill-embedding.ts</files>
  <action>
Create `apps/web/lib/generate-skill-embedding.ts`:

```typescript
import { getSiteSettings, upsertSkillEmbedding } from "@everyskill/db";
import { generateEmbedding } from "./ollama";
import { createHash } from "crypto";

/**
 * Generate and store an embedding for a skill. Fire-and-forget safe.
 * Returns true if embedding was stored, false on any failure.
 */
export async function generateAndStoreSkillEmbedding(params: {
  skillId: string;
  tenantId: string;
  name: string;
  description: string;
}): Promise<boolean> {
  try {
    const settings = await getSiteSettings();
    if (!settings?.semanticSimilarityEnabled) return false;

    const text = `${params.name} ${params.description}`;
    const embedding = await generateEmbedding(text, {
      url: settings.ollamaUrl,
      model: settings.ollamaModel,
    });
    if (!embedding) return false;

    const inputHash = createHash("sha256").update(text).digest("hex");
    await upsertSkillEmbedding({
      tenantId: params.tenantId,
      skillId: params.skillId,
      embedding,
      modelName: settings.ollamaModel,
      dimensions: settings.embeddingDimensions,
      inputHash,
    });
    return true;
  } catch {
    return false;
  }
}
```

Then find the skill creation/publish server action. Look in `apps/web/app/actions/` for the action that creates or publishes a skill. Add a fire-and-forget call to `generateAndStoreSkillEmbedding()` after successful skill creation/publish. Use `void generateAndStoreSkillEmbedding(...)` pattern (don't await -- don't block the user).

Also find the skill update/edit action. Wire the same fire-and-forget call there so embeddings stay fresh when skills are edited.

Important: Only call when the skill is being published (status = 'published'). Don't generate embeddings for drafts.
  </action>
  <verify>Create a test skill via the UI or directly via the skill creation action. Check `psql -d everyskill -c "SELECT skill_id FROM skill_embeddings ORDER BY created_at DESC LIMIT 1;"` to confirm new embedding was created.</verify>
  <done>New published skills automatically get embeddings generated via fire-and-forget. Edited published skills get their embeddings refreshed.</done>
</task>

</tasks>

<verification>
1. `psql -d everyskill -c "SELECT count(*) FROM skill_embeddings;"` shows count matching published skill count
2. `psql -d everyskill -c "SELECT semantic_similarity_enabled FROM site_settings;"` returns true
3. `apps/web/lib/generate-skill-embedding.ts` exists and exports `generateAndStoreSkillEmbedding`
4. Skill create/update actions call `generateAndStoreSkillEmbedding` fire-and-forget
</verification>

<success_criteria>
- 140+ embeddings exist in skill_embeddings table
- site_settings.semanticSimilarityEnabled is true
- New skill publishes trigger embedding generation automatically
- No blocking of user-facing operations (fire-and-forget pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/45-hybrid-search/45-01-SUMMARY.md`
</output>
