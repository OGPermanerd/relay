---
phase: 45-hybrid-search
plan: 02
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - packages/db/src/services/hybrid-search.ts
  - packages/db/src/services/index.ts
  - apps/web/app/actions/discover.ts
autonomous: true

must_haves:
  truths:
    - "Hybrid search returns results combining keyword and semantic matches via RRF"
    - "Search falls back to keyword-only when Ollama is unavailable or embedding fails"
    - "User preferred categories get a 1.3x score boost in results"
    - "Visibility filtering prevents users from seeing unauthorized skills"
  artifacts:
    - path: "packages/db/src/services/hybrid-search.ts"
      provides: "SQL-level RRF hybrid search query"
      contains: "hybridSearchSkills"
    - path: "apps/web/app/actions/discover.ts"
      provides: "Server action orchestrating embedding + RRF + preference boost + rationale"
      contains: "discoverSkills"
  key_links:
    - from: "apps/web/app/actions/discover.ts"
      to: "packages/db/src/services/hybrid-search.ts"
      via: "hybridSearchSkills call"
      pattern: "hybridSearchSkills"
    - from: "apps/web/app/actions/discover.ts"
      to: "apps/web/lib/ollama.ts"
      via: "generateEmbedding for query"
      pattern: "generateEmbedding"
    - from: "apps/web/app/actions/discover.ts"
      to: "packages/db/src/services/user-preferences.ts"
      via: "getOrCreateUserPreferences for boost"
      pattern: "getOrCreateUserPreferences"
---

<objective>
Build the hybrid search backend: RRF SQL query, server action with fallback, and preference boost.

Purpose: This is the core search intelligence -- combining full-text and semantic retrieval via Reciprocal Rank Fusion, with graceful degradation and personalization.
Output: `discoverSkills()` server action that Plan 03 UI will consume.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/db/src/services/semantic-search.ts
@packages/db/src/lib/visibility.ts
@apps/web/lib/ollama.ts
@apps/web/lib/search-skills.ts
@packages/db/src/services/user-preferences.ts
@packages/db/src/services/site-settings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hybrid search SQL service with RRF</name>
  <files>packages/db/src/services/hybrid-search.ts, packages/db/src/services/index.ts</files>
  <action>
Create `packages/db/src/services/hybrid-search.ts`:

```typescript
import { db } from "../client";
import { sql } from "drizzle-orm";
import { visibilitySQL } from "../lib/visibility";

export interface HybridSearchResult {
  id: string;
  name: string;
  slug: string;
  description: string;
  category: string;
  totalUses: number;
  averageRating: number | null;
  authorId: string | null;
  ftRank: number | null;
  smRank: number | null;
  rrfScore: number;
}

/**
 * Hybrid search combining full-text (tsvector) and semantic (pgvector) via RRF.
 * Uses k=60 (industry standard). Each CTE limited to 20 results.
 * FULL OUTER JOIN ensures results from either method are included.
 */
export async function hybridSearchSkills(params: {
  query: string;
  queryEmbedding: number[];
  userId?: string;
  limit?: number;
}): Promise<HybridSearchResult[]> {
  if (!db) return [];
  const { query, queryEmbedding, userId, limit = 10 } = params;
  const vectorStr = `[${queryEmbedding.join(",")}]`;
  const vis = visibilitySQL(userId);

  const results = await db.execute(sql`
    WITH full_text AS (
      SELECT s.id, s.name, s.slug, s.description, s.category,
             s.total_uses, s.average_rating, s.author_id,
             row_number() OVER (
               ORDER BY ts_rank(s.search_vector, websearch_to_tsquery('english', ${query})) DESC
             ) AS rank_ix
      FROM skills s
      WHERE s.search_vector @@ websearch_to_tsquery('english', ${query})
        AND s.status = 'published'
        AND ${vis}
      ORDER BY rank_ix
      LIMIT 20
    ),
    semantic AS (
      SELECT s.id, s.name, s.slug, s.description, s.category,
             s.total_uses, s.average_rating, s.author_id,
             row_number() OVER (
               ORDER BY se.embedding <=> ${vectorStr}::vector
             ) AS rank_ix
      FROM skill_embeddings se
      JOIN skills s ON s.id = se.skill_id
      WHERE s.status = 'published'
        AND ${vis}
      ORDER BY rank_ix
      LIMIT 20
    )
    SELECT
      COALESCE(ft.id, sm.id) AS id,
      COALESCE(ft.name, sm.name) AS name,
      COALESCE(ft.slug, sm.slug) AS slug,
      COALESCE(ft.description, sm.description) AS description,
      COALESCE(ft.category, sm.category) AS category,
      COALESCE(ft.total_uses, sm.total_uses) AS total_uses,
      COALESCE(ft.average_rating, sm.average_rating) AS average_rating,
      COALESCE(ft.author_id, sm.author_id) AS author_id,
      ft.rank_ix AS ft_rank,
      sm.rank_ix AS sm_rank,
      COALESCE(1.0 / (60 + ft.rank_ix), 0.0) +
      COALESCE(1.0 / (60 + sm.rank_ix), 0.0) AS rrf_score
    FROM full_text ft
    FULL OUTER JOIN semantic sm ON ft.id = sm.id
    ORDER BY rrf_score DESC
    LIMIT ${limit}
  `);

  return (results as unknown as Record<string, unknown>[]).map(row => ({
    id: String(row.id),
    name: String(row.name),
    slug: String(row.slug),
    description: String(row.description),
    category: String(row.category),
    totalUses: Number(row.total_uses) || 0,
    averageRating: row.average_rating != null ? Number(row.average_rating) : null,
    authorId: row.author_id ? String(row.author_id) : null,
    ftRank: row.ft_rank != null ? Number(row.ft_rank) : null,
    smRank: row.sm_rank != null ? Number(row.sm_rank) : null,
    rrfScore: Number(row.rrf_score) || 0,
  }));
}

/**
 * Keyword-only search fallback when semantic search is unavailable.
 * Uses the same tsvector full-text search with ILIKE fallback.
 */
export async function keywordSearchSkills(params: {
  query: string;
  userId?: string;
  limit?: number;
}): Promise<HybridSearchResult[]> {
  if (!db) return [];
  const { query, userId, limit = 10 } = params;
  const vis = visibilitySQL(userId);
  const likePattern = `%${query}%`;

  const results = await db.execute(sql`
    SELECT s.id, s.name, s.slug, s.description, s.category,
           s.total_uses, s.average_rating, s.author_id,
           row_number() OVER (
             ORDER BY ts_rank(s.search_vector, websearch_to_tsquery('english', ${query})) DESC
           ) AS rank_ix
    FROM skills s
    WHERE s.status = 'published'
      AND ${vis}
      AND (
        s.search_vector @@ websearch_to_tsquery('english', ${query})
        OR s.name ILIKE ${likePattern}
        OR s.description ILIKE ${likePattern}
      )
    ORDER BY rank_ix
    LIMIT ${limit}
  `);

  return (results as unknown as Record<string, unknown>[]).map(row => ({
    id: String(row.id),
    name: String(row.name),
    slug: String(row.slug),
    description: String(row.description),
    category: String(row.category),
    totalUses: Number(row.total_uses) || 0,
    averageRating: row.average_rating != null ? Number(row.average_rating) : null,
    authorId: row.author_id ? String(row.author_id) : null,
    ftRank: Number(row.rank_ix),
    smRank: null,
    rrfScore: 1.0 / (60 + Number(row.rank_ix)),
  }));
}
```

Add export to `packages/db/src/services/index.ts`:
```typescript
export { hybridSearchSkills, keywordSearchSkills, type HybridSearchResult } from "./hybrid-search";
```
  </action>
  <verify>`npx tsc --noEmit -p packages/db/tsconfig.json` compiles without errors (or `pnpm build` from root). Grep for `hybridSearchSkills` in `packages/db/src/services/index.ts` to confirm export.</verify>
  <done>hybrid-search.ts service exists with RRF SQL query, keyword fallback, and proper visibility filtering. Exported from services/index.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create discover server action with orchestration</name>
  <files>apps/web/app/actions/discover.ts</files>
  <action>
Create `apps/web/app/actions/discover.ts`:

```typescript
"use server";

import { auth } from "@/auth";
import { generateEmbedding } from "@/lib/ollama";
import {
  getSiteSettings,
  hybridSearchSkills,
  keywordSearchSkills,
  getOrCreateUserPreferences,
  type HybridSearchResult,
} from "@everyskill/db";

const DEFAULT_TENANT_ID = "default-tenant-000-0000-000000000000";
const PREFERENCE_BOOST = 1.3;

export interface DiscoveryResult {
  id: string;
  name: string;
  slug: string;
  description: string;
  category: string;
  totalUses: number;
  averageRating: number | null;
  matchRationale: string;
  matchType: "keyword" | "semantic" | "both";
  rrfScore: number;
  isBoosted: boolean;
}

function generateRationale(ftRank: number | null, smRank: number | null, query: string): {
  rationale: string;
  matchType: "keyword" | "semantic" | "both";
} {
  if (ftRank != null && smRank != null) {
    return {
      rationale: `Matches your search terms and is semantically related to "${query}"`,
      matchType: "both",
    };
  }
  if (ftRank != null) {
    return {
      rationale: `Contains keywords matching "${query}"`,
      matchType: "keyword",
    };
  }
  return {
    rationale: `Semantically similar to what you're looking for`,
    matchType: "semantic",
  };
}

function applyPreferenceBoost(
  results: (HybridSearchResult & { matchRationale: string; matchType: "keyword" | "semantic" | "both" })[],
  preferredCategories: string[]
): DiscoveryResult[] {
  const boosted = results.map(r => {
    const isBoosted = preferredCategories.includes(r.category);
    return {
      id: r.id,
      name: r.name,
      slug: r.slug,
      description: r.description,
      category: r.category,
      totalUses: r.totalUses,
      averageRating: r.averageRating,
      matchRationale: r.matchRationale,
      matchType: r.matchType,
      rrfScore: isBoosted ? r.rrfScore * PREFERENCE_BOOST : r.rrfScore,
      isBoosted,
    };
  });
  boosted.sort((a, b) => b.rrfScore - a.rrfScore);
  return boosted;
}

/**
 * Discover skills using hybrid search (semantic + full-text + RRF).
 * Falls back to keyword-only if Ollama is unavailable.
 * Applies preference boost for user's preferred categories.
 *
 * Returns top results (default 3) with match rationale.
 */
export async function discoverSkills(query: string, limit = 3): Promise<DiscoveryResult[]> {
  if (!query || !query.trim()) return [];

  const trimmed = query.trim();
  const session = await auth();
  const userId = session?.user?.id;
  const tenantId = session?.user?.tenantId ?? DEFAULT_TENANT_ID;

  // 1. Try to get query embedding for semantic search
  let queryEmbedding: number[] | null = null;
  try {
    const settings = await getSiteSettings();
    if (settings?.semanticSimilarityEnabled) {
      queryEmbedding = await generateEmbedding(trimmed, {
        url: settings.ollamaUrl,
        model: settings.ollamaModel,
      });
    }
  } catch {
    // Embedding failed -- will fall back to keyword-only
  }

  // 2. Run hybrid or keyword-only search
  let rawResults: HybridSearchResult[];
  if (queryEmbedding) {
    rawResults = await hybridSearchSkills({
      query: trimmed,
      queryEmbedding,
      userId,
      limit: limit + 5, // fetch extra for post-boost reranking
    });

    // If hybrid returned nothing, fall back to keyword
    if (rawResults.length === 0) {
      rawResults = await keywordSearchSkills({ query: trimmed, userId, limit: limit + 5 });
    }
  } else {
    rawResults = await keywordSearchSkills({ query: trimmed, userId, limit: limit + 5 });
  }

  if (rawResults.length === 0) return [];

  // 3. Generate rationale for each result
  const withRationale = rawResults.map(r => {
    const { rationale, matchType } = generateRationale(r.ftRank, r.smRank, trimmed);
    return { ...r, matchRationale: rationale, matchType };
  });

  // 4. Apply preference boost
  let preferredCategories: string[] = [];
  if (userId) {
    try {
      const prefs = await getOrCreateUserPreferences(userId, tenantId);
      preferredCategories = prefs?.preferredCategories ?? [];
    } catch {
      // Preferences unavailable -- no boost
    }
  }

  const finalResults = applyPreferenceBoost(withRationale, preferredCategories);

  // 5. Return top N
  return finalResults.slice(0, limit);
}
```

Key design decisions:
- Fetch `limit + 5` from DB to allow preference reranking to surface boosted results
- Never block on Ollama failure -- wrap in try/catch, fall back to keyword
- Rationale is computed from which CTE contributed (no AI call, zero latency cost)
- Preference boost is 1.3x for categories the user has marked as preferred
- Visibility is handled at the SQL level in hybridSearchSkills/keywordSearchSkills
  </action>
  <verify>TypeScript compiles: `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit`. Import `discoverSkills` from `@/app/actions/discover` is resolvable.</verify>
  <done>discoverSkills() server action exists, handles hybrid search with RRF, keyword fallback, preference boost, and match rationale generation. Ready for UI consumption.</done>
</task>

</tasks>

<verification>
1. `packages/db/src/services/hybrid-search.ts` exports `hybridSearchSkills` and `keywordSearchSkills`
2. `apps/web/app/actions/discover.ts` exports `discoverSkills` returning `DiscoveryResult[]`
3. TypeScript compiles without errors
4. `discoverSkills("code review")` returns results with hybrid scores (test manually via tsx or dev console)
5. When Ollama is stopped, `discoverSkills("code review")` still returns keyword-only results
</verification>

<success_criteria>
- Hybrid search returns merged results from both full-text and semantic search via RRF
- Keyword fallback works when Ollama is unavailable (graceful degradation)
- Preference boost applied for user's preferred categories
- Each result has a human-readable matchRationale and matchType
- Visibility filtering prevents seeing unauthorized skills
</success_criteria>

<output>
After completion, create `.planning/phases/45-hybrid-search/45-02-SUMMARY.md`
</output>
