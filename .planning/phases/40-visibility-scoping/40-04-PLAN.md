---
phase: 40-visibility-scoping
plan: 04
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - apps/mcp/src/tools/search.ts
  - apps/mcp/src/tools/recommend.ts
  - apps/mcp/src/tools/list.ts
  - apps/mcp/src/tools/describe.ts
  - apps/mcp/src/tools/create.ts
  - packages/db/src/services/search-skills.ts
  - packages/db/src/services/semantic-search.ts
autonomous: true

must_haves:
  truths:
    - "MCP search returns only skills the authenticated user is allowed to see"
    - "MCP recommend returns only skills the authenticated user is allowed to see"
    - "MCP list returns only tenant-visible and user's own personal skills"
    - "MCP describe returns 'not found' for personal skills not owned by the requesting user"
    - "MCP create accepts optional visibility parameter"
  artifacts:
    - path: "apps/mcp/src/tools/search.ts"
      provides: "Visibility-filtered MCP search"
      contains: "userId"
    - path: "apps/mcp/src/tools/list.ts"
      provides: "Visibility-filtered MCP list"
      contains: "visibility"
    - path: "packages/db/src/services/search-skills.ts"
      provides: "DB service accepting userId for visibility"
      contains: "userId"
    - path: "packages/db/src/services/semantic-search.ts"
      provides: "DB service accepting userId for visibility"
      contains: "userId"
  key_links:
    - from: "apps/mcp/src/tools/search.ts"
      to: "packages/db/src/services/search-skills.ts"
      via: "passes userId to searchSkillsByQuery"
      pattern: "userId"
    - from: "packages/db/src/services/search-skills.ts"
      to: "packages/db/src/lib/visibility.ts"
      via: "import buildVisibilityFilter"
      pattern: "buildVisibilityFilter"
    - from: "apps/mcp/src/tools/list.ts"
      to: "packages/db/src/lib/visibility.ts"
      via: "import buildVisibilityFilter for DB query"
      pattern: "buildVisibilityFilter\\|visibility"
---

<objective>
Apply visibility filtering to all MCP tool paths -- search, recommend, list, describe, and create -- by threading userId from the MCP auth module into the database service layer.

Purpose: Implements VIS-03 -- MCP search and recommend tools return only skills the authenticated user is allowed to see.
Output: All MCP tools respect visibility scoping.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/40-visibility-scoping/40-01-SUMMARY.md
@packages/db/src/lib/visibility.ts
@apps/mcp/src/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add userId to DB service functions (search-skills, semantic-search)</name>
  <files>
    packages/db/src/services/search-skills.ts
    packages/db/src/services/semantic-search.ts
    packages/db/src/services/skill-forks.ts
  </files>
  <action>
**1. packages/db/src/services/search-skills.ts**
- Read the file first.
- Import `buildVisibilityFilter` from `../lib/visibility`.
- Add `userId?: string` to the function parameters (likely in a params object or as a separate arg).
- In the query conditions, after `eq(skills.status, "published")`, add: `buildVisibilityFilter(userId)`.

**2. packages/db/src/services/semantic-search.ts**
- Read the file first.
- Import `buildVisibilityFilter` from `../lib/visibility`.
- Add `userId?: string` to `semanticSearchSkills()` parameters.
- If using Drizzle query builder: add `buildVisibilityFilter(userId)` to conditions.
- If using raw SQL: import `visibilitySQL` and interpolate `AND ${visibilitySQL(userId)}` into the query.

**3. packages/db/src/services/skill-forks.ts**
- Read the file first.
- Import `buildVisibilityFilter` from `../lib/visibility`.
- Add `userId?: string` to `getForkCount()` and `getTopForks()` parameters.
- Add `buildVisibilityFilter(userId)` to query conditions.
- This ensures fork counts and top forks only show visible skills.

All changes are backward-compatible: userId is optional, and when not provided, only tenant-visible skills are returned (same as current behavior).
  </action>
  <verify>
Run: `cd /home/dev/projects/relay && pnpm --filter @everyskill/db typecheck`
Expected: No type errors. The new userId parameters are optional so existing callers are unaffected.
  </verify>
  <done>
searchSkillsByQuery, semanticSearchSkills, getForkCount, and getTopForks all accept optional userId parameter and apply visibility filtering. Default behavior (no userId) returns only tenant-visible skills.
  </done>
</task>

<task type="auto">
  <name>Task 2: Thread userId through MCP tools and add visibility checks</name>
  <files>
    apps/mcp/src/tools/search.ts
    apps/mcp/src/tools/recommend.ts
    apps/mcp/src/tools/list.ts
    apps/mcp/src/tools/describe.ts
    apps/mcp/src/tools/create.ts
  </files>
  <action>
**1. apps/mcp/src/tools/search.ts**
- Read the file first.
- The MCP auth module provides `getUserId()` (confirmed in research). The handler likely already receives `userId` or can call the auth function.
- Pass `userId` to the `searchSkillsByQuery()` call.

**2. apps/mcp/src/tools/recommend.ts**
- Read the file first.
- Pass `userId` to `semanticSearchSkills()` call.

**3. apps/mcp/src/tools/list.ts**
- Read the file first.
- IMPORTANT: Research notes this currently fetches ALL skills and filters in-memory. Rewrite the query to use proper Drizzle `where()` clause with:
  - `eq(skills.status, "published")` (existing logic moved to DB)
  - `buildVisibilityFilter(userId)` (new visibility filter)
- Import `buildVisibilityFilter` from `@everyskill/db/lib/visibility`.
- Remove in-memory filtering for status (move to DB query).
- Pass `userId` from auth context.

**4. apps/mcp/src/tools/describe.ts**
- Read the file first.
- After fetching the skill by ID, add a visibility check:
  - If `skill.visibility === "personal"` and `skill.authorId !== userId`, return a "skill not found" response.
  - This prevents users from accessing personal skills they don't own via the describe tool.

**5. apps/mcp/src/tools/create.ts**
- Read the file first.
- Add optional `visibility` parameter to the tool's input schema (default: "tenant").
- Validate it's one of "tenant" or "personal".
- Pass the value to the skill insert. If not provided, the DB default "tenant" applies.

For all tools: Read `apps/mcp/src/auth.ts` to understand how userId is resolved (likely from EVERYSKILL_API_KEY â†’ user lookup). Thread it through each handler that calls a DB service.
  </action>
  <verify>
Run: `cd /home/dev/projects/relay/apps/mcp && npx tsc --noEmit` (or the equivalent typecheck command)
Expected: No type errors.
Also: `cd /home/dev/projects/relay && pnpm build`
Expected: Full monorepo build succeeds.
  </verify>
  <done>
All MCP tools (search, recommend, list, describe, create) respect visibility scoping. search/recommend/list only return visible skills. describe returns "not found" for invisible personal skills. create accepts optional visibility parameter.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds across the monorepo
2. MCP search tool: personal skills of other users are excluded from results
3. MCP list tool: uses DB-level filtering (no in-memory filter for status)
4. MCP describe tool: returns not-found for personal skills of other users
5. MCP create tool: accepts visibility parameter
6. DB services: searchSkillsByQuery, semanticSearchSkills, getForkCount, getTopForks all accept userId
</verification>

<success_criteria>
- All 5 MCP tools handle visibility correctly
- DB service layer (search-skills, semantic-search, skill-forks) accepts userId and applies buildVisibilityFilter
- MCP list tool uses DB-level WHERE clause instead of in-memory filtering
- Full monorepo build passes
- No breaking changes to existing MCP functionality (userId is optional everywhere)
</success_criteria>

<output>
After completion, create `.planning/phases/40-visibility-scoping/40-04-SUMMARY.md`
</output>
