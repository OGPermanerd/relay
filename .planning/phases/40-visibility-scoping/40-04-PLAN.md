---
phase: 40-visibility-scoping
plan: 04
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - apps/mcp/src/tools/search.ts
  - apps/mcp/src/tools/recommend.ts
  - apps/mcp/src/tools/list.ts
  - apps/mcp/src/tools/describe.ts
  - apps/mcp/src/tools/create.ts
  - apps/mcp/src/tools/update-skill.ts
  - packages/db/src/services/search-skills.ts
  - packages/db/src/services/semantic-search.ts
autonomous: true

must_haves:
  truths:
    - "MCP search returns only skills the authenticated user is allowed to see"
    - "MCP recommend returns only skills the authenticated user is allowed to see"
    - "MCP list returns only tenant-visible and user's own personal skills"
    - "MCP describe returns 'not found' for personal skills not owned by the requesting user"
    - "MCP create accepts optional visibility parameter"
    - "MCP update_skill accepts optional visibility parameter in author path and sets visibility='personal' on fork path"
  artifacts:
    - path: "apps/mcp/src/tools/search.ts"
      provides: "Visibility-filtered MCP search"
      contains: "userId"
    - path: "apps/mcp/src/tools/list.ts"
      provides: "Visibility-filtered MCP list"
      contains: "visibility"
    - path: "apps/mcp/src/tools/update-skill.ts"
      provides: "Visibility-aware MCP update with fork default"
      contains: "visibility"
    - path: "packages/db/src/services/search-skills.ts"
      provides: "DB service accepting userId for visibility"
      contains: "userId"
    - path: "packages/db/src/services/semantic-search.ts"
      provides: "DB service accepting userId for visibility"
      contains: "userId"
  key_links:
    - from: "apps/mcp/src/tools/search.ts"
      to: "packages/db/src/services/search-skills.ts"
      via: "passes userId to searchSkillsByQuery"
      pattern: "userId"
    - from: "packages/db/src/services/search-skills.ts"
      to: "packages/db/src/lib/visibility.ts"
      via: "import buildVisibilityFilter"
      pattern: "buildVisibilityFilter"
    - from: "apps/mcp/src/tools/list.ts"
      to: "packages/db/src/lib/visibility.ts"
      via: "import buildVisibilityFilter for DB query"
      pattern: "buildVisibilityFilter\\|visibility"
    - from: "apps/mcp/src/tools/update-skill.ts"
      to: "skills table"
      via: "UPDATE SET visibility and INSERT with visibility='personal'"
      pattern: "visibility"
---

<objective>
Apply visibility filtering to all MCP tool paths -- search, recommend, list, describe, create, and update -- by threading userId from the MCP auth module into the database service layer.

Purpose: Implements VIS-03 -- MCP search and recommend tools return only skills the authenticated user is allowed to see. Also ensures the MCP edit path (update_skill) handles visibility for both author updates and forks.
Output: All MCP tools respect visibility scoping.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/40-visibility-scoping/40-01-SUMMARY.md
@packages/db/src/lib/visibility.ts
@apps/mcp/src/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add userId to DB service functions (search-skills, semantic-search)</name>
  <files>
    packages/db/src/services/search-skills.ts
    packages/db/src/services/semantic-search.ts
    packages/db/src/services/skill-forks.ts
  </files>
  <action>
**1. packages/db/src/services/search-skills.ts**
- Read the file first.
- Import `buildVisibilityFilter` from `../lib/visibility`.
- Add `userId?: string` to the function parameters (likely in a params object or as a separate arg).
- In the query conditions, after `eq(skills.status, "published")`, add: `buildVisibilityFilter(userId)`.

**2. packages/db/src/services/semantic-search.ts**
- Read the file first.
- Import `buildVisibilityFilter` from `../lib/visibility`.
- Add `userId?: string` to `semanticSearchSkills()` parameters.
- If using Drizzle query builder: add `buildVisibilityFilter(userId)` to conditions.
- If using raw SQL: import `visibilitySQL` and interpolate `AND ${visibilitySQL(userId)}` into the query.

**3. packages/db/src/services/skill-forks.ts**
- Read the file first.
- Import `buildVisibilityFilter` from `../lib/visibility`.
- Add `userId?: string` to `getForkCount()` and `getTopForks()` parameters.
- Add `buildVisibilityFilter(userId)` to query conditions.
- This ensures fork counts and top forks only show visible skills.

All changes are backward-compatible: userId is optional, and when not provided, only tenant-visible skills are returned (same as current behavior).
  </action>
  <verify>
Run: `cd /home/dev/projects/relay && pnpm --filter @everyskill/db typecheck`
Expected: No type errors. The new userId parameters are optional so existing callers are unaffected.
  </verify>
  <done>
searchSkillsByQuery, semanticSearchSkills, getForkCount, and getTopForks all accept optional userId parameter and apply visibility filtering. Default behavior (no userId) returns only tenant-visible skills.
  </done>
</task>

<task type="auto">
  <name>Task 2: Thread userId through MCP tools and add visibility checks</name>
  <files>
    apps/mcp/src/tools/search.ts
    apps/mcp/src/tools/recommend.ts
    apps/mcp/src/tools/list.ts
    apps/mcp/src/tools/describe.ts
    apps/mcp/src/tools/create.ts
    apps/mcp/src/tools/update-skill.ts
  </files>
  <action>
**1. apps/mcp/src/tools/search.ts**
- Read the file first.
- The MCP auth module provides `getUserId()` (confirmed in research). The handler likely already receives `userId` or can call the auth function.
- Pass `userId` to the `searchSkillsByQuery()` call.

**2. apps/mcp/src/tools/recommend.ts**
- Read the file first.
- Pass `userId` to `semanticSearchSkills()` call.

**3. apps/mcp/src/tools/list.ts**
- Read the file first.
- IMPORTANT: Research notes this currently fetches ALL skills and filters in-memory. Rewrite the query to use proper Drizzle `where()` clause with:
  - `eq(skills.status, "published")` (existing logic moved to DB)
  - `buildVisibilityFilter(userId)` (new visibility filter)
- Import `buildVisibilityFilter` from `@everyskill/db/lib/visibility`.
- Remove in-memory filtering for status (move to DB query).
- Pass `userId` from auth context.

**4. apps/mcp/src/tools/describe.ts**
- Read the file first.
- After fetching the skill by ID, add a visibility check:
  - If `skill.visibility === "personal"` and `skill.authorId !== userId`, return a "skill not found" response.
  - This prevents users from accessing personal skills they don't own via the describe tool.

**5. apps/mcp/src/tools/create.ts**
- Read the file first.
- Add optional `visibility` parameter to the tool's input schema (default: "tenant").
- Validate it's one of "tenant" or "personal".
- Pass the value to the skill insert. If not provided, the DB default "tenant" applies.

**6. apps/mcp/src/tools/update-skill.ts**
- Read the file first. This tool has two code paths: author update and non-author fork.
- Add optional `visibility` parameter to the tool's input schema:
  ```
  visibility: z.enum(["tenant", "personal"]).optional().describe("Skill visibility (optional, only applies when you are the author)")
  ```
- Update `handleUpdateSkill` function signature to accept `visibility?: string`.
- **Author path** (where `userId === skill.author_id`): In the two UPDATE SQL statements (lines ~143 and ~153), add `visibility = ${visibility}` to the SET clause when visibility is provided. If not provided, don't change existing visibility. Use conditional SQL:
  - When both `description` and `visibility` are provided, include both in SET.
  - When only `visibility` is provided (no description), add it to the second UPDATE branch.
  - Simplest approach: consolidate into one UPDATE that conditionally sets each field, or build the SET clause dynamically.
- **Fork path** (non-author): In the INSERT statement (line ~197), explicitly add `visibility` column with value `'personal'`. The fork is the user's private copy regardless of original visibility. Add `'personal'` after `'draft'` in the VALUES clause:
  ```sql
  INSERT INTO skills (id, tenant_id, name, slug, description, category, content, hours_saved, author_id, forked_from_id, forked_at_content_hash, status, visibility)
  VALUES (...existing values..., 'draft', 'personal')
  ```
- Update the tool registration call (line ~272) to pass visibility through:
  ```
  async ({ skillId, content, description, visibility }) => handleUpdateSkill({ skillId, content, description, visibility })
  ```

For all tools: Read `apps/mcp/src/auth.ts` to understand how userId is resolved (likely from EVERYSKILL_API_KEY -> user lookup). Thread it through each handler that calls a DB service.
  </action>
  <verify>
Run: `cd /home/dev/projects/relay/apps/mcp && npx tsc --noEmit` (or the equivalent typecheck command)
Expected: No type errors.
Also: `cd /home/dev/projects/relay && pnpm build`
Expected: Full monorepo build succeeds.
  </verify>
  <done>
All MCP tools (search, recommend, list, describe, create, update_skill) respect visibility scoping. search/recommend/list only return visible skills. describe returns "not found" for invisible personal skills. create accepts optional visibility parameter. update_skill accepts optional visibility for author updates and forces visibility='personal' for forks.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds across the monorepo
2. MCP search tool: personal skills of other users are excluded from results
3. MCP list tool: uses DB-level filtering (no in-memory filter for status)
4. MCP describe tool: returns not-found for personal skills of other users
5. MCP create tool: accepts visibility parameter
6. MCP update_skill tool: author path can change visibility; fork path defaults to personal
7. DB services: searchSkillsByQuery, semanticSearchSkills, getForkCount, getTopForks all accept userId
</verification>

<success_criteria>
- All 6 MCP tools handle visibility correctly (search, recommend, list, describe, create, update_skill)
- DB service layer (search-skills, semantic-search, skill-forks) accepts userId and applies buildVisibilityFilter
- MCP list tool uses DB-level WHERE clause instead of in-memory filtering
- MCP update_skill author path supports optional visibility change in UPDATE SET clause
- MCP update_skill fork path explicitly sets visibility='personal' in INSERT
- Full monorepo build passes
- No breaking changes to existing MCP functionality (userId is optional everywhere, visibility is optional in update)
</success_criteria>

<output>
After completion, create `.planning/phases/40-visibility-scoping/40-04-SUMMARY.md`
</output>
