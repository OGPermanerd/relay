---
phase: 55-schema-foundation-data-sanitization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/skill-feedback.ts
  - packages/db/src/schema/token-measurements.ts
  - packages/db/src/schema/benchmark-runs.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/schema/skills.ts
  - packages/db/src/relations/index.ts
  - packages/db/src/migrations/0030_create_skill_feedback.sql
  - packages/db/src/migrations/0031_create_token_measurements.sql
  - packages/db/src/migrations/0032_create_benchmark_tables.sql
  - packages/db/src/migrations/0033_add_feedback_aggregates_to_skills.sql
autonomous: true

must_haves:
  truths:
    - "skill_feedback table exists in the database with proper columns, indexes, and RLS policy"
    - "token_measurements table exists in the database with proper columns, indexes, and RLS policy"
    - "benchmark_runs and benchmark_results tables exist with proper columns, indexes, cascade deletes, and RLS policies"
    - "skills table has total_feedback, positive_feedback_pct, avg_token_cost_microcents columns defaulting appropriately"
    - "All 4 new tables have tenant_id NOT NULL with tenant_isolation RLS policy"
    - "TypeScript types for all new tables are exported from @everyskill/db"
  artifacts:
    - path: "packages/db/src/schema/skill-feedback.ts"
      provides: "skill_feedback table definition"
      exports: ["skillFeedback", "SkillFeedback", "NewSkillFeedback"]
    - path: "packages/db/src/schema/token-measurements.ts"
      provides: "token_measurements table definition"
      exports: ["tokenMeasurements", "TokenMeasurement", "NewTokenMeasurement"]
    - path: "packages/db/src/schema/benchmark-runs.ts"
      provides: "benchmark_runs and benchmark_results table definitions"
      exports: ["benchmarkRuns", "BenchmarkRun", "NewBenchmarkRun", "benchmarkResults", "BenchmarkResult", "NewBenchmarkResult"]
    - path: "packages/db/src/migrations/0030_create_skill_feedback.sql"
      provides: "skill_feedback CREATE TABLE + indexes + RLS"
    - path: "packages/db/src/migrations/0031_create_token_measurements.sql"
      provides: "token_measurements CREATE TABLE + indexes + RLS"
    - path: "packages/db/src/migrations/0032_create_benchmark_tables.sql"
      provides: "benchmark_runs + benchmark_results CREATE TABLE + indexes + RLS"
    - path: "packages/db/src/migrations/0033_add_feedback_aggregates_to_skills.sql"
      provides: "ALTER TABLE skills ADD COLUMN for 3 aggregate columns"
  key_links:
    - from: "packages/db/src/schema/index.ts"
      to: "packages/db/src/schema/skill-feedback.ts"
      via: "barrel re-export"
      pattern: 'export \* from "./skill-feedback"'
    - from: "packages/db/src/relations/index.ts"
      to: "packages/db/src/schema/index.ts"
      via: "import for relation definitions"
      pattern: "skillFeedback.*tokenMeasurements.*benchmarkRuns.*benchmarkResults"
    - from: "packages/db/src/relations/index.ts"
      to: "skillsRelations"
      via: "many() additions for new tables"
      pattern: "feedback: many\\(skillFeedback\\)"
---

<objective>
Create all 4 new database tables (skill_feedback, token_measurements, benchmark_runs, benchmark_results), add denormalized aggregate columns to the skills table, write SQL migrations, update the schema barrel export, define Drizzle relations, run migrations, and verify TypeScript compilation.

Purpose: Foundation tables for v5.0 feedback, training, token measurement, and benchmarking features. Every subsequent phase depends on these tables existing.
Output: 3 new schema files, 4 SQL migrations, updated schema index, updated relations, all types exported.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-schema-foundation-data-sanitization/55-RESEARCH.md

# Key reference files (read these for exact patterns):
@packages/db/src/schema/ratings.ts
@packages/db/src/schema/skills.ts
@packages/db/src/schema/skill-versions.ts
@packages/db/src/schema/index.ts
@packages/db/src/relations/index.ts
@packages/db/src/migrations/0029_add_email_diagnostics.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema files for all 4 new tables + update skills aggregate columns + update barrel export</name>
  <files>
    packages/db/src/schema/skill-feedback.ts
    packages/db/src/schema/token-measurements.ts
    packages/db/src/schema/benchmark-runs.ts
    packages/db/src/schema/skills.ts
    packages/db/src/schema/index.ts
  </files>
  <action>
Create 3 new schema files following the exact pattern from `ratings.ts` and `skill-versions.ts`:

**1. `packages/db/src/schema/skill-feedback.ts`** — `skill_feedback` table:
- `id`: text PK with `$defaultFn(() => crypto.randomUUID())`
- `tenantId`: text NOT NULL FK to `tenants.id` (no cascade)
- `skillId`: text NOT NULL FK to `skills.id` with `onDelete: "cascade"`
- `skillVersionId`: text nullable FK to `skillVersions.id`
- `userId`: text nullable FK to `users.id` (nullable for anonymous MCP feedback)
- `usageEventId`: text nullable (NO FK — uuid/text type mismatch with usage_events)
- `feedbackType`: text NOT NULL — discriminator: "thumbs_up" | "thumbs_down" | "suggestion" | "training_example" | "bug_report"
- `sentiment`: integer nullable (-1, 0, 1)
- `comment`: text nullable
- `suggestedContent`: text nullable
- `suggestedDiff`: text nullable
- `exampleInput`: text nullable
- `exampleOutput`: text nullable
- `expectedOutput`: text nullable
- `qualityScore`: integer nullable (1-10)
- `status`: text NOT NULL default "pending"
- `reviewedBy`: text nullable FK to `users.id`
- `reviewedAt`: timestamp with timezone, nullable
- `reviewNotes`: text nullable
- `source`: text NOT NULL default "web"
- `createdAt`: timestamp with timezone, precision 3, NOT NULL, defaultNow()
- Indexes: skill_id, user_id, tenant_id, feedback_type, status
- RLS: `pgPolicy("tenant_isolation", { as: "restrictive", for: "all", using: sql\`tenant_id = current_setting('app.current_tenant_id', true)\`, withCheck: sql\`tenant_id = current_setting('app.current_tenant_id', true)\` })`
- Export `SkillFeedback` (inferSelect) and `NewSkillFeedback` (inferInsert)

**2. `packages/db/src/schema/token-measurements.ts`** — `token_measurements` table:
- `id`: text PK with crypto.randomUUID()
- `tenantId`: text NOT NULL FK to `tenants.id`
- `skillId`: text NOT NULL FK to `skills.id` with `onDelete: "cascade"`
- `usageEventId`: text nullable (NO FK — uuid/text mismatch)
- `userId`: text nullable FK to `users.id`
- `inputTokens`: integer nullable
- `outputTokens`: integer nullable
- `totalTokens`: integer nullable
- `modelName`: text NOT NULL
- `modelProvider`: text NOT NULL default "anthropic"
- `estimatedCostMicrocents`: integer nullable
- `latencyMs`: integer nullable
- `source`: text NOT NULL default "hook"
- `createdAt`: timestamp with timezone, precision 3, NOT NULL, defaultNow()
- Indexes: skill_id, model_name, tenant_id, created_at
- RLS: same tenant_isolation policy
- Export `TokenMeasurement` and `NewTokenMeasurement`

**3. `packages/db/src/schema/benchmark-runs.ts`** — Contains BOTH `benchmark_runs` AND `benchmark_results` tables (same file since results depend on runs):
- **benchmark_runs:**
  - `id`: text PK with crypto.randomUUID()
  - `tenantId`: text NOT NULL FK to `tenants.id`
  - `skillId`: text NOT NULL FK to `skills.id` with `onDelete: "cascade"`
  - `skillVersionId`: text nullable FK to `skillVersions.id`
  - `triggeredBy`: text NOT NULL FK to `users.id`
  - `status`: text NOT NULL default "pending"
  - `models`: text array NOT NULL (use `.array()`)
  - `bestModel`: text nullable
  - `bestQualityScore`: integer nullable
  - `cheapestModel`: text nullable
  - `cheapestCostMicrocents`: integer nullable
  - `startedAt`: timestamp with timezone, nullable
  - `completedAt`: timestamp with timezone, nullable
  - `createdAt`: timestamp with timezone, precision 3, NOT NULL, defaultNow()
  - Indexes: skill_id, tenant_id, status
  - RLS: tenant_isolation

- **benchmark_results:**
  - `id`: text PK with crypto.randomUUID()
  - `tenantId`: text NOT NULL FK to `tenants.id`
  - `benchmarkRunId`: text NOT NULL FK to `benchmarkRuns.id` with `onDelete: "cascade"`
  - `modelName`: text NOT NULL
  - `modelProvider`: text NOT NULL
  - `testCaseIndex`: integer NOT NULL
  - `inputUsed`: text nullable
  - `outputProduced`: text nullable
  - `expectedOutput`: text nullable
  - `inputTokens`: integer nullable
  - `outputTokens`: integer nullable
  - `totalTokens`: integer nullable
  - `latencyMs`: integer nullable
  - `estimatedCostMicrocents`: integer nullable
  - `qualityScore`: integer nullable (0-100)
  - `qualityNotes`: text nullable
  - `matchesExpected`: boolean nullable (import `boolean` from drizzle)
  - `errorMessage`: text nullable
  - `createdAt`: timestamp with timezone, precision 3, NOT NULL, defaultNow()
  - Indexes: benchmark_run_id, model_name, tenant_id
  - RLS: tenant_isolation
  - Export all 4 types: BenchmarkRun, NewBenchmarkRun, BenchmarkResult, NewBenchmarkResult

**4. Update `packages/db/src/schema/skills.ts`** — Add 3 denormalized aggregate columns after the existing `averageRating` column:
- `totalFeedback: integer("total_feedback").notNull().default(0)`
- `positiveFeedbackPct: integer("positive_feedback_pct")` (nullable, like averageRating)
- `avgTokenCostMicrocents: integer("avg_token_cost_microcents")` (nullable)

**5. Update `packages/db/src/schema/index.ts`** — Add 3 new barrel exports at the bottom:
```typescript
export * from "./skill-feedback";
export * from "./token-measurements";
export * from "./benchmark-runs";
```
  </action>
  <verify>Run `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json 2>&1 | head -30` to check TypeScript compiles (may have errors from relations not yet updated — that's OK, verify schema files parse correctly)</verify>
  <done>3 new schema files exist with all specified columns, types exported, skills.ts has 3 new aggregate columns, schema/index.ts re-exports all 3 new files</done>
</task>

<task type="auto">
  <name>Task 2: Write SQL migrations and run them</name>
  <files>
    packages/db/src/migrations/0030_create_skill_feedback.sql
    packages/db/src/migrations/0031_create_token_measurements.sql
    packages/db/src/migrations/0032_create_benchmark_tables.sql
    packages/db/src/migrations/0033_add_feedback_aggregates_to_skills.sql
  </files>
  <action>
Create 4 migration SQL files following the exact pattern from `0029_add_email_diagnostics.sql`. Every CREATE TABLE must include:
- `CREATE TABLE IF NOT EXISTS`
- All columns matching the Drizzle schema definitions from Task 1
- `TIMESTAMPTZ(3)` for precision-3 timestamps, `TIMESTAMPTZ` for non-precision
- `TEXT[]` for the `models` array column in benchmark_runs
- `CREATE INDEX IF NOT EXISTS` for each index
- `ALTER TABLE ... ENABLE ROW LEVEL SECURITY;`
- Idempotent RLS policy creation using `DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = '...' AND policyname = 'tenant_isolation') THEN CREATE POLICY ... END IF; END $$;`

**0030_create_skill_feedback.sql:**
- Header comment with date 2026-02-15
- CREATE TABLE with all columns from skill_feedback schema
- 5 indexes: skill_id, user_id, tenant_id, feedback_type, status
- RLS enable + tenant_isolation policy

**0031_create_token_measurements.sql:**
- CREATE TABLE with all columns from token_measurements schema
- 4 indexes: skill_id, model_name, tenant_id, created_at
- RLS enable + tenant_isolation policy

**0032_create_benchmark_tables.sql:**
- CREATE TABLE for benchmark_runs with all columns (including `models TEXT[] NOT NULL`)
- 3 indexes for benchmark_runs: skill_id, tenant_id, status
- RLS enable + tenant_isolation policy for benchmark_runs
- CREATE TABLE for benchmark_results with all columns (including `matches_expected BOOLEAN`)
- `benchmark_run_id TEXT NOT NULL REFERENCES benchmark_runs(id) ON DELETE CASCADE`
- 3 indexes for benchmark_results: benchmark_run_id, model_name, tenant_id
- RLS enable + tenant_isolation policy for benchmark_results

**0033_add_feedback_aggregates_to_skills.sql:**
- `ALTER TABLE skills ADD COLUMN IF NOT EXISTS total_feedback INTEGER NOT NULL DEFAULT 0;`
- `ALTER TABLE skills ADD COLUMN IF NOT EXISTS positive_feedback_pct INTEGER;`
- `ALTER TABLE skills ADD COLUMN IF NOT EXISTS avg_token_cost_microcents INTEGER;`

After creating all migration files, run migrations:
```bash
cd /home/dev/projects/relay && pnpm db:migrate
```

Verify all 4 migrations applied successfully. If any fail, diagnose and fix.
  </action>
  <verify>Run `cd /home/dev/projects/relay && pnpm db:migrate` — should report all 4 migrations applied (or already applied if re-run). Then verify tables exist: `cd /home/dev/projects/relay && node -e "const { db } = require('@everyskill/db'); db.execute('SELECT tablename FROM pg_tables WHERE schemaname = '\''public'\'' AND tablename IN ('\''skill_feedback'\'', '\''token_measurements'\'', '\''benchmark_runs'\'', '\''benchmark_results'\'')').then(r => { console.log(r.rows || r); process.exit(); })"` or use psql if available.</verify>
  <done>All 4 SQL migration files exist, migrations run successfully, all 4 new tables plus 3 new columns on skills table are present in the database</done>
</task>

<task type="auto">
  <name>Task 3: Define Drizzle relations for all new tables + update existing relations + verify TypeScript compilation</name>
  <files>
    packages/db/src/relations/index.ts
  </files>
  <action>
Update `packages/db/src/relations/index.ts` with the following changes:

**1. Add new imports** — In the import block from `"../schema"`, add: `skillFeedback`, `tokenMeasurements`, `benchmarkRuns`, `benchmarkResults`

**2. Update `skillsRelations`** — Add 3 new `many()` relations to the existing `skillsRelations` export:
```typescript
feedback: many(skillFeedback),
tokenMeasurements: many(tokenMeasurements),
benchmarkRuns: many(benchmarkRuns),
```

**3. Update `usersRelations`** — Add:
```typescript
skillFeedback: many(skillFeedback),
tokenMeasurements: many(tokenMeasurements),
benchmarkRuns: many(benchmarkRuns),
```

**4. Update `tenantsRelations`** — Add:
```typescript
skillFeedback: many(skillFeedback),
tokenMeasurements: many(tokenMeasurements),
benchmarkRuns: many(benchmarkRuns),
benchmarkResults: many(benchmarkResults),
```

**5. Add `skillFeedbackRelations`:**
```typescript
export const skillFeedbackRelations = relations(skillFeedback, ({ one }) => ({
  tenant: one(tenants, { fields: [skillFeedback.tenantId], references: [tenants.id] }),
  skill: one(skills, { fields: [skillFeedback.skillId], references: [skills.id] }),
  user: one(users, { fields: [skillFeedback.userId], references: [users.id] }),
  skillVersion: one(skillVersions, { fields: [skillFeedback.skillVersionId], references: [skillVersions.id] }),
  reviewer: one(users, { fields: [skillFeedback.reviewedBy], references: [users.id], relationName: "reviewedFeedback" }),
}));
```

**6. Add `tokenMeasurementsRelations`:**
```typescript
export const tokenMeasurementsRelations = relations(tokenMeasurements, ({ one }) => ({
  tenant: one(tenants, { fields: [tokenMeasurements.tenantId], references: [tenants.id] }),
  skill: one(skills, { fields: [tokenMeasurements.skillId], references: [skills.id] }),
  user: one(users, { fields: [tokenMeasurements.userId], references: [users.id] }),
}));
```

**7. Add `benchmarkRunsRelations`:**
```typescript
export const benchmarkRunsRelations = relations(benchmarkRuns, ({ one, many }) => ({
  tenant: one(tenants, { fields: [benchmarkRuns.tenantId], references: [tenants.id] }),
  skill: one(skills, { fields: [benchmarkRuns.skillId], references: [skills.id] }),
  skillVersion: one(skillVersions, { fields: [benchmarkRuns.skillVersionId], references: [skillVersions.id] }),
  triggeredByUser: one(users, { fields: [benchmarkRuns.triggeredBy], references: [users.id] }),
  results: many(benchmarkResults),
}));
```

**8. Add `benchmarkResultsRelations`:**
```typescript
export const benchmarkResultsRelations = relations(benchmarkResults, ({ one }) => ({
  tenant: one(tenants, { fields: [benchmarkResults.tenantId], references: [tenants.id] }),
  benchmarkRun: one(benchmarkRuns, { fields: [benchmarkResults.benchmarkRunId], references: [benchmarkRuns.id] }),
}));
```

**Important:** The `skillFeedback` has two FK refs to `users` (userId and reviewedBy). Use `relationName: "reviewedFeedback"` on the reviewer relation to disambiguate. Also update `usersRelations` to have both:
```typescript
skillFeedback: many(skillFeedback),
reviewedFeedback: many(skillFeedback, { relationName: "reviewedFeedback" }),
```

After making all relation changes, verify the full project compiles:
```bash
cd /home/dev/projects/relay && pnpm build --filter @everyskill/db
```
If no build script exists for the db package, run:
```bash
cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json
```
  </action>
  <verify>Run TypeScript compilation: `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json` — must complete with zero errors. Then run `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit 2>&1 | head -20` to verify the web app also compiles with the new schema types available.</verify>
  <done>All 4 new relation definitions exist, existing skillsRelations/usersRelations/tenantsRelations updated with many() refs, TypeScript compiles with zero errors across both packages/db and apps/web</done>
</task>

</tasks>

<verification>
1. All 4 new tables exist in the database: `skill_feedback`, `token_measurements`, `benchmark_runs`, `benchmark_results`
2. Each table has `tenant_id NOT NULL` with RLS policy named `tenant_isolation`
3. `skills` table has 3 new columns: `total_feedback`, `positive_feedback_pct`, `avg_token_cost_microcents`
4. All new types exported from `@everyskill/db`: SkillFeedback, NewSkillFeedback, TokenMeasurement, NewTokenMeasurement, BenchmarkRun, NewBenchmarkRun, BenchmarkResult, NewBenchmarkResult
5. TypeScript compiles cleanly (`npx tsc --noEmit`) across packages/db and apps/web
6. Drizzle relations properly defined — new tables have `one()` refs to parent tables, parent tables have `many()` refs to new tables
</verification>

<success_criteria>
- 4 SQL migrations applied successfully to database
- 3 new schema files + updated skills.ts + updated index.ts all valid TypeScript
- Relations file has 4 new relation definitions + 3 updated existing relations
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/55-schema-foundation-data-sanitization/55-01-SUMMARY.md`
</output>
