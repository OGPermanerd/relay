---
phase: 23-analytics-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/analytics-queries.ts
autonomous: true

must_haves:
  truths:
    - "SQL queries return org-wide overview stats (hours saved, active employees, skills deployed)"
    - "SQL queries return per-employee usage data with sorting support"
    - "SQL queries return top skills with usage counts and employee breakdown"
    - "Time range filtering works for all queries"
    - "Individual employee activity can be retrieved for drill-down"
    - "Individual skill usage trend over time can be retrieved for drill-down"
  artifacts:
    - path: "apps/web/lib/analytics-queries.ts"
      provides: "All analytics SQL query functions"
      exports: ["getOverviewStats", "getUsageTrend", "getEmployeeUsage", "getSkillUsage", "getExportData", "getEmployeeActivity", "getSkillTrend"]
  key_links:
    - from: "apps/web/lib/analytics-queries.ts"
      to: "@relay/db"
      via: "drizzle-orm sql template"
      pattern: "db\\.execute\\(sql"
---

<objective>
Create SQL analytics query functions for the org-wide analytics dashboard.

Purpose: Provide the data layer for all analytics views (overview stats, usage trends, employee table, skills leaderboard, drill-down details, and CSV export).
Output: `apps/web/lib/analytics-queries.ts` with typed query functions
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@apps/web/lib/my-leverage.ts (pattern: SQL queries with COALESCE fallback chain)
@apps/web/lib/usage-trends.ts (pattern: date_trunc for time-series)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create analytics-queries.ts with all query functions</name>
  <files>apps/web/lib/analytics-queries.ts</files>
  <action>
Create `apps/web/lib/analytics-queries.ts` with these functions:

1. **getOverviewStats(startDate: Date)** - Returns:
   - totalHoursSaved: SUM of hours using COALESCE(r.hours_saved_estimate, s.hours_saved, 1) fallback
   - activeEmployees: COUNT(DISTINCT user_id) from usage_events
   - skillsDeployed: COUNT(DISTINCT skill_id) from usage_events
   - deploymentsThisPeriod: COUNT(*) from usage_events
   - mostUsedSkill: Subquery for skill name with highest count
   - highestSaver: Subquery for user name with most hours saved

2. **getUsageTrend(startDate: Date, granularity: 'day' | 'week' | 'month')** - Returns:
   - Array of { date: string, hoursSaved: number }
   - Use date_trunc(granularity, created_at) for grouping
   - Fill missing date gaps with 0 values (reuse fillMissingDays pattern from usage-trends.ts)

3. **getEmployeeUsage(startDate: Date)** - Returns array of:
   - id, name, email, image (from users table)
   - skillsUsed: COUNT(DISTINCT skill_id)
   - usageFrequency: COUNT(*)
   - hoursSaved: SUM with COALESCE fallback
   - lastActive: MAX(created_at)
   - topSkill: Subquery for most-used skill name

4. **getSkillUsage(startDate: Date)** - Returns array of:
   - skillId, name, category, authorName (from skills + users)
   - usageCount: COUNT(*)
   - uniqueUsers: COUNT(DISTINCT user_id)
   - hoursSaved: usageCount * COALESCE(hours_saved, 1)
   - employeeBreakdown: Array of { userId, userName, usageCount }

5. **getExportData(startDate: Date)** - Returns full dataset for CSV:
   - Join usage_events with skills and users
   - Include all fields: date, employee name, email, skill name, category, action, hours saved

6. **getEmployeeActivity(userId: string, startDate: Date)** - Returns array of recent usage events for one employee:
   - date: string (ISO format)
   - skillName: string
   - skillId: string
   - action: string (the action_type from usage_events)
   - hoursSaved: number
   - Ordered by date descending
   - Used for employee detail modal drill-down

7. **getSkillTrend(skillId: string, startDate: Date, granularity: 'day' | 'week' | 'month')** - Returns time-series for one skill:
   - Array of { date: string, usageCount: number }
   - Use date_trunc(granularity, created_at) for grouping
   - Filter by skill_id
   - Fill missing date gaps with 0 values
   - Used for skill analytics modal drill-down

**Types:** Define interfaces for all return types at the top of the file.

**Date serialization:** Use `.toISOString()` for all Date fields returned to client.

**Pattern to follow:** See my-leverage.ts for the exact SQL template syntax and result parsing.
  </action>
  <verify>
    - `cd apps/web && npx tsc --noEmit` passes without errors
    - All functions are exported
  </verify>
  <done>
    - analytics-queries.ts exists with 7 query functions
    - All functions accept startDate parameter for time filtering
    - getEmployeeActivity returns usage events for drill-down
    - getSkillTrend returns time-series for skill modal chart
    - Types are defined for all return values
    - Date fields use toISOString() for serialization
  </done>
</task>

<task type="auto">
  <name>Task 2: Add granularity auto-selection helper</name>
  <files>apps/web/lib/analytics-queries.ts</files>
  <action>
Add a helper function to auto-select granularity based on time range:

```typescript
export function getGranularity(range: '7d' | '30d' | '90d' | '1y'): 'day' | 'week' | 'month' {
  switch (range) {
    case '7d':
    case '30d':
      return 'day';
    case '90d':
      return 'week';
    case '1y':
      return 'month';
  }
}

export function getStartDate(range: '7d' | '30d' | '90d' | '1y'): Date {
  const now = new Date();
  switch (range) {
    case '7d':
      return new Date(now.setDate(now.getDate() - 7));
    case '30d':
      return new Date(now.setDate(now.getDate() - 30));
    case '90d':
      return new Date(now.setDate(now.getDate() - 90));
    case '1y':
      return new Date(now.setFullYear(now.getFullYear() - 1));
  }
}
```

Also export a `TimeRange` type: `export type TimeRange = '7d' | '30d' | '90d' | '1y';`
  </action>
  <verify>
    - `cd apps/web && npx tsc --noEmit` passes
    - getGranularity and getStartDate are exported
  </verify>
  <done>
    - TimeRange type exported
    - getGranularity function converts range to appropriate granularity
    - getStartDate function calculates start date from range
  </done>
</task>

</tasks>

<verification>
- All query functions compile without TypeScript errors
- Functions follow existing patterns from my-leverage.ts
- Time range helpers are exported
- Drill-down queries (getEmployeeActivity, getSkillTrend) are present
</verification>

<success_criteria>
- apps/web/lib/analytics-queries.ts exists
- 7 main query functions + 2 helper functions exported
- getEmployeeActivity supports employee detail modal
- getSkillTrend supports skill analytics modal chart
- All return types defined as TypeScript interfaces
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-analytics-dashboard/23-01-SUMMARY.md`
</output>
