---
phase: 60-token-cost-measurement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/mcp/src/tools/deploy.ts
autonomous: true

must_haves:
  truths:
    - "PostToolUse hook reads transcript_path from stdin and parses last assistant message for model and token counts"
    - "Hook payload sent to /api/track includes model_name, input_tokens, output_tokens fields when transcript data is available"
    - "Hook degrades gracefully when transcript_path is missing, unreadable, or has no model data -- sends payload without token fields"
    - "Hook works on both Linux and macOS (no tac, no GNU-only commands)"
  artifacts:
    - path: "apps/mcp/src/tools/deploy.ts"
      provides: "Updated buildHookFrontmatter with transcript parsing for token capture"
      contains: "transcript_path"
  key_links:
    - from: "apps/mcp/src/tools/deploy.ts (hook shell)"
      to: "/api/track"
      via: "curl POST with model_name, input_tokens, output_tokens in payload"
      pattern: "model_name"
---

<objective>
Extend the PostToolUse hook frontmatter to parse transcript_path for token counts and model name.

Purpose: This captures TOKEN-01, TOKEN-03, TOKEN-04 at the source -- the hook that fires on every skill tool use inside Claude Code. The enriched payload flows to /api/track (extended in Plan 01).
Output: Updated buildHookFrontmatter() in deploy.ts that emits transcript-parsing shell code.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@apps/mcp/src/tools/deploy.ts
@.planning/phases/60-token-cost-measurement/60-RESEARCH.md (Pattern 1: Transcript-Based Token Capture, Pitfall 6: tac not on macOS)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transcript parsing to PostToolUse hook frontmatter</name>
  <files>apps/mcp/src/tools/deploy.ts</files>
  <action>
    Modify `buildHookFrontmatter()` in `apps/mcp/src/tools/deploy.ts` to enhance the shell command with transcript parsing.

    The current hook shell does:
    1. Read INPUT from stdin via `cat`
    2. Extract tool_name via jq
    3. Build a JSON payload with skill_id, tool_name, ts, hook_event
    4. HMAC sign and curl to /api/track

    Extend it to ALSO:
    1. Extract `transcript_path` from INPUT via jq: `TP=$(echo "$INPUT" | jq -r '.transcript_path // empty' 2>/dev/null || echo "");`
    2. Initialize defaults: `MODEL=""; IN_TOK=""; OUT_TOK="";`
    3. If transcript_path exists and is a readable file (`[ -n "$TP" ] && [ -f "$TP" ]`):
       - Use portable approach (NO `tac` -- not available on macOS):
         `LAST=$(tail -n 100 "$TP" | jq -c 'select(.message.model != null) | .message' 2>/dev/null | tail -1);`
       - If LAST is non-empty, extract:
         `MODEL=$(echo "$LAST" | jq -r '.model // empty' 2>/dev/null || echo "");`
         `IN_TOK=$(echo "$LAST" | jq -r '.usage.input_tokens // empty' 2>/dev/null || echo "");`
         `OUT_TOK=$(echo "$LAST" | jq -r '.usage.output_tokens // empty' 2>/dev/null || echo "");`
    4. Build the payload JSON conditionally:
       - Start with the existing fields: skill_id, tool_name, ts, hook_event
       - If MODEL is non-empty, add `"model_name":"$MODEL"` to the JSON
       - If IN_TOK is non-empty, add `"input_tokens":$IN_TOK` (number, not string)
       - If OUT_TOK is non-empty, add `"output_tokens":$OUT_TOK` (number, not string)
       - Use a simple approach: build a base JSON string, then conditionally append fields before the closing brace.

    Shell JSON building strategy (simple, avoids complex conditionals):
    ```
    PL="{\\"skill_id\\":\\"${skillId}\\",\\"tool_name\\":\\"$TN\\",\\"ts\\":\\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\",\\"hook_event\\":\\"PostToolUse\\"";
    if [ -n "$MODEL" ]; then PL="$PL,\\"model_name\\":\\"$MODEL\\""; fi;
    if [ -n "$IN_TOK" ]; then PL="$PL,\\"input_tokens\\":$IN_TOK"; fi;
    if [ -n "$OUT_TOK" ]; then PL="$PL,\\"output_tokens\\":$OUT_TOK"; fi;
    PL="$PL}";
    ```

    Keep `async: true` and `timeout: 30` unchanged. The hook is already async and fire-and-forget.

    IMPORTANT: All shell quoting must be correct for YAML frontmatter embedding. The existing pattern uses single-line `>-` folded scalar. Follow the exact same escaping pattern as the current hook lines. Test mentally that the resulting shell is valid bash.

    IMPORTANT: Keep the HMAC signing intact. The SIG line uses `$PL` so it will sign the full payload including any token fields.

    IMPORTANT: The existing retry logic (if RESP != 200, retry once after 5s) should remain unchanged.
  </action>
  <verify>
    Run `cd /home/dev/projects/relay && pnpm build` to verify TypeScript compiles.
    Manually inspect the generated frontmatter by adding a temporary console.log in a test: call `buildHookFrontmatter("test-id", "Test Skill", "productivity", 1)` and verify the output is valid YAML with correct shell syntax. Remove temp log after.
  </verify>
  <done>
    buildHookFrontmatter generates PostToolUse hook shell that: (1) reads transcript_path from stdin, (2) parses last assistant message for model/tokens, (3) includes model_name, input_tokens, output_tokens in the /api/track payload when available, (4) degrades gracefully when transcript is unavailable. Works on Linux and macOS (no tac).
  </done>
</task>

</tasks>

<verification>
- `pnpm build` passes
- Generated frontmatter is valid YAML (no syntax errors)
- Shell commands use only portable tools (jq, tail, curl, bash, date, openssl)
- Token fields are optional in the payload -- old /api/track endpoints that don't understand them will ignore them via Zod passthrough or optional schema
</verification>

<success_criteria>
TOKEN-01: Token counts captured from transcript via PostToolUse hook
TOKEN-03: Model name captured from transcript
TOKEN-04 (partial): Latency not in transcript -- hook captures what's available (tokens + model)
</success_criteria>

<output>
After completion, create `.planning/phases/60-token-cost-measurement/60-02-SUMMARY.md`
</output>
