---
phase: 60-token-cost-measurement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/pricing-table.ts
  - packages/db/src/services/token-measurements.ts
  - packages/db/src/services/index.ts
  - apps/web/app/api/track/route.ts
autonomous: true

must_haves:
  truths:
    - "/api/track accepts optional model_name, input_tokens, output_tokens, latency_ms fields without breaking existing payloads"
    - "When token data is present in /api/track payload, a token_measurements row is inserted with calculated cost"
    - "Cost is calculated server-side using static Anthropic pricing table in microcents"
    - "skills.avgTokenCostMicrocents is updated after each token measurement insert"
  artifacts:
    - path: "apps/web/lib/pricing-table.ts"
      provides: "Static Anthropic pricing lookup and estimateCostMicrocents function"
      exports: ["ANTHROPIC_PRICING", "estimateCostMicrocents", "formatCostMicrocents"]
    - path: "packages/db/src/services/token-measurements.ts"
      provides: "insertTokenMeasurement and getSkillCostStats DB service"
      exports: ["insertTokenMeasurement", "getSkillCostStats", "SkillCostStats"]
    - path: "apps/web/app/api/track/route.ts"
      provides: "Extended tracking endpoint with optional token fields"
      contains: "model_name"
  key_links:
    - from: "apps/web/app/api/track/route.ts"
      to: "packages/db/src/services/token-measurements.ts"
      via: "insertTokenMeasurement call when model_name present"
      pattern: "insertTokenMeasurement"
    - from: "packages/db/src/services/token-measurements.ts"
      to: "apps/web/lib/pricing-table.ts"
      via: "estimateCostMicrocents for cost calculation"
      pattern: "estimateCostMicrocents"
---

<objective>
Create the pricing table, token measurement DB service, and extend /api/track to accept and store token data.

Purpose: This is the backend foundation for TOKEN-01 through TOKEN-05. When hooks send token data, the server calculates cost and persists measurements.
Output: Working /api/track extension that stores token measurements with cost estimation.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@packages/db/src/schema/token-measurements.ts
@packages/db/src/services/usage-tracking.ts
@apps/web/app/api/track/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pricing table and token measurement DB service</name>
  <files>
    apps/web/lib/pricing-table.ts
    packages/db/src/services/token-measurements.ts
    packages/db/src/services/index.ts
  </files>
  <action>
    1. Create `apps/web/lib/pricing-table.ts`:
       - Export `ANTHROPIC_PRICING` record mapping model API IDs to `{ input: number; output: number }` in microcents/token.
       - Include current models: claude-opus-4-6 (0.5/2.5), claude-sonnet-4-5-20250929 + alias (0.3/1.5), claude-haiku-4-5-20251001 + alias (0.1/0.5).
       - Include legacy models: claude-opus-4-5-20251101, claude-opus-4-1-20250805, claude-sonnet-4-20250514, claude-3-7-sonnet-20250219, claude-opus-4-20250514, claude-3-5-sonnet-20241022, claude-3-haiku-20240307, plus their short aliases.
       - Formula comment: `$/MTok / 10 = microcents/token`.
       - Export `estimateCostMicrocents(modelName: string, inputTokens: number, outputTokens: number): number | null` -- returns null if model not in table.
       - Export `formatCostMicrocents(microcents: number): string` -- converts to dollar string ($0.0012, $0.45, etc.). Return "$0.00" for zero.

    2. Create `packages/db/src/services/token-measurements.ts`:
       - Import `db` from `../client`, `tokenMeasurements` from schema, `skills` from schema, `eq`, `sql` from drizzle-orm.
       - Import `estimateCostMicrocents` from a local copy of the pricing logic (NOT from apps/web -- packages/db cannot import from apps/web). Inline the pricing table in this file OR create a shared constant. Simplest: import from a `pricing.ts` file co-located in services/.
         Actually, the cleanest approach: put the pricing table and estimateCostMicrocents in `packages/db/src/services/pricing.ts` (since it's pure logic, no Next.js deps), and re-export from `apps/web/lib/pricing-table.ts` for the formatCostMicrocents display helper. This avoids cross-package import issues.
         So: Create `packages/db/src/services/pricing.ts` with ANTHROPIC_PRICING and estimateCostMicrocents.
         Then `apps/web/lib/pricing-table.ts` re-exports from `@everyskill/db/services/pricing` and adds formatCostMicrocents.
       - Export `insertTokenMeasurement(input)` -- fire-and-forget (catches errors, never throws). Input: `{ tenantId, skillId, userId, usageEventId?, modelName, inputTokens, outputTokens, latencyMs? }`. Calculates totalTokens and estimatedCostMicrocents, inserts into token_measurements. Then updates `skills.avgTokenCostMicrocents` with a subquery avg.
       - Export `getSkillCostStats(skillId: string): Promise<SkillCostStats>` interface with totalCostMicrocents, avgCostPerUseMicrocents, measurementCount, predominantModel. Uses SQL aggregation with COALESCE defaults.
       - Export the `SkillCostStats` type.

    3. Update `packages/db/src/services/index.ts`:
       - Add exports for `insertTokenMeasurement`, `getSkillCostStats`, `SkillCostStats` from `./token-measurements`.
       - Add exports for `estimateCostMicrocents`, `ANTHROPIC_PRICING` from `./pricing`.

    NOTE: Create `packages/db/src/services/pricing.ts` as the canonical location for the pricing table (pure TypeScript, no framework deps).
  </action>
  <verify>
    Run `cd /home/dev/projects/relay && pnpm build` to verify no TypeScript errors. Check that `packages/db` builds cleanly and exports are accessible.
  </verify>
  <done>
    pricing.ts exports ANTHROPIC_PRICING and estimateCostMicrocents. token-measurements.ts exports insertTokenMeasurement, getSkillCostStats, SkillCostStats. Both are re-exported from services/index.ts. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend /api/track to accept token data and insert measurements</name>
  <files>apps/web/app/api/track/route.ts</files>
  <action>
    Modify `apps/web/app/api/track/route.ts`:

    1. Add optional fields to `trackingPayloadSchema`:
       - `model_name: z.string().max(100).optional()`
       - `input_tokens: z.number().int().min(0).optional()`
       - `output_tokens: z.number().int().min(0).optional()`
       - `latency_ms: z.number().int().min(0).optional()`

    2. After the existing `insertTrackingEvent` call (step 7), add a new step 7b:
       - If `parsed.data.model_name` is present AND at least one of input_tokens/output_tokens is present:
         - Import `insertTokenMeasurement` from `@everyskill/db/services`
         - Call `insertTokenMeasurement({ tenantId: keyResult.tenantId, userId: keyResult.userId, skillId: parsed.data.skill_id, modelName: parsed.data.model_name, inputTokens: parsed.data.input_tokens ?? 0, outputTokens: parsed.data.output_tokens ?? 0, latencyMs: parsed.data.latency_ms })`.
         - This is fire-and-forget (insertTokenMeasurement handles its own errors).
         - Do NOT await it -- use void promise to avoid blocking the response.

    3. The existing response (step 8, return 200) stays unchanged. Backward compatibility is preserved because all new fields are optional.
  </action>
  <verify>
    Run `cd /home/dev/projects/relay && pnpm build` to verify no TypeScript errors.
    Test backward compatibility: `curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:2002/api/track -H "Content-Type: application/json" -H "Authorization: Bearer test" -d '{"skill_id":"test","tool_name":"test","ts":"2026-01-01T00:00:00Z"}'` should still return 401 (invalid key) or 200 (valid key), not 400.
  </verify>
  <done>
    /api/track accepts optional model_name, input_tokens, output_tokens, latency_ms. When model_name is present, a token_measurements row is inserted with server-calculated cost. Existing payloads without token fields continue to work unchanged.
  </done>
</task>

</tasks>

<verification>
- `pnpm build` passes with no errors
- trackingPayloadSchema accepts payloads with and without token fields
- estimateCostMicrocents returns correct values (e.g., 1000 input tokens on claude-sonnet-4-5 = 1000 * 0.3 = 300 microcents)
- insertTokenMeasurement is fire-and-forget safe
</verification>

<success_criteria>
TOKEN-01 (partial): Server-side storage ready for token counts
TOKEN-02: Cost estimation via static pricing table
TOKEN-03 (partial): Server accepts model_name
TOKEN-04 (partial): Server accepts latency_ms
TOKEN-05: /api/track backward-compatible extension with optional token fields
</success_criteria>

<output>
After completion, create `.planning/phases/60-token-cost-measurement/60-01-SUMMARY.md`
</output>
