---
phase: 28-hook-based-usage-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/services/api-keys.ts
  - apps/mcp/src/auth.ts
  - apps/web/app/api/auth/validate-key/route.ts
  - apps/web/app/api/install-callback/route.ts
autonomous: true

must_haves:
  truths:
    - "validateApiKey returns tenantId alongside userId and keyId"
    - "Expired keys are NOT rejected -- soft expiry returns isExpired flag"
    - "All 3 callers compile and work with the new return type"
  artifacts:
    - path: "packages/db/src/services/api-keys.ts"
      provides: "validateApiKey with tenantId + isExpired"
      exports: ["validateApiKey"]
    - path: "apps/mcp/src/auth.ts"
      provides: "Updated caller destructuring"
    - path: "apps/web/app/api/auth/validate-key/route.ts"
      provides: "Returns tenantId in response"
    - path: "apps/web/app/api/install-callback/route.ts"
      provides: "Updated caller destructuring"
  key_links:
    - from: "packages/db/src/services/api-keys.ts"
      to: "api_keys table"
      via: "db.query.apiKeys.findFirst"
      pattern: "tenantId.*expiresAt"
---

<objective>
Modify validateApiKey() to return tenantId and isExpired flag (soft expiry), then update all 3 callers.

Purpose: TENANT-11 requires API key validation to return tenantId. SOC2-05 requires soft expiry (expired keys keep working but are flagged). This is a breaking change to the function signature that must update all callers atomically.
Output: Updated validateApiKey + 3 updated callers that compile and work correctly.
</objective>

<execution_context>
@/home/dev/.claude/agents/gsd-planner.md
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify validateApiKey to return tenantId + soft expiry</name>
  <files>packages/db/src/services/api-keys.ts</files>
  <action>
Modify `validateApiKey()` return type from `{ userId: string; keyId: string } | null` to `{ userId: string; keyId: string; tenantId: string; isExpired: boolean } | null`.

Changes:
1. Update the return type in the function signature and JSDoc.
2. In the db query `columns`, add `tenantId: true` and `expiresAt: true`.
3. In the WHERE clause, REMOVE the `or(isNull(apiKeys.expiresAt), gt(apiKeys.expiresAt, now))` condition. Keep only `eq(apiKeys.keyHash, keyHash)` and `isNull(apiKeys.revokedAt)`. This implements soft expiry -- expired keys are NOT rejected.
4. In the return statement, add `tenantId: result.tenantId` and `isExpired: result.expiresAt ? result.expiresAt <= now : false`.
5. Remove the `gt` import from drizzle-orm if no longer used (it was only used for the expiresAt check).

The key behavioral change: previously expired keys returned null (hard rejection). Now they return a result with `isExpired: true` (soft expiry per user decision).
  </action>
  <verify>Run `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json` -- should compile without errors in api-keys.ts</verify>
  <done>validateApiKey returns {userId, keyId, tenantId, isExpired} on valid key, null only on revoked/invalid keys. Expired keys return isExpired: true instead of null.</done>
</task>

<task type="auto">
  <name>Task 2: Update all 3 callers of validateApiKey</name>
  <files>
    apps/mcp/src/auth.ts
    apps/web/app/api/auth/validate-key/route.ts
    apps/web/app/api/install-callback/route.ts
  </files>
  <action>
Update each caller to handle the new return type:

**apps/mcp/src/auth.ts** (line 32):
- `result.userId` still works. No destructuring change needed since it accesses `.userId` directly on the result object.
- BUT the console.error on line 37 says "invalid or expired" -- update message to "invalid or revoked" since expired keys now succeed.

**apps/web/app/api/auth/validate-key/route.ts** (line 25-31):
- Add `tenantId` and `isExpired` to the response JSON: `return NextResponse.json({ userId: result.userId, keyId: result.keyId, tenantId: result.tenantId, isExpired: result.isExpired }, { status: 200 })`
- Update the error message on line 29 from "Invalid or expired key" to "Invalid or revoked key" since expired keys now succeed.

**apps/web/app/api/install-callback/route.ts** (line 42-43):
- Currently destructures `result?.userId`. This still works since userId is still in the return type.
- Also extract tenantId: `const result = await validateApiKey(key); userId = result?.userId ?? null;` -- also set a local `resolvedTenantId` from `result?.tenantId ?? DEFAULT_TENANT_ID` and use it in the insert instead of hardcoded DEFAULT_TENANT_ID.
  </action>
  <verify>Run `cd /home/dev/projects/relay && pnpm build` -- the full build must succeed (checks both apps/web and apps/mcp compilation)</verify>
  <done>All 3 callers compile and correctly handle the new return type. validate-key endpoint returns tenantId. install-callback uses resolved tenantId. MCP auth handles soft expiry messaging.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds across the entire monorepo
- `validateApiKey` function signature includes tenantId and isExpired in return type
- No remaining references to "expired" in error messages for key validation (now "revoked")
</verification>

<success_criteria>
- validateApiKey returns {userId, keyId, tenantId, isExpired} for valid (including expired) keys
- validateApiKey returns null only for revoked or non-existent keys
- All 3 callers compile and handle the new return type
- validate-key endpoint response includes tenantId and isExpired fields
</success_criteria>

<output>
After completion, create `.planning/phases/28-hook-based-usage-tracking/28-01-SUMMARY.md`
</output>
