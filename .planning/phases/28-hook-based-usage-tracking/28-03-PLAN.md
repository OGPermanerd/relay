---
phase: 28-hook-based-usage-tracking
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/services/usage-tracking.ts
autonomous: true

must_haves:
  truths:
    - "insertTrackingEvent writes a usage event with tenantId, userId, skillId, toolName"
    - "Skill name is resolved from skillId and stored in metadata"
    - "Server timestamp is added to metadata"
    - "Errors are caught and logged, never thrown"
  artifacts:
    - path: "packages/db/src/services/usage-tracking.ts"
      provides: "Tracking event insertion with enrichment"
      exports: ["insertTrackingEvent"]
  key_links:
    - from: "packages/db/src/services/usage-tracking.ts"
      to: "usage_events table"
      via: "db.insert(usageEvents)"
      pattern: "insert.*usageEvents"
---

<objective>
Create a usage tracking service that inserts enriched usage events from hook callbacks.

Purpose: TRACK-01 requires the tracking endpoint to insert usage events. This service handles validation, enrichment (resolve skill name from ID, add server timestamp), and fire-and-forget insertion.
Output: New service module ready to be called by the /api/track endpoint.
</objective>

<execution_context>
@/home/dev/.claude/agents/gsd-planner.md
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usage-tracking service</name>
  <files>packages/db/src/services/usage-tracking.ts</files>
  <action>
Create `packages/db/src/services/usage-tracking.ts`.

Interface:
```typescript
interface TrackingEventInput {
  tenantId: string;
  userId: string;
  skillId: string;
  toolName: string;
  clientTimestamp?: string; // ISO string from hook
  hookEvent?: string;      // e.g., "PostToolUse"
  metadata?: Record<string, unknown>;
}
```

Function `insertTrackingEvent(input: TrackingEventInput): Promise<void>`:
1. Early return if `!db`.
2. Resolve skill name: `db.query.skills.findFirst({ columns: { name: true }, where: eq(skills.id, input.skillId) })`. If not found, skillName = undefined (don't fail).
3. Insert into usageEvents:
   - `tenantId: input.tenantId`
   - `toolName: input.toolName`
   - `skillId: input.skillId`
   - `userId: input.userId`
   - `metadata: { ...input.metadata, skillName, clientTimestamp: input.clientTimestamp, hookEvent: input.hookEvent, source: "hook", serverTimestamp: new Date().toISOString() }`
4. Wrap entire body in try/catch. On error: `console.error("Failed to insert tracking event:", error)`. Never throw.

Imports:
- `db` from "../client"
- `usageEvents` from "../schema"
- `skills` from "../schema"
- `eq` from "drizzle-orm"

Export `insertTrackingEvent` and the `TrackingEventInput` type.
  </action>
  <verify>Run `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json` -- should compile</verify>
  <done>usage-tracking.ts exports insertTrackingEvent that enriches and inserts usage events with fire-and-forget error handling.</done>
</task>

</tasks>

<verification>
- File compiles without TypeScript errors
- Function catches all errors (never throws)
- Metadata includes source: "hook" and serverTimestamp
</verification>

<success_criteria>
- insertTrackingEvent accepts tenantId, userId, skillId, toolName and inserts enriched usage event
- Skill name resolution failure does not prevent event insertion
- All errors caught and logged, never propagated
</success_criteria>

<output>
After completion, create `.planning/phases/28-hook-based-usage-tracking/28-03-SUMMARY.md`
</output>
