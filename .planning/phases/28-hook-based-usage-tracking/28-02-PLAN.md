---
phase: 28-hook-based-usage-tracking
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/rate-limiter.ts
  - apps/web/lib/hmac.ts
autonomous: true

must_haves:
  truths:
    - "Rate limiter allows up to 100 requests per minute per key ID"
    - "Rate limiter rejects request 101 within the same minute window"
    - "HMAC verification confirms payload integrity using timing-safe comparison"
    - "HMAC rejects tampered payloads"
  artifacts:
    - path: "apps/web/lib/rate-limiter.ts"
      provides: "In-memory sliding window rate limiter"
      exports: ["checkRateLimit"]
    - path: "apps/web/lib/hmac.ts"
      provides: "HMAC-SHA256 signing and verification"
      exports: ["computeHmac", "verifyHmac"]
  key_links: []
---

<objective>
Create rate limiter and HMAC utility modules for the tracking endpoint.

Purpose: TRACK-06 requires 100 req/min rate limiting per API key. TRACK-07 requires HMAC payload signing to prevent spoofed callbacks. These are standalone utility modules with no external dependencies.
Output: Two new utility files ready to be imported by the /api/track endpoint.
</objective>

<execution_context>
@/home/dev/.claude/agents/gsd-planner.md
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create in-memory rate limiter</name>
  <files>apps/web/lib/rate-limiter.ts</files>
  <action>
Create `apps/web/lib/rate-limiter.ts` with a sliding window rate limiter using an in-memory Map.

Implementation:
- Constants: `WINDOW_MS = 60_000` (1 minute), `MAX_REQUESTS = 100`
- Store: `Map<string, number[]>` mapping keyId to array of timestamps
- `checkRateLimit(keyId: string): boolean` -- filters timestamps to current window, returns false if >= MAX_REQUESTS, otherwise pushes current timestamp and returns true
- Cleanup: `setInterval` every 5 minutes to prune entries older than 2x window. Delete entries with zero remaining timestamps.
- Export only `checkRateLimit`.

This is sufficient for single-server deployment (one LXC container). No Redis needed.
  </action>
  <verify>Run `cd /home/dev/projects/relay && npx tsc --noEmit -p apps/web/tsconfig.json 2>&1 | grep rate-limiter` -- should show no errors for this file</verify>
  <done>rate-limiter.ts exports checkRateLimit function that enforces 100 req/min per key ID using sliding window.</done>
</task>

<task type="auto">
  <name>Task 2: Create HMAC signing and verification utilities</name>
  <files>apps/web/lib/hmac.ts</files>
  <action>
Create `apps/web/lib/hmac.ts` using Node.js built-in crypto module.

Implementation:
- `computeHmac(payload: string, secret: string): string` -- uses `crypto.createHmac("sha256", secret).update(payload).digest("hex")`
- `verifyHmac(payload: string, signature: string, secret: string): boolean` -- computes expected HMAC, then uses `crypto.timingSafeEqual` for constant-time comparison. Handle length mismatch (return false if signature and expected have different byte lengths).
- Import `createHmac` and `timingSafeEqual` from "crypto".
- Export both `computeHmac` and `verifyHmac`.

Key: Use `Buffer.from(sig, "hex")` for both buffers before timingSafeEqual to prevent timing attacks on string comparison.
  </action>
  <verify>Run `cd /home/dev/projects/relay && npx tsc --noEmit -p apps/web/tsconfig.json 2>&1 | grep hmac` -- should show no errors for this file</verify>
  <done>hmac.ts exports computeHmac and verifyHmac with timing-safe comparison using Node crypto.</done>
</task>

</tasks>

<verification>
- Both files compile without TypeScript errors
- rate-limiter uses Map-based sliding window (not Redis)
- hmac uses crypto.timingSafeEqual (not string comparison)
</verification>

<success_criteria>
- checkRateLimit correctly allows 100 requests and rejects the 101st within a minute
- verifyHmac correctly validates matching signatures and rejects mismatches
- No external dependencies added (Node.js crypto only)
</success_criteria>

<output>
After completion, create `.planning/phases/28-hook-based-usage-tracking/28-02-SUMMARY.md`
</output>
