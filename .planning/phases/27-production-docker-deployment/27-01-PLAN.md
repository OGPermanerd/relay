---
phase: 27-production-docker-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/next.config.ts
  - apps/web/app/api/health/route.ts
  - apps/web/middleware.ts
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "next.config.ts produces standalone output for Docker deployment"
    - "GET /api/health returns 200 with {status: healthy} when DB is connected"
    - "/api/health is exempt from auth middleware"
    - ".dockerignore prevents secrets and node_modules from entering Docker build context"
  artifacts:
    - path: "apps/web/next.config.ts"
      provides: "Standalone output + outputFileTracingRoot for monorepo"
      contains: "output.*standalone"
    - path: "apps/web/app/api/health/route.ts"
      provides: "Health check endpoint for Docker"
      exports: ["GET"]
    - path: ".dockerignore"
      provides: "Build context exclusions"
      contains: "node_modules"
  key_links:
    - from: "apps/web/next.config.ts"
      to: "outputFileTracingRoot"
      via: "path.join(__dirname, ../../) points to monorepo root"
      pattern: "outputFileTracingRoot"
    - from: "apps/web/middleware.ts"
      to: "/api/health"
      via: "exempt path check"
      pattern: "api/health"
---

<objective>
Prepare the Next.js app for Docker deployment by enabling standalone output, adding a health check endpoint, and creating .dockerignore.

Purpose: These are prerequisites that the Dockerfile and docker-compose health checks depend on. Without standalone output, the Docker image would be ~1GB instead of ~150MB. Without /api/health, Docker cannot verify the web service is ready. Without .dockerignore, secrets could leak into image layers.

Output: Modified next.config.ts, new /api/health route, updated middleware, new .dockerignore
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable standalone output and add health endpoint</name>
  <files>
    apps/web/next.config.ts
    apps/web/app/api/health/route.ts
    apps/web/middleware.ts
  </files>
  <action>
1. Update `apps/web/next.config.ts` to enable standalone output for Docker:
```typescript
import path from "path";
import { fileURLToPath } from "url";
import type { NextConfig } from "next";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const nextConfig: NextConfig = {
  output: "standalone",
  outputFileTracingRoot: path.join(__dirname, "../../"),
  transpilePackages: ["@everyskill/ui", "@everyskill/core", "@everyskill/db"],
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "lh3.googleusercontent.com",
      },
    ],
  },
};

export default nextConfig;
```

Key points:
- `output: "standalone"` creates a self-contained build (~150MB vs ~1GB)
- `outputFileTracingRoot: path.join(__dirname, "../../")` tells Next.js to trace from the monorepo root so @everyskill/* packages are included. Without this, standalone build crashes with "Cannot find module" errors.

2. Create `apps/web/app/api/health/route.ts`:
```typescript
import { NextResponse } from "next/server";
import { isDatabaseConfigured } from "@everyskill/db";

export const dynamic = "force-dynamic";

export async function GET() {
  const dbOk = isDatabaseConfigured();
  if (!dbOk) {
    return NextResponse.json({ status: "unhealthy", db: false }, { status: 503 });
  }
  return NextResponse.json({ status: "healthy", db: true });
}
```

3. Update `apps/web/middleware.ts` -- add `/api/health` to the exempt paths block. Add this line after the `pathname === "/api/validate-key"` check:
```
    pathname === "/api/health"
```
So the block becomes:
```typescript
  if (
    pathname.startsWith("/api/auth") ||
    pathname === "/api/dev-login" ||
    pathname.startsWith("/api/install-callback") ||
    pathname.startsWith("/api/mcp") ||
    pathname === "/api/validate-key" ||
    pathname === "/api/health"
  ) {
    return NextResponse.next();
  }
```
  </action>
  <verify>
Run `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit --pretty 2>&1 | head -30` to verify no type errors in the modified files. Then run `cd /home/dev/projects/relay && pnpm turbo build --filter=web 2>&1 | tail -20` to verify standalone build succeeds and check output mentions "standalone".
  </verify>
  <done>
next.config.ts has output:"standalone" and outputFileTracingRoot. /api/health endpoint exists and returns JSON health status. Middleware exempts /api/health from auth. Build succeeds with standalone output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create .dockerignore</name>
  <files>.dockerignore</files>
  <action>
Create `.dockerignore` at the REPO ROOT (not in docker/). This file controls what enters the Docker build context when the Dockerfile uses `COPY . .`.

```
node_modules
.next
.turbo
dist
.env
.env.*
.env.local
.git
.gitignore
.planning
playwright-report
test-results
coverage
docker
.vscode
.idea
*.tsbuildinfo
```

NOTE: Do NOT exclude *.md files globally -- turbo.json and pnpm-workspace.yaml are not markdown but some workspace tooling files could be needed. The key exclusions are: node_modules (huge, reinstalled in Docker), .env* (secrets), .git (huge), .planning (private), test artifacts.
  </action>
  <verify>
Verify the file exists: `ls -la /home/dev/projects/relay/.dockerignore`. Verify it contains critical exclusions: `grep -E "node_modules|\.env|\.git" /home/dev/projects/relay/.dockerignore`.
  </verify>
  <done>
.dockerignore exists at repo root with exclusions for node_modules, .env files, .git, .planning, and test artifacts. No secrets or unnecessary large directories will enter Docker build context.
  </done>
</task>

</tasks>

<verification>
- `apps/web/next.config.ts` contains `output: "standalone"` and `outputFileTracingRoot`
- `apps/web/app/api/health/route.ts` exists and exports GET handler
- `apps/web/middleware.ts` exempts `/api/health`
- `.dockerignore` exists at repo root with proper exclusions
- `pnpm turbo build --filter=web` succeeds
</verification>

<success_criteria>
Next.js builds in standalone mode. Health endpoint is accessible without auth. Docker build context will exclude secrets and large directories.
</success_criteria>

<output>
After completion, create `.planning/phases/27-production-docker-deployment/27-01-SUMMARY.md`
</output>
