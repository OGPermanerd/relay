---
phase: 27-production-docker-deployment
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - docker/backup.sh
  - docker/restore.sh
  - docker/LUKS-RUNBOOK.md
autonomous: true

must_haves:
  truths:
    - "backup.sh performs pg_dump | gzip | gpg pipeline with no unencrypted temp files"
    - "backup.sh transfers encrypted backup to off-site storage via rsync"
    - "backup.sh cleans up local backups older than 90 days"
    - "restore.sh can decrypt and restore a backup"
    - "LUKS runbook documents the encryption procedure for Hetzner VPS"
  artifacts:
    - path: "docker/backup.sh"
      provides: "Automated encrypted backup pipeline"
      contains: "pg_dump"
    - path: "docker/restore.sh"
      provides: "Backup restoration script"
      contains: "gpg.*decrypt"
    - path: "docker/LUKS-RUNBOOK.md"
      provides: "LUKS encryption setup documentation"
      contains: "cryptsetup"
  key_links:
    - from: "docker/backup.sh"
      to: "everyskill-postgres"
      via: "docker exec pg_dump"
      pattern: "docker exec.*pg_dump"
---

<objective>
Create the backup/restore scripts and LUKS encryption runbook for SOC2 compliance.

Purpose: SOC2-06 requires encrypted backups with off-site storage and 90-day retention. SOC2-03 requires encryption at rest via LUKS. The backup script automates pg_dump -> gzip -> gpg -> rsync. The LUKS runbook documents the one-time manual server setup (can't be automated -- requires Hetzner Rescue Mode).

Output: docker/backup.sh, docker/restore.sh, docker/LUKS-RUNBOOK.md
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backup, restore scripts and LUKS runbook</name>
  <files>
    docker/backup.sh
    docker/restore.sh
    docker/LUKS-RUNBOOK.md
  </files>
  <action>
1. Create `docker/backup.sh`:

```bash
#!/bin/bash
# Automated PostgreSQL backup with encryption and off-site storage
# Usage: ./backup.sh [--full]
# Schedule via cron:
#   0 * * * * /opt/everyskill/backup.sh >> /var/log/everyskill-backup.log 2>&1
#   0 2 * * * /opt/everyskill/backup.sh --full >> /var/log/everyskill-backup.log 2>&1

set -euo pipefail

# Configuration (override via environment)
BACKUP_DIR="${BACKUP_DIR:-/backups}"
CONTAINER_NAME="${CONTAINER_NAME:-everyskill-postgres}"
DB_USER="${DB_USER:-everyskill}"
DB_NAME="${DB_NAME:-everyskill}"
RETENTION_DAYS="${RETENTION_DAYS:-90}"
PASSPHRASE_FILE="${PASSPHRASE_FILE:-/etc/everyskill/backup-passphrase}"
STORAGEBOX_USER="${STORAGEBOX_USER:-}"
STORAGEBOX_HOST="${STORAGEBOX_HOST:-}"
STORAGEBOX_PORT="${STORAGEBOX_PORT:-23}"

# Derived
DATE=$(date +%Y%m%d_%H%M%S)
TYPE="snapshot"
if [[ "${1:-}" == "--full" ]]; then
  TYPE="full"
fi
BACKUP_FILE="everyskill_${TYPE}_${DATE}.sql.gz.gpg"

# Validate
if [[ ! -f "$PASSPHRASE_FILE" ]]; then
  echo "[ERROR] Passphrase file not found: $PASSPHRASE_FILE"
  exit 1
fi
mkdir -p "$BACKUP_DIR"

echo "[$(date)] Starting ${TYPE} backup..."

# Dump, compress, encrypt in single pipeline (no unencrypted temp file)
docker exec "$CONTAINER_NAME" pg_dump -U "$DB_USER" "$DB_NAME" \
  | gzip \
  | gpg --batch --yes --symmetric --cipher-algo AES256 \
        --passphrase-file "$PASSPHRASE_FILE" \
  > "${BACKUP_DIR}/${BACKUP_FILE}"

FILESIZE=$(du -h "${BACKUP_DIR}/${BACKUP_FILE}" | cut -f1)
echo "[$(date)] Backup created: ${BACKUP_FILE} (${FILESIZE})"

# Transfer to off-site storage (Hetzner Storage Box)
if [[ -n "$STORAGEBOX_USER" && -n "$STORAGEBOX_HOST" ]]; then
  echo "[$(date)] Transferring to off-site storage..."
  rsync -az --port="$STORAGEBOX_PORT" \
    "${BACKUP_DIR}/${BACKUP_FILE}" \
    "${STORAGEBOX_USER}@${STORAGEBOX_HOST}:backups/"
  echo "[$(date)] Off-site transfer complete"
else
  echo "[$(date)] WARN: No storage box configured, skipping off-site transfer"
fi

# Cleanup old local backups
DELETED=$(find "${BACKUP_DIR}" -name "everyskill_*.sql.gz.gpg" -mtime +${RETENTION_DAYS} -delete -print | wc -l)
if [[ "$DELETED" -gt 0 ]]; then
  echo "[$(date)] Cleaned up ${DELETED} backups older than ${RETENTION_DAYS} days"
fi

echo "[$(date)] Backup complete: ${BACKUP_FILE}"
```

Make it executable: `chmod +x docker/backup.sh`

2. Create `docker/restore.sh`:

```bash
#!/bin/bash
# Restore a PostgreSQL backup from encrypted file
# Usage: ./restore.sh <backup-file.sql.gz.gpg>
# WARNING: This will DROP and recreate the database!

set -euo pipefail

BACKUP_FILE="${1:-}"
CONTAINER_NAME="${CONTAINER_NAME:-everyskill-postgres}"
DB_USER="${DB_USER:-everyskill}"
DB_NAME="${DB_NAME:-everyskill}"
PASSPHRASE_FILE="${PASSPHRASE_FILE:-/etc/everyskill/backup-passphrase}"

if [[ -z "$BACKUP_FILE" ]]; then
  echo "Usage: $0 <backup-file.sql.gz.gpg>"
  echo "Available backups:"
  ls -lh /backups/everyskill_*.sql.gz.gpg 2>/dev/null || echo "  (none found in /backups/)"
  exit 1
fi

if [[ ! -f "$BACKUP_FILE" ]]; then
  echo "[ERROR] Backup file not found: $BACKUP_FILE"
  exit 1
fi

if [[ ! -f "$PASSPHRASE_FILE" ]]; then
  echo "[ERROR] Passphrase file not found: $PASSPHRASE_FILE"
  exit 1
fi

echo "[WARNING] This will DROP and recreate database '${DB_NAME}'!"
echo "Backup file: ${BACKUP_FILE}"
read -p "Type 'RESTORE' to confirm: " CONFIRM
if [[ "$CONFIRM" != "RESTORE" ]]; then
  echo "Aborted."
  exit 1
fi

echo "[$(date)] Starting restore from ${BACKUP_FILE}..."

# Decrypt, decompress, restore
gpg --batch --yes --decrypt --passphrase-file "$PASSPHRASE_FILE" "$BACKUP_FILE" \
  | gunzip \
  | docker exec -i "$CONTAINER_NAME" psql -U "$DB_USER" -d "$DB_NAME"

echo "[$(date)] Restore complete"
```

Make it executable: `chmod +x docker/restore.sh`

3. Create `docker/LUKS-RUNBOOK.md` documenting the LUKS full-disk encryption setup:

The runbook should cover:
- Prerequisites: Hetzner Rescue Mode access, backup data first
- Step 1: Boot into Hetzner Rescue Mode
- Step 2: Install cryptsetup if needed
- Step 3: Create LUKS partition on the data volume
- Step 4: Format and mount encrypted volume
- Step 5: Install Dropbear SSH in initramfs for remote unlock
- Step 6: Configure Dropbear on port 2222 with authorized keys
- Step 7: Update fstab and crypttab
- Step 8: Test reboot with remote LUKS unlock via Dropbear
- Step 9: Verify Docker volumes are on encrypted filesystem
- Emergency procedures: KVM console unlock, key custodian contacts

Important notes in the runbook:
- This is a ONE-TIME manual procedure on the VPS
- Must be done BEFORE deploying production workloads
- Requires server downtime (Rescue Mode reboot)
- Two key custodians should have the LUKS passphrase
- Monitor server after reboot -- if it doesn't come up within 10 min, unlock via Dropbear SSH on port 2222
  </action>
  <verify>
Verify all files exist and are executable (scripts):
- `ls -la /home/dev/projects/relay/docker/backup.sh /home/dev/projects/relay/docker/restore.sh`
- `grep "pg_dump" /home/dev/projects/relay/docker/backup.sh`
- `grep "gpg.*decrypt" /home/dev/projects/relay/docker/restore.sh`
- `grep -i "cryptsetup\|luks" /home/dev/projects/relay/docker/LUKS-RUNBOOK.md`
- Run `bash -n /home/dev/projects/relay/docker/backup.sh` and `bash -n /home/dev/projects/relay/docker/restore.sh` to syntax-check both scripts
  </verify>
  <done>
backup.sh performs pg_dump | gzip | gpg pipeline with rsync off-site transfer and 90-day retention cleanup. restore.sh decrypts and restores with confirmation prompt. LUKS-RUNBOOK.md documents the one-time server encryption procedure with Dropbear remote unlock. Both scripts pass bash syntax check.
  </done>
</task>

</tasks>

<verification>
- docker/backup.sh is executable, syntax-valid, pipes pg_dump -> gzip -> gpg
- docker/restore.sh is executable, syntax-valid, decrypts and restores
- docker/LUKS-RUNBOOK.md documents LUKS + Dropbear setup procedure
- No unencrypted temp files in backup pipeline (single pipe)
</verification>

<success_criteria>
Backup script automates encrypted pg_dump with off-site storage. Restore script can decrypt and restore. LUKS runbook provides step-by-step server encryption procedure. SOC2-03, SOC2-06, SOC2-07, DEPLOY-07 addressed.
</success_criteria>

<output>
After completion, create `.planning/phases/27-production-docker-deployment/27-03-SUMMARY.md`
</output>
