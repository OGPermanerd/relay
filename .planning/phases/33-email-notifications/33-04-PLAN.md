---
phase: 33-email-notifications
plan: 04
type: execute
wave: 3
depends_on: ["33-01", "33-03"]
files_modified:
  - apps/web/components/notification-bell.tsx
  - apps/web/components/notification-list.tsx
  - apps/web/app/actions/notifications.ts
  - apps/web/app/(protected)/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Bell icon visible in header with unread count badge"
    - "Clicking bell opens dropdown showing notification list"
    - "Each notification shows title, message, relative time, and read/unread state"
    - "Clicking a notification marks it as read and navigates to actionUrl"
    - "Mark all as read button clears all unread notifications"
  artifacts:
    - path: "apps/web/components/notification-bell.tsx"
      provides: "Bell icon with unread badge, dropdown toggle"
      exports: ["NotificationBell"]
    - path: "apps/web/components/notification-list.tsx"
      provides: "Scrollable notification list with mark-read actions"
      exports: ["NotificationList"]
    - path: "apps/web/app/actions/notifications.ts"
      provides: "Server actions for notification operations"
      exports: ["getMyNotifications", "getMyUnreadCount", "markRead", "markAllRead"]
  key_links:
    - from: "apps/web/app/(protected)/layout.tsx"
      to: "apps/web/components/notification-bell.tsx"
      via: "JSX render in header"
      pattern: "NotificationBell"
    - from: "apps/web/components/notification-bell.tsx"
      to: "apps/web/app/actions/notifications.ts"
      via: "server action calls"
      pattern: "import.*notifications"
    - from: "apps/web/app/actions/notifications.ts"
      to: "packages/db/src/services/notifications.ts"
      via: "import service functions"
      pattern: "import.*getUnreadNotificationCount|getUserNotifications"
---

<objective>
Build the in-app notification center: bell icon with unread count badge in the header, dropdown notification list with mark-read actions.

Purpose: NOTIF-02 requires a visible notification center. Users see a bell icon in the header, click to reveal a scrollable list of their notifications, and can mark them as read.
Output: NotificationBell and NotificationList components, notification server actions, layout integration.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@apps/web/app/(protected)/layout.tsx
@apps/web/components/greeting-area.tsx (reference for server component pattern in header)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server actions and notification bell component</name>
  <files>
    apps/web/app/actions/notifications.ts
    apps/web/components/notification-bell.tsx
    apps/web/components/notification-list.tsx
  </files>
  <action>
Create `apps/web/app/actions/notifications.ts` ("use server"):
- Import auth from "@/auth"
- Import getUserNotifications, getUnreadNotificationCount, markNotificationAsRead, markAllNotificationsAsRead from "@everyskill/db/services/notifications"
- Do NOT import or re-export types from this file (bundler issues with "use server")

Functions:
1. `getMyNotifications()` - Get session, return getUserNotifications(session.user.id). Serialize dates with .toISOString() before returning.
2. `getMyUnreadCount()` - Get session, return getUnreadNotificationCount(session.user.id). Returns number.
3. `markRead(notificationId: string)` - Get session (guard), call markNotificationAsRead(notificationId), return updated unread count.
4. `markAllRead()` - Get session (guard), call markAllNotificationsAsRead(session.user.id), return 0.

Create `apps/web/components/notification-list.tsx` ("use client"):
- Props: { notifications: Array<{ id: string; type: string; title: string; message: string; actionUrl: string | null; isRead: boolean; createdAt: string }>; onMarkRead: (id: string) => void; onMarkAllRead: () => void }
- Render a scrollable container (max-h-96 overflow-y-auto)
- Each notification: white bg if unread, gray-50 bg if read. Show blue dot indicator for unread.
- Display title (font-medium), message (text-sm text-gray-600), relative time using RelativeTime component from @/components/relative-time
- If actionUrl, wrap in an anchor tag that also calls onMarkRead
- "Mark all as read" button at the top-right if any unread exist
- Empty state: "No notifications yet" centered message
- Import RelativeTime from "@/components/relative-time" for timestamps

Create `apps/web/components/notification-bell.tsx` ("use client"):
- Props: { initialCount: number; initialNotifications: Array<same shape as above> }
- State: count (from initialCount), notifications (from initialNotifications), isOpen (boolean), isPending (useTransition)
- Bell SVG icon (24x24, gray-500, hover:gray-700)
- Red badge positioned absolute top-right: show count if > 0, show "99+" if > 99
- Click toggles isOpen state
- When open, render NotificationList as absolute dropdown (right-0, top-full, mt-2, w-80 or w-96, bg-white, shadow-lg, rounded-lg, border, z-50)
- Close dropdown when clicking outside (useEffect with document.addEventListener)
- onMarkRead: optimistic count decrement, call markRead server action, update count from response
- onMarkAllRead: optimistic count to 0, call markAllRead server action
- When dropdown opens, refresh notifications via getMyNotifications() server action to get latest
  </action>
  <verify>cd /home/dev/projects/relay/apps/web && pnpm exec tsc --noEmit 2>&1 | grep -E "(notification|Notification)" | head -10</verify>
  <done>NotificationBell and NotificationList components compile. Server actions export 4 functions.</done>
</task>

<task type="auto">
  <name>Task 2: Wire notification bell into protected layout header</name>
  <files>apps/web/app/(protected)/layout.tsx</files>
  <action>
Update `apps/web/app/(protected)/layout.tsx`:

1. Import getUnreadNotificationCount and getUserNotifications from "@everyskill/db/services/notifications" (direct DB import for server component, NOT via server action)
2. Import NotificationBell from "@/components/notification-bell"

3. In the ProtectedLayout server component, after the auth check:
   - Fetch unread count: `const unreadCount = await getUnreadNotificationCount(user.id!)`
   - Fetch recent notifications: `const recentNotifications = await getUserNotifications(user.id!, 20)` -- serialize dates to ISO strings

4. Add NotificationBell in the header "User Menu" div, BEFORE the profile link (after GreetingArea):
```tsx
<NotificationBell
  initialCount={unreadCount}
  initialNotifications={recentNotifications.map(n => ({
    ...n,
    createdAt: n.createdAt instanceof Date ? n.createdAt.toISOString() : n.createdAt,
    readAt: n.readAt instanceof Date ? n.readAt.toISOString() : n.readAt ?? null,
  }))}
/>
```

The bell should be positioned between the greeting area and the user avatar for visual balance. Use a div wrapper with `relative` positioning for the dropdown.

IMPORTANT: Do NOT use toLocaleDateString or toLocaleString anywhere (hydration mismatch). All date serialization uses .toISOString().
  </action>
  <verify>cd /home/dev/projects/relay/apps/web && pnpm exec tsc --noEmit 2>&1 | head -20 && pnpm build 2>&1 | tail -10</verify>
  <done>NotificationBell appears in the protected layout header with unread count badge. Build succeeds.</done>
</task>

</tasks>

<verification>
- `pnpm build` in apps/web succeeds
- Layout renders NotificationBell component
- Bell icon visible in header area
- Clicking bell shows dropdown with notification list
</verification>

<success_criteria>
- Bell icon with red unread count badge visible in header
- Dropdown opens on click with scrollable notification list
- Mark as read works with optimistic UI update
- Mark all as read clears badge
- Dropdown closes on outside click
- No hydration mismatches (dates serialized as ISO strings)
</success_criteria>

<output>
After completion, create `.planning/phases/33-email-notifications/33-04-SUMMARY.md`
</output>
