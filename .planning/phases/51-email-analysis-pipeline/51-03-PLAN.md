---
phase: 51-email-analysis-pipeline
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/email-classifier.ts
autonomous: true

must_haves:
  truths:
    - "Rule-based pass classifies obvious patterns (List-Unsubscribe = newsletter, noreply@ = automated)"
    - "AI pass sends ambiguous emails to Claude in batches of 75"
    - "Classification uses claude-haiku-4-5-20251022 for cost efficiency"
    - "Output validated with Zod schema matching category enum"
  artifacts:
    - path: "apps/web/lib/email-classifier.ts"
      provides: "classifyEmails with two-pass strategy (rules + AI)"
      exports: ["classifyEmails", "EmailCategory", "ClassifiedEmail"]
  key_links:
    - from: "apps/web/lib/email-classifier.ts"
      to: "@anthropic-ai/sdk"
      via: "import Anthropic"
      pattern: "Anthropic"
    - from: "apps/web/lib/email-classifier.ts"
      to: "zod"
      via: "import z for validation"
      pattern: "import.*z.*from.*zod"
---

<objective>
Create two-pass email classification engine: rule-based first (fast, free, handles ~70%), AI second (ambiguous cases only).

Purpose: Maximize accuracy while minimizing AI costs. Rule-based patterns handle obvious cases (List-Unsubscribe header = newsletter). Claude Haiku classifies remaining ambiguous emails in batches.
Output: classifyEmails function returning ClassifiedEmail[] with category and classificationMethod ("rule" or "ai").
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/lib/ai-review.ts
@apps/web/lib/gmail-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email classification library</name>
  <files>
apps/web/lib/email-classifier.ts
  </files>
  <action>
Create `apps/web/lib/email-classifier.ts`:

Import:
- Anthropic from "@anthropic-ai/sdk"
- z from "zod"
- EmailMetadata type from "./gmail-client"

Export type EmailCategory (union):
- "newsletter"
- "automated-notification"
- "meeting-invite"
- "direct-message"
- "internal-thread"
- "vendor-external"
- "support-ticket"

Export interface ClassifiedEmail (extends EmailMetadata):
- category: EmailCategory
- classificationMethod: "rule" | "ai"

Function 1: `applyRules(email: EmailMetadata): EmailCategory | null`
Rules (return category or null if no match):
1. If email.listUnsubscribe exists → "newsletter"
2. If email.from.toLowerCase() includes "noreply@", "no-reply@", "notifications@", "donotreply@" → "automated-notification"
3. If (email.from.toLowerCase() includes "calendar.google.com" OR "outlook.com") AND email.subject.toLowerCase() includes "invite" → "meeting-invite"
4. Otherwise → return null (ambiguous, needs AI)

Function 2: `async classifyBatchWithAI(emails: EmailMetadata[]): Promise<Map<string, EmailCategory>>`
- Prepare minimal metadata for Claude (privacy: domain only, truncated subject):
  ```
  const emailSummaries = emails.map(e => ({
    id: e.id,
    senderDomain: e.from.split("@")[1] ?? "unknown",
    subjectPreview: e.subject.slice(0, 100),
    hasListUnsubscribe: !!e.listUnsubscribe,
    isReply: !!e.inReplyTo,
  }))
  ```
- Create Anthropic client: `const client = new Anthropic({apiKey: process.env.ANTHROPIC_API_KEY!})`
- System prompt:
  ```
  You are an email categorization system. Given email metadata (sender domain, subject preview, reply status), classify each into one of these categories:
  - newsletter: Marketing emails, promotional content, bulk newsletters
  - automated-notification: System notifications, alerts, CI/CD reports, monitoring
  - meeting-invite: Calendar invites, meeting requests, scheduling
  - direct-message: Personal 1:1 communication requiring response
  - internal-thread: Multi-person discussion threads within same organization
  - vendor-external: Communication with external vendors, clients, partners
  - support-ticket: Customer support, helpdesk, issue tracking

  Return a JSON array with id and category for each email.
  ```
- JSON schema for output_config (following ai-review.ts pattern):
  ```
  const CLASSIFICATION_SCHEMA = {
    type: "object" as const,
    properties: {
      classifications: {
        type: "array" as const,
        items: {
          type: "object" as const,
          properties: {
            id: {type: "string" as const},
            category: {type: "string" as const, enum: ["newsletter", "automated-notification", "meeting-invite", "direct-message", "internal-thread", "vendor-external", "support-ticket"]}
          },
          required: ["id", "category"]
        }
      }
    },
    required: ["classifications"]
  }
  ```
- Zod schema for validation:
  ```
  const ClassificationOutputSchema = z.object({
    classifications: z.array(z.object({
      id: z.string(),
      category: z.enum(["newsletter", "automated-notification", "meeting-invite", "direct-message", "internal-thread", "vendor-external", "support-ticket"])
    }))
  })
  ```
- Call Claude:
  ```
  const response = await client.messages.create({
    model: "claude-haiku-4-5-20251022",
    max_tokens: 2048,
    system: systemPrompt,
    messages: [{role: "user", content: `Classify these emails:\n\n${JSON.stringify(emailSummaries, null, 2)}`}],
    output_config: {format: {type: "json_schema", schema: CLASSIFICATION_SCHEMA}}
  })
  ```
- Parse response (follow ai-review.ts pattern):
  ```
  const textBlock = response.content.find(block => block.type === "text");
  if (!textBlock || textBlock.type !== "text") throw new Error("No text content in classification response");
  const parsed = ClassificationOutputSchema.parse(JSON.parse(textBlock.text));
  ```
- Return as Map: `new Map(parsed.classifications.map(c => [c.id, c.category]))`

Export async function classifyEmails(emails: EmailMetadata[]): Promise<ClassifiedEmail[]>
Implementation:
1. PASS 1: Apply rules
   - For each email, call applyRules
   - If category returned, push to classified array with classificationMethod: "rule"
   - Else push to ambiguous array
2. PASS 2: AI classification (if ambiguous.length > 0)
   - Batch ambiguous emails in chunks of 75
   - For each batch, call classifyBatchWithAI
   - Lookup category from Map, fallback to "direct-message" if missing
   - Push to classified array with classificationMethod: "ai"
3. Return classified array

Follow ai-review.ts patterns for Anthropic client, structured output, and Zod validation.
  </action>
  <verify>
grep "export.*classifyEmails" apps/web/lib/email-classifier.ts
grep "claude-haiku-4-5-20251022" apps/web/lib/email-classifier.ts
grep "applyRules" apps/web/lib/email-classifier.ts
grep "classifyBatchWithAI" apps/web/lib/email-classifier.ts
  </verify>
  <done>
email-classifier.ts exports classifyEmails, EmailCategory type, ClassifiedEmail interface, uses two-pass strategy with Haiku 4.5.
  </done>
</task>

</tasks>

<verification>
1. Rule-based classification handles List-Unsubscribe, noreply@, meeting invites
2. AI classification uses Claude Haiku 4.5 with structured output
3. Batching limits AI calls to 75 emails per request
4. Output validated with Zod schema
5. ClassifiedEmail includes classificationMethod field
</verification>

<success_criteria>
- classifyEmails function implements two-pass strategy
- Rule-based pass handles obvious patterns (List-Unsubscribe, noreply@, calendar invites)
- AI pass sends ambiguous emails to Claude in batches of 75
- Uses claude-haiku-4-5-20251022 for cost efficiency
- Output validated with Zod matching EmailCategory enum
- Classification method tracked ("rule" or "ai") for each email
</success_criteria>

<output>
After completion, create `.planning/phases/51-email-analysis-pipeline/51-03-SUMMARY.md`
</output>
