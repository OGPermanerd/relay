---
phase: 51-email-analysis-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/gmail-client.ts
  - apps/web/package.json
autonomous: true
user_setup:
  - service: gmail-api
    why: "Fetch email metadata via Gmail API"
    env_vars:
      - name: GMAIL_CLIENT_ID
        source: "Already configured in Phase 50 (reuses AUTH_GOOGLE_ID)"
      - name: GMAIL_CLIENT_SECRET
        source: "Already configured in Phase 50 (reuses AUTH_GOOGLE_SECRET)"

must_haves:
  truths:
    - "Gmail client fetches message IDs for 90-day date range using gmail.readonly scope"
    - "Message metadata (From, Subject, Date, List-Unsubscribe, In-Reply-To) fetched with format: 'metadata'"
    - "Batching prevents rate limit errors (100 messages per Promise.all batch)"
    - "Token auto-refresh handled via getValidGmailToken before each batch"
  artifacts:
    - path: "apps/web/lib/gmail-client.ts"
      provides: "fetchEmailMetadata function using @googleapis/gmail"
      exports: ["fetchEmailMetadata", "EmailMetadata"]
    - path: "apps/web/package.json"
      provides: "@googleapis/gmail dependency"
      contains: "@googleapis/gmail"
  key_links:
    - from: "apps/web/lib/gmail-client.ts"
      to: "@everyskill/db/services/gmail-tokens"
      via: "import getValidGmailToken"
      pattern: "getValidGmailToken"
    - from: "apps/web/lib/gmail-client.ts"
      to: "@googleapis/gmail"
      via: "import google.gmail"
      pattern: "google\\.gmail"
---

<objective>
Create Gmail API client that fetches 90 days of email metadata with batching, pagination, and token refresh.

Purpose: Privacy-first email data access -- fetches ONLY headers (From, Subject, Date, List-Unsubscribe, In-Reply-To) using format: 'metadata', never accesses email bodies. Handles large mailboxes with batched API calls.
Output: fetchEmailMetadata function returning EmailMetadata[] array processed entirely in memory.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/db/src/services/gmail-tokens.ts
@apps/web/lib/ai-review.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @googleapis/gmail dependency</name>
  <files>
apps/web/package.json
  </files>
  <action>
Install @googleapis/gmail in apps/web workspace:

cd /home/dev/projects/relay/apps/web && pnpm add @googleapis/gmail

This provides the official Gmail API client with TypeScript types, OAuth2 integration, and batching support.
  </action>
  <verify>
grep "@googleapis/gmail" apps/web/package.json
  </verify>
  <done>
@googleapis/gmail dependency added to apps/web/package.json.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Gmail API client with metadata fetching</name>
  <files>
apps/web/lib/gmail-client.ts
  </files>
  <action>
Create `apps/web/lib/gmail-client.ts`:

Import:
- `gmail_v1, google` from "@googleapis/gmail"
- `getValidGmailToken` from "@everyskill/db/services/gmail-tokens"

Export interface EmailMetadata:
- id: string
- threadId: string
- date: Date
- from: string
- subject: string
- listUnsubscribe: string | null
- inReplyTo: string | null
- labels: string[]

Export async function fetchEmailMetadata(userId: string, options: {daysBack: number, maxMessages: number}): Promise<EmailMetadata[]>

Implementation:
1. Call getValidGmailToken(userId) to get decrypted token with auto-refresh
2. Create OAuth2Client: `const auth = new google.auth.OAuth2()` then `auth.setCredentials({access_token: token.accessToken, refresh_token: token.refreshToken, expiry_date: token.expiresAt.getTime()})`
3. Create Gmail client: `const gmail = google.gmail({version: "v1", auth})`
4. Calculate afterDate: `const afterDate = new Date(); afterDate.setDate(afterDate.getDate() - options.daysBack)`
5. Format for Gmail query: `const afterDateStr = afterDate.toISOString().split("T")[0].replace(/-/g, "/")`
6. List message IDs with pagination:
   - Call `gmail.users.messages.list({userId: "me", maxResults: 500, pageToken, q: \`after:\${afterDateStr}\`})`
   - Collect all message IDs up to maxMessages
   - Follow nextPageToken until exhausted or limit reached
7. Batch fetch metadata (100 messages per batch):
   - Slice messageIds into chunks of 100
   - For each chunk: `Promise.all(chunk.map(id => gmail.users.messages.get({userId: "me", id, format: "metadata", metadataHeaders: ["From", "Subject", "Date", "List-Unsubscribe", "In-Reply-To"]})))`
   - Parse headers using helper: `const getHeader = (name: string) => headers.find(h => h.name?.toLowerCase() === name.toLowerCase())?.value`
   - Build EmailMetadata objects
8. Return metadata array

Handle errors: wrap API calls in try/catch, throw descriptive errors on 401 (token invalid), 403 (permission denied), 429 (rate limit).

IMPORTANT: Gmail API costs 5 quota units per messages.get call. Rate limit is 250 units/user/second = 50 calls/second. Batching 100 messages with Promise.all takes ~2 seconds. For 5,000 messages, expect ~100 seconds total.
  </action>
  <verify>
grep "export.*fetchEmailMetadata" apps/web/lib/gmail-client.ts
grep "format:.*metadata" apps/web/lib/gmail-client.ts
grep "metadataHeaders" apps/web/lib/gmail-client.ts
  </verify>
  <done>
gmail-client.ts exports fetchEmailMetadata function, uses format: 'metadata', batches in chunks of 100, handles pagination.
  </done>
</task>

</tasks>

<verification>
1. @googleapis/gmail installed in apps/web
2. fetchEmailMetadata function exists and exports EmailMetadata type
3. Function uses format: 'metadata' with metadataHeaders (never accesses bodies)
4. Batching limits concurrent requests to 100 per Promise.all
5. Token refresh handled via getValidGmailToken
</verification>

<success_criteria>
- Gmail client can fetch message IDs for 90-day date range using q parameter
- Metadata fetching uses format: 'metadata' with specific headers only
- Batching prevents rate limit errors (100 per batch)
- Token auto-refresh works via getValidGmailToken before API calls
- EmailMetadata interface includes all required fields (from, subject, date, listUnsubscribe, inReplyTo, labels)
</success_criteria>

<output>
After completion, create `.planning/phases/51-email-analysis-pipeline/51-02-SUMMARY.md`
</output>
