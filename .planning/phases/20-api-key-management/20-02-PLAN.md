---
phase: 20-api-key-management
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - packages/db/src/services/api-keys.ts
  - packages/db/src/services/index.ts
  - apps/web/app/api/auth/validate-key/route.ts
  - apps/web/app/actions/api-keys.ts
autonomous: true

must_haves:
  truths:
    - "API key validation endpoint accepts raw key and returns userId for valid, non-revoked, non-expired keys"
    - "Validation endpoint returns 401 for revoked or expired keys"
    - "Server actions can generate, list, and revoke API keys for authenticated users"
    - "Key generation returns the raw key exactly once -- never persisted in plaintext"
    - "lastUsedAt updates fire-and-forget on successful validation"
  artifacts:
    - path: "packages/db/src/services/api-keys.ts"
      provides: "validateApiKey, listUserKeys, revokeApiKey, setKeyExpiry database operations"
      exports: ["validateApiKey", "listUserKeys", "revokeApiKey", "setKeyExpiry"]
    - path: "apps/web/app/api/auth/validate-key/route.ts"
      provides: "POST endpoint for MCP key validation"
      exports: ["POST"]
    - path: "apps/web/app/actions/api-keys.ts"
      provides: "generateApiKey, revokeApiKeyAction, listApiKeysAction server actions"
      exports: ["generateApiKey", "revokeApiKeyAction", "listApiKeysAction"]
  key_links:
    - from: "apps/web/app/api/auth/validate-key/route.ts"
      to: "packages/db/src/services/api-keys.ts"
      via: "import validateApiKey"
      pattern: "validateApiKey"
    - from: "apps/web/app/actions/api-keys.ts"
      to: "apps/web/lib/api-key-crypto.ts"
      via: "import generateRawApiKey, hashApiKey, extractPrefix"
      pattern: "generateRawApiKey|hashApiKey|extractPrefix"
    - from: "packages/db/src/services/api-keys.ts"
      to: "packages/db/src/schema/api-keys.ts"
      via: "import apiKeys table for queries"
      pattern: "apiKeys"
---

<objective>
Build the service layer, server actions, and validation endpoint for API key operations.

Purpose: This plan creates the complete backend for API key management. The service layer handles database queries (validate, list, revoke). Server actions handle authenticated mutations (generate, revoke, list). The validation endpoint provides a public POST route for the MCP server to resolve API keys to userIds.
Output: Working backend for all 6 KEY requirements -- ready for UI integration
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-api-key-management/20-RESEARCH.md
@.planning/phases/20-api-key-management/20-01-SUMMARY.md

@packages/db/src/schema/api-keys.ts
@packages/db/src/services/index.ts
@packages/db/src/client.ts
@apps/web/lib/api-key-crypto.ts
@apps/web/lib/admin.ts
@apps/web/app/actions/skills.ts
@apps/web/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create api-keys service layer and validation endpoint</name>
  <files>
    packages/db/src/services/api-keys.ts
    packages/db/src/services/index.ts
    apps/web/app/api/auth/validate-key/route.ts
  </files>
  <action>
Create `packages/db/src/services/api-keys.ts` with these exported functions:

**validateApiKey(rawKey: string): Promise<{ userId: string; keyId: string } | null>**
- Compute SHA-256 hash of the raw key using `createHash("sha256").update(rawKey).digest("hex")`
- Query api_keys table WHERE keyHash = computed hash AND revokedAt IS NULL AND (expiresAt IS NULL OR expiresAt > now)
- If no result, return null
- Perform timing-safe comparison using `crypto.timingSafeEqual` between the computed hash buffer and stored hash buffer (defense in depth)
- If match, fire-and-forget update of lastUsedAt to current timestamp (do NOT await -- use `.then(() => {}).catch(console.error)`)
- Return `{ userId, keyId }` on success
- Import `createHash`, `timingSafeEqual` from `crypto`

**listUserKeys(userId: string): Promise<Array<{...}>>**
- Query api_keys WHERE userId matches, ordered by createdAt DESC
- Return ONLY: id, keyPrefix, name, lastUsedAt, createdAt, revokedAt, expiresAt
- NEVER return keyHash in the result -- use explicit column selection with Drizzle's `columns` option

**revokeApiKey(keyId: string): Promise<boolean>**
- Update api_keys SET revokedAt = now() WHERE id = keyId AND revokedAt IS NULL
- Return true if a row was updated, false otherwise

**setKeyExpiry(userId: string, gracePeriodHours: number): Promise<void>**
- Update all active keys for the user (revokedAt IS NULL AND expiresAt IS NULL) to set expiresAt = now + gracePeriodHours
- This is used during key rotation to expire old keys after a grace period

Update `packages/db/src/services/index.ts` to export: `validateApiKey`, `listUserKeys`, `revokeApiKey`, `setKeyExpiry` from `"./api-keys"`.

Create `apps/web/app/api/auth/validate-key/route.ts`:
- Export async function POST(req: NextRequest)
- Parse JSON body, extract `key` field
- Validate key is a non-empty string
- If key missing or not string, return 400 with `{ error: "Missing key" }`
- Call `validateApiKey(key)` from the service layer
- If null (invalid/revoked/expired), return 401 with `{ error: "Invalid or expired key" }`
- If valid, return 200 with `{ userId, keyId }`
- This route is under `/api/auth/` which the middleware already allows through (line 9-13 of middleware.ts: `isAuthApi = req.nextUrl.pathname.startsWith("/api/auth")`)

Do NOT add any auth session check to the validation endpoint -- it must work without a browser session because the MCP stdio server calls it directly.
  </action>
  <verify>
1. `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json` passes
2. `npx tsc --noEmit -p apps/web/tsconfig.json` passes
3. Verify validate-key route.ts exports a POST function
4. Verify service never returns keyHash in listUserKeys
  </verify>
  <done>Service layer handles validate/list/revoke/setExpiry. Validation endpoint at /api/auth/validate-key accepts POST with { key } and returns { userId, keyId } or 401.</done>
</task>

<task type="auto">
  <name>Task 2: Create server actions for key generation, revocation, and listing</name>
  <files>
    apps/web/app/actions/api-keys.ts
  </files>
  <action>
Create `apps/web/app/actions/api-keys.ts` with "use server" directive at top.

**generateApiKey(formData: FormData): Promise<{ key?: string; error?: string }>**
- Get session via `auth()`, require session.user.id
- Parse formData fields: `name` (string, 1-100 chars via zod), `forUserId` (optional string)
- If `forUserId` is provided AND differs from session.user.id, check `isAdmin(session.user.email)` -- return error if not admin
- Determine targetUserId = forUserId || session.user.id
- Call `generateRawApiKey()` to get the plaintext key
- Call `hashApiKey(rawKey)` to get the SHA-256 hash
- Call `extractPrefix(rawKey)` to get the display prefix
- Insert into api_keys table via direct Drizzle insert: `db.insert(apiKeys).values({ userId: targetUserId, keyHash, keyPrefix, name })`
- Call `revalidatePath("/profile")` to refresh the profile page
- Return `{ key: rawKey }` -- this is the ONLY time the raw key is returned
- Wrap insert in try/catch, return `{ error: "Failed to generate key" }` on failure

**revokeApiKeyAction(keyId: string): Promise<{ success?: boolean; error?: string }>**
- Get session via `auth()`, require session.user.id
- Query the key by id to get its userId
- If key's userId !== session.user.id, check isAdmin -- return error if not admin
- Call `revokeApiKey(keyId)` from service layer
- Call `revalidatePath("/profile")`
- Return `{ success: true }` or `{ error: "Key not found or already revoked" }`

**rotateApiKey(formData: FormData): Promise<{ key?: string; error?: string }>**
- Get session via `auth()`, require session.user.id
- Parse formData: `name` (string), `gracePeriodHours` (number, default 24)
- Call `setKeyExpiry(session.user.id, gracePeriodHours)` to expire existing keys after grace period
- Generate new key (same logic as generateApiKey but always for self)
- Call `revalidatePath("/profile")`
- Return `{ key: rawKey }`

**listApiKeysAction(): Promise<{ keys?: Array<{...}>; error?: string }>**
- Get session via `auth()`, require session.user.id
- Call `listUserKeys(session.user.id)` from service layer
- Return `{ keys }` array

**listAllApiKeysAction(targetUserId?: string): Promise<{ keys?: Array<{...}>; error?: string }>**
- Get session via `auth()`, require session.user.id
- Check `isAdmin(session.user.email)` -- return error if not admin
- If targetUserId provided, list that user's keys; otherwise list all keys (query without userId filter)
- Return `{ keys }` with user info included

Follow the existing pattern from `apps/web/app/actions/skills.ts` for auth checks, zod validation, error handling, and revalidatePath usage. Import from `@relay/db` and `@/lib/api-key-crypto`, `@/lib/admin`, `@/auth`.
  </action>
  <verify>
1. `cd /home/dev/projects/relay && npx tsc --noEmit -p apps/web/tsconfig.json` passes
2. File starts with "use server" directive
3. All functions check session authentication
4. generateApiKey and rotateApiKey return the raw key string
5. Admin-only operations check isAdmin before proceeding
  </verify>
  <done>Five server actions exported: generateApiKey, revokeApiKeyAction, rotateApiKey, listApiKeysAction, listAllApiKeysAction. All auth-guarded. Admin operations require ADMIN_EMAILS membership. Raw key returned exactly once from generate/rotate.</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for both packages/db and apps/web
2. POST /api/auth/validate-key route exists and exports POST handler
3. Service layer never exposes keyHash to callers of listUserKeys
4. Server actions enforce auth and admin checks
5. Middleware already allows /api/auth/* paths through -- validate-key is accessible without session
</verification>

<success_criteria>
- validateApiKey resolves raw key to userId, rejects revoked/expired keys, uses timing-safe comparison
- POST /api/auth/validate-key returns 200 with {userId, keyId} for valid keys, 401 for invalid
- Server actions handle generate (KEY-01, KEY-05), revoke (KEY-04), rotate (KEY-06), and list operations
- Admin check gates cross-user operations (KEY-01 admin generation)
- Raw key returned exactly once on generation -- never stored in plaintext
</success_criteria>

<output>
After completion, create `.planning/phases/20-api-key-management/20-02-SUMMARY.md`
</output>
