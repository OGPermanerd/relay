---
phase: 20-api-key-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/services/api-keys.ts
  - packages/db/src/services/index.ts
autonomous: true

must_haves:
  truths:
    - "validateApiKey resolves raw key to userId for active, non-expired keys"
    - "validateApiKey returns null for revoked or expired keys"
    - "listUserKeys never returns keyHash"
    - "lastUsedAt updates fire-and-forget on validation"
  artifacts:
    - path: "packages/db/src/services/api-keys.ts"
      exports: ["validateApiKey", "listUserKeys", "revokeApiKey", "setKeyExpiry"]
---

<objective>
Create the database service layer for API key operations: validate, list, revoke, and set expiry.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@packages/db/src/schema/api-keys.ts
@packages/db/src/client.ts
@packages/db/src/services/skill-metrics.ts
@packages/db/src/services/index.ts
</context>

<tasks>

<task type="auto">
  <name>Create api-keys service</name>
  <files>
    packages/db/src/services/api-keys.ts
    packages/db/src/services/index.ts
  </files>
  <action>
Create `packages/db/src/services/api-keys.ts` following the pattern from `skill-metrics.ts`:

**validateApiKey(rawKey: string): Promise<{ userId: string; keyId: string } | null>**
- Hash the raw key with SHA-256: `createHash("sha256").update(rawKey).digest("hex")`
- Query api_keys WHERE keyHash = hash AND revokedAt IS NULL AND (expiresAt IS NULL OR expiresAt > now)
- Use `db.query.apiKeys.findFirst(...)` with Drizzle `eq`, `and`, `isNull`, `or`, `gt`
- If found, do timing-safe comparison with `crypto.timingSafeEqual` (Buffer of computed hash vs Buffer.from(stored hash, "hex"))
- If match, fire-and-forget `db.update(apiKeys).set({ lastUsedAt: new Date() }).where(eq(apiKeys.id, result.id)).then(() => {}).catch(console.error)`
- Return `{ userId: result.userId, keyId: result.id }` or null
- Select only id, userId, keyHash columns in the query

**listUserKeys(userId: string)**
- Query api_keys WHERE userId matches, ordered by createdAt DESC
- Use explicit `columns` to return: id, keyPrefix, name, lastUsedAt, createdAt, revokedAt, expiresAt
- NEVER return keyHash

**revokeApiKey(keyId: string): Promise<boolean>**
- Update SET revokedAt = new Date() WHERE id = keyId AND revokedAt IS NULL
- Return true if row affected

**setKeyExpiry(userId: string, gracePeriodHours: number): Promise<void>**
- Update all active keys (revokedAt IS NULL, expiresAt IS NULL) for userId
- Set expiresAt = new Date(Date.now() + gracePeriodHours * 3600000)

Update `packages/db/src/services/index.ts` to re-export: `validateApiKey`, `listUserKeys`, `revokeApiKey`, `setKeyExpiry` from `"./api-keys"`.
  </action>
  <verify>`npx tsc --noEmit -p packages/db/tsconfig.json` passes</verify>
  <done>Service layer handles validate/list/revoke/setExpiry. Validation uses timing-safe comparison and fire-and-forget lastUsedAt update.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/db/tsconfig.json` passes
2. Service never exposes keyHash in listUserKeys
</verification>

<success_criteria>
- validateApiKey resolves raw key to userId, rejects revoked/expired keys
- listUserKeys returns keys without keyHash
- revokeApiKey marks key as revoked
- setKeyExpiry sets grace period on active keys
</success_criteria>

<output>
After completion, create `.planning/phases/20-api-key-management/20-02-SUMMARY.md`
</output>
