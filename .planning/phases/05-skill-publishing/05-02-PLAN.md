---
phase: 05-skill-publishing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/skill-stats.ts
  - apps/web/components/stat-card.tsx
  - apps/web/components/skill-detail.tsx
  - apps/web/app/(protected)/skills/[slug]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can view skill detail page at /skills/{slug}"
    - "Skill detail page displays name, description, category"
    - "Skill detail page shows author name and avatar"
    - "Skill detail page shows total uses from MCP tracking"
    - "Skill detail page shows unique users count"
    - "Skill detail page shows average rating"
    - "Skill detail page shows FTE Days Saved calculation"
    - "Non-existent slug returns 404 page"
  artifacts:
    - path: "apps/web/lib/skill-stats.ts"
      provides: "Usage statistics aggregation from database"
      exports: ["getSkillStats", "SkillStats"]
    - path: "apps/web/components/stat-card.tsx"
      provides: "Reusable stat display component"
      exports: ["StatCard"]
    - path: "apps/web/components/skill-detail.tsx"
      provides: "Skill detail display component"
      exports: ["SkillDetail"]
    - path: "apps/web/app/(protected)/skills/[slug]/page.tsx"
      provides: "Dynamic route for skill detail"
      min_lines: 30
  key_links:
    - from: "apps/web/app/(protected)/skills/[slug]/page.tsx"
      to: "@relay/db"
      via: "db.query.skills.findFirst"
      pattern: "db.*query.*skills.*findFirst"
    - from: "apps/web/lib/skill-stats.ts"
      to: "usageEvents table"
      via: "SQL aggregation"
      pattern: "usageEvents"
---

<objective>
Create the skill detail page with usage statistics from MCP tracking.

Purpose: Allow users to view skill information and see real usage metrics proving skill value.
Output: Dynamic detail page at /skills/[slug] showing full metadata and statistics.
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-skill-publishing/05-RESEARCH.md

# Existing infrastructure
@packages/db/src/schema/skills.ts
@packages/db/src/schema/usage-events.ts
@packages/db/src/relations/index.ts
@packages/db/src/services/skill-metrics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill statistics aggregation service</name>
  <files>apps/web/lib/skill-stats.ts</files>
  <action>
Create apps/web/lib/skill-stats.ts with usage statistics aggregation:

1. Export interface SkillStats:
   ```typescript
   export interface SkillStats {
     totalUses: number
     uniqueUsers: number
     averageRating: string | null  // Formatted "4.5" or null
     totalRatings: number
     fteDaysSaved: number  // Rounded to 1 decimal
   }
   ```

2. Export async function getSkillStats(skillId: string): Promise<SkillStats>

Implementation:
- Import db from @relay/db
- Import usageEvents, ratings, skills from @relay/db schema tables
- Import sql, eq, count from drizzle-orm
- Import formatRating from @relay/db (services)

Query 1 - Usage stats from usageEvents:
```typescript
const usageResult = await db?.select({
  totalUses: sql<number>`cast(count(*) as integer)`,
  uniqueUsers: sql<number>`cast(count(distinct ${usageEvents.userId}) as integer)`,
})
.from(usageEvents)
.where(eq(usageEvents.skillId, skillId))
```

Query 2 - Rating stats from ratings:
```typescript
const ratingResult = await db?.select({
  totalRatings: sql<number>`cast(count(*) as integer)`,
})
.from(ratings)
.where(eq(ratings.skillId, skillId))
```

Query 3 - Get skill for denormalized values:
```typescript
const skill = await db?.query.skills.findFirst({
  where: eq(skills.id, skillId),
  columns: { hoursSaved: true, totalUses: true, averageRating: true }
})
```

Calculate FTE Days Saved:
- totalUses from skill (denormalized) or usageResult
- hoursSaved from skill (default 1)
- fteDaysSaved = (totalUses * hoursSaved) / 8
- Round to 1 decimal: Math.round(fteDaysSaved * 10) / 10

Return SkillStats object with defaults for null cases:
- totalUses: skill?.totalUses ?? 0
- uniqueUsers: usageResult?.[0]?.uniqueUsers ?? 0
- averageRating: formatRating(skill?.averageRating ?? null)
- totalRatings: ratingResult?.[0]?.totalRatings ?? 0
- fteDaysSaved: calculated value

IMPORTANT: Handle null db case - return all zeros if db is null.
  </action>
  <verify>
TypeScript compilation passes: `pnpm --filter @relay/web exec tsc --noEmit`
  </verify>
  <done>
getSkillStats function aggregates real usage data from usageEvents and ratings tables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StatCard and SkillDetail components</name>
  <files>apps/web/components/stat-card.tsx, apps/web/components/skill-detail.tsx</files>
  <action>
Create two reusable components:

**1. apps/web/components/stat-card.tsx** (server component):

```typescript
interface StatCardProps {
  label: string
  value: string | number
  suffix?: string
}

export function StatCard({ label, value, suffix }: StatCardProps) {
  return (
    <div className="rounded-lg bg-white p-4 shadow">
      <p className="text-sm text-gray-500">{label}</p>
      <p className="text-2xl font-bold text-blue-600">
        {value}
        {suffix && <span className="ml-1 text-sm font-normal text-gray-400">{suffix}</span>}
      </p>
    </div>
  )
}
```

**2. apps/web/components/skill-detail.tsx** (server component):

Import { StatCard } from './stat-card'
Import Image from 'next/image'
Import type { SkillStats } from '@/lib/skill-stats'

Define SkillWithAuthor type matching what we'll pass from the page:
```typescript
interface SkillWithAuthor {
  id: string
  name: string
  slug: string
  description: string
  category: string
  content: string
  hoursSaved: number | null
  createdAt: Date
  author: {
    id: string
    name: string | null
    image: string | null
  } | null
}

interface SkillDetailProps {
  skill: SkillWithAuthor
  stats: SkillStats
}
```

Export function SkillDetail({ skill, stats }: SkillDetailProps):

Layout structure:
1. Header section:
   - Category badge (uppercase, bg-blue-100 text-blue-800 rounded-full px-3 py-1 text-sm)
   - Skill name (h1, text-3xl font-bold)
   - Author info (flex with avatar Image 40x40 rounded-full, name, "Created {date}")

2. Stats grid (grid cols-2 sm:cols-4 gap-4 mt-6):
   - StatCard: "Total Uses" - stats.totalUses
   - StatCard: "Unique Users" - stats.uniqueUsers
   - StatCard: "Avg Rating" - stats.averageRating ?? "N/A", suffix: stats.totalRatings ? `(${stats.totalRatings})` : undefined
   - StatCard: "FTE Days Saved" - stats.fteDaysSaved

3. Description section (mt-8):
   - h2 "Description"
   - p with skill.description

4. Usage section (if skill has hoursSaved):
   - Show estimated time saved per use

5. Content section (mt-8):
   - h2 "Skill Content"
   - pre/code block with skill.content (bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto whitespace-pre-wrap)

Format date with toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })

Use Next.js Image with fallback for missing avatar (div with initials).
  </action>
  <verify>
TypeScript compilation passes: `pnpm --filter @relay/web exec tsc --noEmit`
  </verify>
  <done>
StatCard and SkillDetail components render skill information with proper styling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create dynamic skill detail page route</name>
  <files>apps/web/app/(protected)/skills/[slug]/page.tsx</files>
  <action>
Create the dynamic route page at apps/web/app/(protected)/skills/[slug]/page.tsx:

```typescript
import { notFound } from 'next/navigation'
import { db, skills } from '@relay/db'
import { eq } from 'drizzle-orm'
import { SkillDetail } from '@/components/skill-detail'
import { getSkillStats } from '@/lib/skill-stats'

interface SkillPageProps {
  params: Promise<{ slug: string }>  // Next.js 15: params is a Promise
}

export default async function SkillPage({ params }: SkillPageProps) {
  const { slug } = await params  // IMPORTANT: await params in Next.js 15

  if (!db) {
    return (
      <div className="mx-auto max-w-4xl px-4 py-8">
        <p className="text-gray-600">Database not configured</p>
      </div>
    )
  }

  const skill = await db.query.skills.findFirst({
    where: eq(skills.slug, slug),
    with: {
      author: {
        columns: { id: true, name: true, image: true }
      }
    }
  })

  if (!skill) {
    notFound()
  }

  const stats = await getSkillStats(skill.id)

  return (
    <div className="mx-auto max-w-4xl px-4 py-8">
      <SkillDetail skill={skill} stats={stats} />
    </div>
  )
}
```

Key patterns from research:
1. `params` is Promise<{ slug: string }> in Next.js 15 - MUST await
2. Use db.query.skills.findFirst with `with` for relations
3. Return notFound() for missing skills (shows 404 page)
4. Handle null db case gracefully
  </action>
  <verify>
1. TypeScript passes: `pnpm --filter @relay/web exec tsc --noEmit`
2. Build succeeds: `pnpm --filter @relay/web build`
  </verify>
  <done>
Skill detail page at /skills/[slug] displays full skill information with real usage statistics.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `pnpm --filter @relay/web exec tsc --noEmit` passes
2. Build: `pnpm --filter @relay/web build` succeeds
3. Linting: `pnpm lint` passes
4. All files exist at expected paths
</verification>

<success_criteria>
- getSkillStats aggregates usage data from usageEvents table
- StatCard component is reusable for metrics display
- SkillDetail component displays all skill metadata
- Dynamic route /skills/[slug] fetches and displays skill
- Non-existent slugs return 404
- Usage statistics show real MCP tracking data
- FTE Days Saved calculated from uses * hoursSaved / 8
</success_criteria>

<output>
After completion, create `.planning/phases/05-skill-publishing/05-02-SUMMARY.md`
</output>
