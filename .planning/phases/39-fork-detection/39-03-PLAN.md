---
phase: 39-fork-detection
plan: 03
type: execute
wave: 2
depends_on: ["39-01"]
files_modified:
  - apps/mcp/src/tools/update-skill.ts
  - apps/mcp/src/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "Authors can push local modifications back as a new version via update_skill"
    - "Non-authors who call update_skill get a fork created with proper forkedAtContentHash and skill_versions record"
  artifacts:
    - path: "apps/mcp/src/tools/update-skill.ts"
      provides: "update_skill MCP tool with author-vs-fork branching"
      exports: ["handleUpdateSkill"]
    - path: "apps/mcp/src/tools/index.ts"
      provides: "Tool registration import"
      contains: "update-skill"
  key_links:
    - from: "apps/mcp/src/tools/update-skill.ts"
      to: "skills table"
      via: "INSERT or UPDATE depending on author check"
      pattern: "(INSERT INTO skills|UPDATE skills)"
    - from: "apps/mcp/src/tools/update-skill.ts"
      to: "skill_versions table"
      via: "INSERT version record"
      pattern: "INSERT INTO skill_versions"
---

<objective>
Create the `update_skill` MCP tool that pushes local modifications back. If the user is the author, creates a new version. If the user is not the author, creates a fork with `forkedAtContentHash` and a `skill_versions` record.

Purpose: Users need to push modified skills back without leaving the CLI (FORK-03).
Output: New MCP tool registered, handling both author-update and non-author-fork paths.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@apps/mcp/src/tools/create.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update_skill MCP tool</name>
  <files>
    apps/mcp/src/tools/update-skill.ts
    apps/mcp/src/tools/index.ts
  </files>
  <action>
Create `apps/mcp/src/tools/update-skill.ts` following the MCP tool pattern from create.ts:

1. **Imports:** `z` from zod, `crypto` from node:crypto, `sql` from drizzle-orm, `server` from ../server.js, `db`, `DEFAULT_TENANT_ID` from @everyskill/db, `getUserId`, `getTenantId` from ../auth.js.

2. **Self-contained helpers** (same as in create.ts and check-skill-status.ts):
   - `stripFrontmatter(content: string): string`
   - `hashContent(content: string): Promise<string>`
   - `generateSlug(name: string): string` (copy from create.ts)
   - `generateUniqueSlug(name: string): Promise<string>` (copy from create.ts)

3. **Exported handler** `handleUpdateSkill`:
   - Parameters: `{ skillId: string; content: string; description?: string }`
   - DB null check
   - Auth REQUIRED: `const userId = getUserId();` -- return error if null (must be authenticated to modify skills)
   - `const tenantId = getTenantId() || DEFAULT_TENANT_ID;`
   - Fetch skill: `SELECT id, name, slug, description, category, content, author_id, status, hours_saved FROM skills WHERE id = skillId`
   - If no skill found, return error

   **Author path (userId === skill.authorId):**
   - Get latest version number: `SELECT COALESCE(MAX(version), 0) as max_version FROM skill_versions WHERE skill_id = skillId`
   - `const newVersion = maxVersion + 1;`
   - Strip frontmatter from new content: `const rawContent = stripFrontmatter(content);`
   - Hash the full content: `const contentHash = await hashContent(content);`
   - Insert version record:
     ```sql
     INSERT INTO skill_versions (id, tenant_id, skill_id, version, content_url, content_hash, content_type, name, description, created_by)
     VALUES (versionId, tenantId, skillId, newVersion, '', contentHash, 'text/markdown', skill.name, description || skill.description, userId)
     ```
   - Update skill content and version reference:
     ```sql
     UPDATE skills SET content = content, published_version_id = versionId, description = description || skill.description, updated_at = NOW() WHERE id = skillId
     ```
   - Set status to 'draft' so updated skill goes through review pipeline:
     ```sql
     UPDATE skills SET status = 'draft' WHERE id = skillId
     ```
   - Return `{ action: "updated", skillId, version: newVersion, message: "Skill updated to version N. Status set to draft for review." }`

   **Non-author path (userId !== skill.authorId):**
   - Compute forkedAtContentHash: `await hashContent(stripFrontmatter(skill.content))`
   - Generate fork name and slug: `const forkName = skill.name + " (Fork)";` + `await generateUniqueSlug(forkName)`
   - Insert new skill:
     ```sql
     INSERT INTO skills (id, tenant_id, name, slug, description, category, content, hours_saved, forked_from_id, forked_at_content_hash, author_id, status)
     VALUES (newId, tenantId, forkName, slug, description || skill.description, skill.category, content, 0, skillId, forkedAtContentHash, userId, 'draft')
     ```
   - Insert version record for the fork (same pattern as author path, version = 1)
   - Update fork's `published_version_id`
   - Return `{ action: "forked", skillId: newId, slug, forkName, message: "Created fork 'X' as draft. Original skill unchanged." }`

4. **Tool registration:**
   ```typescript
   server.registerTool(
     "update_skill",
     {
       description: "Push local skill modifications back to EverySkill. If you are the skill author, creates a new version (set to draft for re-review). If not the author, creates a fork. Requires EVERYSKILL_API_KEY.",
       inputSchema: {
         skillId: z.string().describe("Skill ID to update"),
         content: z.string().describe("Updated skill content (full markdown)"),
         description: z.string().optional().describe("Updated description (optional, keeps existing if omitted)"),
       },
     },
     async ({ skillId, content, description }) => handleUpdateSkill({ skillId, content, description })
   );
   ```

5. **Register in index.ts:** Add `import "./update-skill.js";` to `apps/mcp/src/tools/index.ts`.
  </action>
  <verify>
Run: `cd apps/mcp && npx tsc --noEmit 2>&1 | grep -v "node_modules" | head -20` -- no new errors.
Run: `grep "update-skill" apps/mcp/src/tools/index.ts` -- import exists.
  </verify>
  <done>
`update_skill` MCP tool exists with two code paths: author-update (new version, status=draft) and non-author-fork (new skill with forkedAtContentHash and skill_versions record).
  </done>
</task>

</tasks>

<verification>
1. Tool file exists at `apps/mcp/src/tools/update-skill.ts`
2. Tool imported in `apps/mcp/src/tools/index.ts`
3. Author path: creates new `skill_versions` record, updates skill content, sets status to draft
4. Non-author path: creates fork with `forkedAtContentHash`, `skill_versions` record, and `publishedVersionId`
5. Auth required (returns error if no userId)
6. TypeScript compiles (no new errors)
</verification>

<success_criteria>
- `update_skill` tool registered with MCP server
- Authors get new version of their skill (set to draft for re-review)
- Non-authors get a fork with complete records (forkedAtContentHash, skill_versions, publishedVersionId)
- Authentication enforced for all modifications
</success_criteria>

<output>
After completion, create `.planning/phases/39-fork-detection/39-03-SUMMARY.md`
</output>
