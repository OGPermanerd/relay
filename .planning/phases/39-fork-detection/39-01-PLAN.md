---
phase: 39-fork-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/skills.ts
  - packages/db/src/migrations/0017_add_forked_at_content_hash.sql
  - apps/web/app/actions/fork-skill.ts
autonomous: true

must_haves:
  truths:
    - "Forking a skill stores the parent's content hash at fork time for later drift detection"
    - "Forking a skill creates a skill_versions record so the fork is not orphaned"
  artifacts:
    - path: "packages/db/src/schema/skills.ts"
      provides: "forkedAtContentHash column definition"
      contains: "forkedAtContentHash"
    - path: "packages/db/src/migrations/0017_add_forked_at_content_hash.sql"
      provides: "ALTER TABLE migration for new column"
      contains: "forked_at_content_hash"
    - path: "apps/web/app/actions/fork-skill.ts"
      provides: "Updated fork action with hash + version record"
      contains: "forkedAtContentHash"
  key_links:
    - from: "apps/web/app/actions/fork-skill.ts"
      to: "packages/db/src/schema/skills.ts"
      via: "forkedAtContentHash column"
      pattern: "forkedAtContentHash"
    - from: "apps/web/app/actions/fork-skill.ts"
      to: "skill_versions table"
      via: "INSERT into skill_versions"
      pattern: "skill_versions"
---

<objective>
Add `forkedAtContentHash` column to skills schema, run migration, and update `forkSkill` action to store the parent's content hash at fork time AND create a `skill_versions` record.

Purpose: Foundation for drift detection -- without the hash anchor, we cannot tell if a fork has been modified. Without a version record, forks are orphaned from the version system.
Output: Schema with new column, migration applied, fork action creating complete records.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/db/src/schema/skills.ts
@packages/db/src/schema/skill-versions.ts
@apps/web/app/actions/fork-skill.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add forkedAtContentHash column and migration</name>
  <files>
    packages/db/src/schema/skills.ts
    packages/db/src/migrations/0017_add_forked_at_content_hash.sql
  </files>
  <action>
1. In `packages/db/src/schema/skills.ts`, add a new column after `forkedFromId`:
   ```typescript
   forkedAtContentHash: text("forked_at_content_hash"),
   ```
   This is nullable -- existing forks will have null (shown as "unknown drift status" in UI).

2. Create migration `packages/db/src/migrations/0017_add_forked_at_content_hash.sql`:
   ```sql
   ALTER TABLE skills ADD COLUMN forked_at_content_hash text;
   ```
   No backfill -- existing forks lack the original parent content at fork time, so any computed hash would be inaccurate.

3. Apply migration via psql (not drizzle-kit push, which prompts about unrelated constraints per [37-01] decision):
   ```bash
   psql "$DATABASE_URL" -f packages/db/src/migrations/0017_add_forked_at_content_hash.sql
   ```
  </action>
  <verify>
Run: `psql "$DATABASE_URL" -c "SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name = 'skills' AND column_name = 'forked_at_content_hash';"` -- should return one row with `text` type and `YES` nullable.
Run: `cd apps/web && npx tsc --noEmit 2>&1 | head -20` -- no new type errors from the schema change.
  </verify>
  <done>The `forked_at_content_hash` column exists in the skills table and the Drizzle schema type includes `forkedAtContentHash`.</done>
</task>

<task type="auto">
  <name>Task 2: Update forkSkill action to store hash and create version record</name>
  <files>
    apps/web/app/actions/fork-skill.ts
  </files>
  <action>
Update `apps/web/app/actions/fork-skill.ts` to:

1. Import `hashContent` from `@/lib/content-hash` and add `skillVersions` import from `@everyskill/db/schema`.

2. After fetching the parent skill, compute `forkedAtContentHash`:
   - Strip frontmatter from parent.content using regex: `const match = content.match(/^---\n[\s\S]*?\n---\n/); const stripped = match ? content.slice(match[0].length) : content;`
   - Hash: `const parentHash = await hashContent(stripped);`

3. Add `forkedAtContentHash: parentHash` to the `db.insert(skills).values(...)` call.

4. After the successful skill insert (after `newSkill = inserted`), create a `skill_versions` record:
   ```typescript
   const versionId = crypto.randomUUID();
   const contentHash = await hashContent(parent.content);
   await db.insert(skillVersions).values({
     id: versionId,
     tenantId: DEFAULT_TENANT_ID,
     skillId: newSkill.id,
     version: 1,
     contentUrl: '',
     contentHash,
     contentType: 'text/markdown',
     name: forkName,
     description: parent.description,
     createdBy: session.user.id,
   });
   // Set publishedVersionId on the fork
   await db.update(skills).set({ publishedVersionId: versionId }).where(eq(skills.id, newSkill.id));
   ```
   Wrap version creation in try/catch (non-fatal -- fork still usable without version record, matches pattern in create.ts).

5. Also fetch `parent.content` in the parent query columns (it is already fetched -- verify the `columns` projection includes `content: true`).

NOTE: The `forkedAtContentHash` is computed from `stripFrontmatter(parent.content)` (body only). The version record's `contentHash` is computed from the full content (with frontmatter), matching the existing pattern in create.ts. These are two DIFFERENT hashes for two DIFFERENT purposes.
  </action>
  <verify>
Run: `cd apps/web && npx tsc --noEmit 2>&1 | head -20` -- no type errors.
Run: `cd apps/web && pnpm build 2>&1 | tail -20` -- build succeeds.
  </verify>
  <done>Forking a skill now stores `forkedAtContentHash` (stripped body hash of parent) and creates a `skill_versions` record with `publishedVersionId` set on the new fork.</done>
</task>

</tasks>

<verification>
1. Schema: `forked_at_content_hash` column exists on skills table (nullable text)
2. Type check: `cd apps/web && npx tsc --noEmit` passes
3. Build: `cd apps/web && pnpm build` succeeds
4. Fork action: contains `forkedAtContentHash`, `skillVersions` insert, and `publishedVersionId` update
</verification>

<success_criteria>
- `forked_at_content_hash` column exists in PostgreSQL skills table
- `forkedAtContentHash` field in Drizzle skills schema
- `forkSkill` action computes and stores `forkedAtContentHash` from stripped parent content
- `forkSkill` action creates `skill_versions` record and sets `publishedVersionId`
- Full build passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/39-fork-detection/39-01-SUMMARY.md`
</output>
