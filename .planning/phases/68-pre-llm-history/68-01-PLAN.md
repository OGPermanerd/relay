---
phase: 68-pre-llm-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/work-artifacts.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/relations/index.ts
  - packages/db/src/migrations/0037_add_work_artifacts.sql
  - apps/web/app/actions/work-artifacts.ts
  - apps/web/lib/portfolio-queries.ts
autonomous: true

must_haves:
  truths:
    - "work_artifacts table exists in the database with tenant_id, userId, title, description, category, artifactDate, fileName, fileType, extractedText, suggestedSkillIds, estimatedHoursSaved columns"
    - "Server actions exist for creating, updating, deleting, and listing work artifacts"
    - "Portfolio queries include a function to fetch user artifacts for display"
  artifacts:
    - path: "packages/db/src/schema/work-artifacts.ts"
      provides: "work_artifacts pgTable definition with pgPolicy tenant isolation"
      contains: "workArtifacts"
    - path: "packages/db/src/migrations/0037_add_work_artifacts.sql"
      provides: "SQL migration to create work_artifacts table with indexes"
      contains: "CREATE TABLE"
    - path: "apps/web/app/actions/work-artifacts.ts"
      provides: "Server actions: createWorkArtifact, updateWorkArtifact, deleteWorkArtifact"
      exports: ["createWorkArtifact", "updateWorkArtifact", "deleteWorkArtifact"]
    - path: "apps/web/lib/portfolio-queries.ts"
      provides: "getUserArtifacts query function"
      contains: "getUserArtifacts"
  key_links:
    - from: "apps/web/app/actions/work-artifacts.ts"
      to: "packages/db/src/schema/work-artifacts.ts"
      via: "SQL insert/update/delete against work_artifacts table"
      pattern: "work_artifacts"
    - from: "packages/db/src/schema/index.ts"
      to: "packages/db/src/schema/work-artifacts.ts"
      via: "re-export"
      pattern: "export.*work-artifacts"
---

<objective>
Create the work_artifacts database schema, migration, server actions (CRUD), and portfolio query for fetching artifacts.

Purpose: Establish the data foundation for pre-LLM history — the table, server actions, and query that all UI components will consume.
Output: Schema, migration, server actions, and query function ready for UI integration.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@packages/db/src/schema/resume-shares.ts — schema pattern (pgTable, pgPolicy, text PK UUID, tenant_id FK)
@packages/db/src/schema/index.ts — schema re-exports
@packages/db/src/relations/index.ts — relations definitions (add workArtifacts relations)
@apps/web/app/actions/resume-share.ts — server action CRUD pattern (auth check, tenantId, db.execute with sql template)
@apps/web/lib/portfolio-queries.ts — existing portfolio query functions (add getUserArtifacts here)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create work_artifacts schema, migration, and wire into DB exports</name>
  <files>
    packages/db/src/schema/work-artifacts.ts
    packages/db/src/schema/index.ts
    packages/db/src/relations/index.ts
    packages/db/src/migrations/0037_add_work_artifacts.sql
  </files>
  <action>
1. Create `packages/db/src/schema/work-artifacts.ts` following the resume-shares.ts pattern exactly:
   - `workArtifacts` pgTable with columns:
     - `id`: text PK with `$defaultFn(() => crypto.randomUUID())`
     - `tenantId`: text NOT NULL references tenants.id
     - `userId`: text NOT NULL references users.id with onDelete cascade
     - `title`: text NOT NULL
     - `description`: text (nullable)
     - `category`: text NOT NULL (values: "document", "email", "template", "script", "other")
     - `artifactDate`: timestamp NOT NULL (when the work was originally done)
     - `fileName`: text (nullable, original file name)
     - `fileType`: text (nullable, file extension/MIME hint)
     - `extractedText`: text (nullable, parsed content for AI analysis)
     - `suggestedSkillIds`: text array, default empty array `sql\`'{}'\``
     - `estimatedHoursSaved`: `doublePrecision("estimated_hours_saved")` (nullable, user self-reported)
     - `createdAt`: timestamp NOT NULL defaultNow()
     - `updatedAt`: timestamp NOT NULL defaultNow()
   - Indexes: user_id, tenant_id, artifact_date (composite user_id + artifact_date)
   - pgPolicy: tenant_isolation (restrictive, for all, using/withCheck on `current_setting('app.current_tenant_id', true)`)
   - Export types: `WorkArtifact` (inferSelect) and `NewWorkArtifact` (inferInsert)

2. Add `export * from "./work-artifacts";` to `packages/db/src/schema/index.ts`

3. In `packages/db/src/relations/index.ts`:
   - Import `workArtifacts` from "../schema"
   - Add `workArtifactsRelations` with: user (many-to-one users), tenant (many-to-one tenants)
   - Add `workArtifacts: many(workArtifacts)` to `usersRelations`
   - Add `workArtifacts: many(workArtifacts)` to `tenantsRelations`

4. Create `packages/db/src/migrations/0037_add_work_artifacts.sql`:
```sql
CREATE TABLE IF NOT EXISTS work_artifacts (
  id TEXT PRIMARY KEY,
  tenant_id TEXT NOT NULL REFERENCES tenants(id),
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL DEFAULT 'other',
  artifact_date TIMESTAMP NOT NULL,
  file_name TEXT,
  file_type TEXT,
  extracted_text TEXT,
  suggested_skill_ids TEXT[] DEFAULT '{}',
  estimated_hours_saved DOUBLE PRECISION,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX work_artifacts_user_id_idx ON work_artifacts(user_id);
CREATE INDEX work_artifacts_tenant_id_idx ON work_artifacts(tenant_id);
CREATE INDEX work_artifacts_user_date_idx ON work_artifacts(user_id, artifact_date);

ALTER TABLE work_artifacts ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation ON work_artifacts
  AS RESTRICTIVE FOR ALL
  USING (tenant_id = current_setting('app.current_tenant_id', true))
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id', true));
```

5. Run the migration: `cd /home/dev/projects/relay && pnpm db:migrate`
  </action>
  <verify>
    - `pnpm --filter @everyskill/db build` succeeds (TypeScript compiles)
    - Migration applied: `pnpm db:migrate` completes without errors
    - Table exists: query `SELECT count(*) FROM work_artifacts` returns 0
  </verify>
  <done>work_artifacts table exists in dev database with all columns, indexes, and RLS policy. Schema is exported from @everyskill/db and relations are wired.</done>
</task>

<task type="auto">
  <name>Task 2: Create server actions and portfolio query for work artifacts</name>
  <files>
    apps/web/app/actions/work-artifacts.ts
    apps/web/lib/portfolio-queries.ts
  </files>
  <action>
1. Create `apps/web/app/actions/work-artifacts.ts` with "use server" directive, following the resume-share.ts pattern:

   **createWorkArtifact(formData: FormData):**
   - Auth check: session?.user?.id and session.user.tenantId
   - Zod validation schema:
     - title: z.string().min(1).max(200)
     - description: z.string().max(2000).optional()
     - category: z.enum(["document", "email", "template", "script", "other"])
     - artifactDate: z.string().min(1) (ISO date string)
     - fileName: z.string().max(500).optional()
     - fileType: z.string().max(100).optional()
     - extractedText: z.string().max(100000).optional() (100KB limit)
     - estimatedHoursSaved: z.coerce.number().min(0).max(10000).optional()
   - Check artifact count: SELECT COUNT(*) FROM work_artifacts WHERE user_id = $userId. Return error if >= 50 ("Maximum 50 artifacts allowed")
   - Insert via sql template literal (same pattern as resume-share.ts)
   - Return `{ success: true, id }`

   **updateWorkArtifact(formData: FormData):**
   - Auth check
   - Zod validation: id (required string), title, description, category, artifactDate, estimatedHoursSaved (same as create but all optional except id)
   - UPDATE work_artifacts SET ... WHERE id = $id AND user_id = $userId (ownership check in WHERE)
   - Only update fields that are present in formData (build SET clause dynamically or use fixed fields)
   - Return `{ success: true }`

   **deleteWorkArtifact(formData: FormData):**
   - Auth check
   - Extract id from formData
   - DELETE FROM work_artifacts WHERE id = $id AND user_id = $userId
   - Return `{ success: true }`

2. Add `getUserArtifacts(userId: string)` to `apps/web/lib/portfolio-queries.ts`:
   - Define `WorkArtifactEntry` interface: { id, title, description, category, artifactDate (string), fileName, fileType, estimatedHoursSaved, suggestedSkillIds (string[]), createdAt (string) }
   - Query: SELECT id, title, description, category, artifact_date, file_name, file_type, estimated_hours_saved, suggested_skill_ids, created_at FROM work_artifacts WHERE user_id = $userId ORDER BY artifact_date DESC
   - Map rows to WorkArtifactEntry objects, serialize dates with .toISOString()
   - Export both the function and the interface
  </action>
  <verify>
    - `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit` passes
    - Server actions are importable: no "use server" re-export issues
  </verify>
  <done>Server actions (create, update, delete) and portfolio query (getUserArtifacts) are implemented with proper auth, tenant scoping, Zod validation, and the 50-artifact-per-user limit.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @everyskill/db build` passes
2. `cd /home/dev/projects/relay/apps/web && npx tsc --noEmit` passes
3. work_artifacts table exists in database with correct schema
4. Migration 0037 is tracked in _applied_migrations
</verification>

<success_criteria>
- work_artifacts table created with all specified columns, indexes, and RLS policy
- Schema exported from @everyskill/db with types and relations
- Server actions for CRUD operations are type-safe and auth-protected
- getUserArtifacts query function returns properly typed artifact entries
- All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/68-pre-llm-history/68-01-SUMMARY.md`
</output>
