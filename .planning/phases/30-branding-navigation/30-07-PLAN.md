---
phase: 30-branding-navigation
plan: 07
type: execute
wave: 2
depends_on: ["30-06"]
files_modified:
  - apps/web/middleware.ts
  - apps/web/app/api/check-domain/route.ts
  - docker/Caddyfile
autonomous: true

must_haves:
  truths:
    - "Middleware sets x-tenant-slug for vanity domain requests by looking up tenant"
    - "GET /api/check-domain validates vanity domains against tenants table"
    - "Caddy on-demand TLS block references the check-domain ask endpoint"
    - "Vanity domain requests resolve to the correct tenant context"
  artifacts:
    - path: "apps/web/middleware.ts"
      provides: "Vanity domain detection and tenant resolution"
      contains: "x-vanity-domain"
    - path: "apps/web/app/api/check-domain/route.ts"
      provides: "Domain validation endpoint for Caddy TLS"
      exports: ["GET"]
    - path: "docker/Caddyfile"
      provides: "On-demand TLS for vanity domains"
      contains: "on_demand"
  key_links:
    - from: "apps/web/middleware.ts"
      to: "@everyskill/db/services/tenant"
      via: "getTenantByVanityDomain lookup"
      pattern: "getTenantByVanityDomain"
    - from: "apps/web/app/api/check-domain/route.ts"
      to: "@everyskill/db/services/tenant"
      via: "getTenantByVanityDomain lookup"
      pattern: "getTenantByVanityDomain"
    - from: "docker/Caddyfile"
      to: "apps/web/app/api/check-domain/route.ts"
      via: "HTTP ask endpoint"
      pattern: "check-domain"
---

<objective>
Add vanity domain support to middleware, create Caddy check-domain API, and update Caddyfile.

Purpose: BRAND-03 requires paid tenants to use vanity URLs. Middleware must detect non-subdomain hostnames and resolve them as vanity domains. Caddy needs on-demand TLS with a validation endpoint to prevent abuse.
Output: Updated middleware, check-domain API route, updated Caddyfile.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@apps/web/middleware.ts
@docker/Caddyfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add vanity domain detection to middleware</name>
  <files>apps/web/middleware.ts</files>
  <action>
Modify `apps/web/middleware.ts`:

1. Add `/api/check-domain` to the exempt paths list (Caddy calls this without auth):
   ```typescript
   pathname === "/api/check-domain" ||
   ```
   Add this line alongside the existing exempt paths (after `pathname === "/api/track"`).

2. After the existing subdomain extraction (`const subdomain = extractSubdomain(host, ROOT_DOMAIN);`), add vanity domain detection:
   ```typescript
   // === Vanity domain detection ===
   // If no subdomain found and host doesn't match root domain patterns,
   // treat as a potential vanity domain and set a header for downstream resolution
   const hostname = host.split(":")[0];
   if (!subdomain && hostname !== "localhost" && !hostname.endsWith(".localhost") && hostname !== ROOT_DOMAIN && !hostname.endsWith(`.${ROOT_DOMAIN}`) && hostname !== `www.${ROOT_DOMAIN}`) {
     requestHeaders.set("x-vanity-domain", hostname);
   }
   ```

   Place this AFTER the `const requestHeaders = new Headers(req.headers);` line and AFTER the existing `if (subdomain)` block that sets `x-tenant-slug`.

The middleware does NOT do a DB lookup for vanity domains (that would import DB code into edge middleware which may not support it). Instead, it sets the `x-vanity-domain` header and lets the layout/page server components resolve the tenant. The `TenantBranding` component from plan 30-04 will need to also check this header in a future iteration, but the middleware's job is just to pass through the hostname.

Alternative approach if the middleware needs to fully resolve: Since the existing middleware already imports nothing from the DB, keep it lightweight. The vanity domain header signals to downstream code that a DB lookup is needed.
  </action>
  <verify>Run `cd /home/dev/projects/relay && npx tsc --noEmit -p apps/web/tsconfig.json 2>&1 | head -20`.</verify>
  <done>
Middleware exempts `/api/check-domain` from auth. Middleware sets `x-vanity-domain` header for hosts that are not the root domain or localhost, enabling downstream tenant resolution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create check-domain API + update Caddyfile</name>
  <files>apps/web/app/api/check-domain/route.ts, docker/Caddyfile</files>
  <action>
1. Create `apps/web/app/api/check-domain/route.ts`:
   ```typescript
   import { NextRequest, NextResponse } from "next/server";
   import { getTenantByVanityDomain } from "@everyskill/db/services/tenant";

   /**
    * Caddy on-demand TLS validation endpoint.
    * Caddy calls GET /api/check-domain?domain=example.com before issuing a certificate.
    * Returns 200 if the domain belongs to an active tenant, 404 otherwise.
    */
   export async function GET(req: NextRequest) {
     const domain = req.nextUrl.searchParams.get("domain");
     if (!domain) {
       return NextResponse.json({ error: "missing domain parameter" }, { status: 400 });
     }

     const tenant = await getTenantByVanityDomain(domain);
     if (!tenant) {
       return NextResponse.json({ error: "unknown domain" }, { status: 404 });
     }

     return NextResponse.json({ ok: true, tenant: tenant.slug }, { status: 200 });
   }
   ```

2. Update `docker/Caddyfile` to support vanity domains with on-demand TLS:
   ```
   {
       on_demand_tls {
           ask http://web:2000/api/check-domain
       }
   }

   *.everyskill.ai, everyskill.ai {
       tls {
           dns hetzner {env.HETZNER_DNS_API_TOKEN}
       }

       reverse_proxy web:2000 {
           header_up Host {host}
           header_up X-Real-IP {remote_host}
           header_up X-Forwarded-For {remote_host}
           header_up X-Forwarded-Proto {scheme}
       }
   }

   # Catch-all for vanity domains â€” on-demand TLS auto-provisions certificates
   # Only domains validated by /api/check-domain will get certificates
   https:// {
       tls {
           on_demand
       }
       reverse_proxy web:2000 {
           header_up Host {host}
           header_up X-Real-IP {remote_host}
           header_up X-Forwarded-For {remote_host}
           header_up X-Forwarded-Proto {scheme}
       }
   }
   ```

   Key: The `{` global options block `}` MUST be at the top of the Caddyfile, before any site blocks. The `ask` endpoint prevents certificate abuse (Pitfall #4 from research).
  </action>
  <verify>
Run `cd /home/dev/projects/relay && npx tsc --noEmit -p apps/web/tsconfig.json 2>&1 | head -20`.
Verify Caddyfile syntax: `cd /home/dev/projects/relay && docker run --rm -v "$PWD/docker/Caddyfile:/etc/caddy/Caddyfile:ro" caddy:2-alpine caddy validate --config /etc/caddy/Caddyfile 2>&1 | tail -5` (optional, only if Docker is available).
  </verify>
  <done>
`/api/check-domain` endpoint validates vanity domains against the tenants table. Caddyfile has on-demand TLS with ask endpoint validation and a catch-all block for vanity domains.
  </done>
</task>

</tasks>

<verification>
- `apps/web/middleware.ts` exempts `/api/check-domain` and sets `x-vanity-domain` header.
- `apps/web/app/api/check-domain/route.ts` exports GET handler.
- `docker/Caddyfile` has global `on_demand_tls` block with ask URL and `https://` catch-all.
- TypeScript compiles without errors.
</verification>

<success_criteria>
Vanity domain infrastructure is complete: middleware detects non-standard hostnames, check-domain API validates against DB, and Caddy auto-provisions TLS certificates only for known tenant domains.
</success_criteria>

<output>
After completion, create `.planning/phases/30-branding-navigation/30-07-SUMMARY.md`
</output>
