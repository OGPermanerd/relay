---
phase: 71-temporal-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/user-skill-views.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/relations/index.ts
  - packages/db/src/services/user-skill-views.ts
  - packages/db/src/services/index.ts
  - packages/db/src/migrations/0039_create_user_skill_views.sql
autonomous: true

must_haves:
  truths:
    - "user_skill_views table exists in database with correct columns and constraints"
    - "RLS policy tenant_isolation is active on user_skill_views"
    - "recordSkillView upserts correctly (insert on first view, update on repeat)"
    - "getUserViewsForSkills returns a Map of skillId -> view for batch badge queries"
    - "getWhatsNewForUser returns skills updated since the user last viewed them"
  artifacts:
    - path: "packages/db/src/schema/user-skill-views.ts"
      provides: "user_skill_views table definition with tenant isolation"
      contains: "userSkillViews"
    - path: "packages/db/src/services/user-skill-views.ts"
      provides: "UPSERT view, batch get views, what's new query, change detection helpers"
      exports: ["recordSkillView", "getUserView", "getUserViewsForSkills", "getWhatsNewForUser", "getVersionNumber", "countFeedbackSince"]
    - path: "packages/db/src/migrations/0039_create_user_skill_views.sql"
      provides: "Migration SQL for user_skill_views table"
      contains: "CREATE TABLE"
  key_links:
    - from: "packages/db/src/schema/user-skill-views.ts"
      to: "packages/db/src/schema/index.ts"
      via: "barrel export"
      pattern: 'export \* from "./user-skill-views"'
    - from: "packages/db/src/services/user-skill-views.ts"
      to: "packages/db/src/services/index.ts"
      via: "barrel export"
      pattern: 'export \* from "./user-skill-views"'
    - from: "packages/db/src/relations/index.ts"
      to: "packages/db/src/schema/user-skill-views.ts"
      via: "relation definition"
      pattern: "userSkillViewsRelations"
---

<objective>
Create the user_skill_views database table, migration, service layer with all query functions, and wire into barrel exports and relations.

Purpose: This is the data foundation for all temporal tracking features (TEMP-01 through TEMP-04). Every subsequent plan depends on this table and these service functions.
Output: New schema file, migration, service with 6 exported functions, updated barrel exports and relations.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/db/src/schema/user-preferences.ts (pattern: per-user table with tenant isolation, same structure)
@packages/db/src/schema/index.ts (barrel export pattern)
@packages/db/src/relations/index.ts (relation definition pattern)
@packages/db/src/services/index.ts (service barrel export pattern)
@packages/db/src/services/feedback.ts (pattern: counting feedback items by skill)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user_skill_views schema, migration, and relations</name>
  <files>
    packages/db/src/schema/user-skill-views.ts
    packages/db/src/schema/index.ts
    packages/db/src/relations/index.ts
    packages/db/src/migrations/0039_create_user_skill_views.sql
  </files>
  <action>
1. Create `packages/db/src/schema/user-skill-views.ts`:
   - Table `user_skill_views` with columns: id (text PK, gen_random_uuid default), tenant_id (text NOT NULL ref tenants.id), user_id (text NOT NULL ref users.id ON DELETE CASCADE), skill_id (text NOT NULL ref skills.id ON DELETE CASCADE), last_viewed_at (timestamptz precision 3, NOT NULL, defaultNow), last_viewed_version (integer, nullable), view_count (integer NOT NULL default 1)
   - Indexes: unique composite (tenant_id, user_id, skill_id), user_id, skill_id, tenant_id, composite (user_id, last_viewed_at)
   - RLS policy: `pgPolicy("tenant_isolation", { as: "restrictive", for: "all", using: sql\`tenant_id = current_setting('app.current_tenant_id', true)\`, withCheck: sql\`tenant_id = current_setting('app.current_tenant_id', true)\` })`
   - Export types: `UserSkillView = typeof userSkillViews.$inferSelect`, `NewUserSkillView = typeof userSkillViews.$inferInsert`
   - Follow exact pattern from `user-preferences.ts` for imports and structure

2. Add `export * from "./user-skill-views";` to `packages/db/src/schema/index.ts`

3. Add `userSkillViewsRelations` to `packages/db/src/relations/index.ts`:
   - Relations: `user` (one, ref users), `skill` (one, ref skills), `tenant` (one, ref tenants)
   - Follow the exact pattern of existing relation definitions (e.g., feedbackRelations)

4. Create migration `packages/db/src/migrations/0039_create_user_skill_views.sql`:
   - CREATE TABLE IF NOT EXISTS with all columns matching schema
   - CREATE INDEX for each index
   - ALTER TABLE ENABLE ROW LEVEL SECURITY
   - CREATE POLICY tenant_isolation matching the pgPolicy definition
   - Use exact SQL from the research (verified pattern)

5. Run migration: `pnpm --filter @everyskill/db db:migrate`
  </action>
  <verify>
    - `pnpm --filter @everyskill/db turbo typecheck` passes
    - Migration applies without errors (check migrate output)
    - Verify table exists: `psql everyskill -c "\d user_skill_views"`
  </verify>
  <done>
    user_skill_views table exists in database with all columns, indexes, RLS policy, schema is exported, relations are defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Create service layer with all query functions</name>
  <files>
    packages/db/src/services/user-skill-views.ts
    packages/db/src/services/index.ts
  </files>
  <action>
1. Create `packages/db/src/services/user-skill-views.ts` with these exported functions:

   a. `recordSkillView(tenantId: string, userId: string, skillId: string, currentVersion: number | null): Promise<void>`
      - UPSERT using `db.insert().onConflictDoUpdate()` on the unique (tenant_id, user_id, skill_id) constraint
      - On conflict: update lastViewedAt to new Date(), lastViewedVersion to currentVersion, increment viewCount via `sql\`view_count + 1\``
      - Early return if !db

   b. `getUserView(userId: string, skillId: string): Promise<UserSkillView | undefined>`
      - Select from userSkillViews where userId AND skillId match
      - Returns the single record or undefined
      - Used BEFORE recording a view to compute changes (critical order per Pitfall 3)

   c. `getUserViewsForSkills(userId: string, skillIds: string[]): Promise<Map<string, UserSkillView>>`
      - If skillIds is empty, return empty Map
      - Query all views for userId WHERE skillId IN (skillIds) using `inArray()`
      - Return Map keyed by skillId
      - This is the batch query for TEMP-02 "Updated" badges (avoids N+1 per Pitfall 1)

   d. `getWhatsNewForUser(userId: string, limit?: number): Promise<WhatsNewItem[]>`
      - Default limit = 10
      - Raw SQL query joining user_skill_views with skills
      - WHERE: user_id = userId AND skills.updated_at > usv.last_viewed_at AND skills.status = 'published' AND skills.updated_at >= 30 days ago
      - ORDER BY skills.updated_at DESC, LIMIT
      - Map results to WhatsNewItem interface: { skillId, skillName, skillSlug, category, updatedAt (ISO string), lastViewedAt (ISO string), viewCount }
      - Export the WhatsNewItem interface

   e. `getVersionNumber(versionId: string): Promise<number | null>`
      - Query skillVersions by id, return version number or null
      - Used when recording a view and when detecting version bumps

   f. `countFeedbackSince(skillId: string, since: Date): Promise<number>`
      - Query feedback table: count WHERE skillId matches AND createdAt > since
      - Used by change detection (TEMP-03)

2. Add `export * from "./user-skill-views";` to `packages/db/src/services/index.ts`

Import patterns: Use `import { db } from "../client"`, `import { userSkillViews } from "../schema/user-skill-views"`, `import { skills, skillVersions, feedback } from "../schema"`, `import { eq, and, sql, inArray, gt, desc } from "drizzle-orm"`
  </action>
  <verify>
    - `pnpm --filter @everyskill/db turbo typecheck` passes
    - `pnpm turbo typecheck` (full monorepo) passes
  </verify>
  <done>
    All 6 service functions exported and type-check: recordSkillView, getUserView, getUserViewsForSkills, getWhatsNewForUser, getVersionNumber, countFeedbackSince. WhatsNewItem interface exported.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo typecheck` passes across all packages
2. `psql everyskill -c "SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'user_skill_views' ORDER BY ordinal_position"` shows all 7 columns
3. `psql everyskill -c "SELECT policyname FROM pg_policies WHERE tablename = 'user_skill_views'"` shows tenant_isolation
4. Schema barrel exports userSkillViews, service barrel exports all 6 functions
</verification>

<success_criteria>
- user_skill_views table exists with correct schema, indexes, and RLS
- Migration 0039 applied successfully
- Service functions exported and type-check
- Full monorepo typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/71-temporal-tracking/71-01-SUMMARY.md`
</output>
