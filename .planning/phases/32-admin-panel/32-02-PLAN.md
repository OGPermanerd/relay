---
phase: 32-admin-panel
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - apps/web/auth.ts
  - apps/web/types/next-auth.d.ts
  - apps/web/lib/admin.ts
  - apps/web/app/(protected)/layout.tsx
  - apps/web/app/(protected)/admin/settings/page.tsx
  - apps/web/app/(protected)/admin/merge/page.tsx
  - apps/web/app/(protected)/admin/keys/page.tsx
  - apps/web/app/actions/admin-settings.ts
  - apps/web/app/actions/api-keys.ts
  - apps/web/app/actions/merge-skills.ts
  - apps/web/app/actions/delete-skill.ts
  - apps/web/app/(protected)/skills/[slug]/page.tsx
autonomous: true

must_haves:
  truths:
    - "JWT contains role claim, session exposes session.user.role"
    - "First user to sign in for a tenant gets role='admin' automatically"
    - "All admin page gates and server action checks use session.user.role instead of ADMIN_EMAILS env var"
    - "Nav bar shows Admin link based on session role, not email list"
  artifacts:
    - path: "apps/web/auth.ts"
      provides: "First-user-becomes-admin in jwt callback + role in JWT/session"
      contains: "isFirstUserInTenant"
    - path: "apps/web/lib/admin.ts"
      provides: "Role-based isAdmin() accepting session instead of email"
      contains: "session.user.role"
    - path: "apps/web/types/next-auth.d.ts"
      provides: "role field on Session.user and JWT types"
      contains: "role.*admin.*member"
  key_links:
    - from: "apps/web/auth.ts"
      to: "packages/db/src/services/user.ts"
      via: "isFirstUserInTenant import for first-user admin check"
      pattern: "isFirstUserInTenant"
    - from: "apps/web/lib/admin.ts"
      to: "apps/web/app/(protected)/admin/settings/page.tsx"
      via: "isAdmin(session) import for page gating"
      pattern: "isAdmin.*session"
---

<objective>
Wire role into auth flow (JWT callback assigns role on first sign-in, session exposes it) and replace ALL env-var-based admin checks with role-based checks across ~12 files.

Purpose: Completes ADMIN-02 (two roles per tenant) and enables all subsequent admin features to use role-based gating.
Output: Auth callback with first-user-becomes-admin logic, updated type augmentation, and all callers migrated from email-based to role-based admin checks.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/32-admin-panel/32-01-SUMMARY.md
@apps/web/auth.ts
@apps/web/types/next-auth.d.ts
@apps/web/lib/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth callback role assignment + type augmentation</name>
  <files>
    apps/web/auth.ts
    apps/web/types/next-auth.d.ts
    apps/web/lib/admin.ts
  </files>
  <action>
1. Update `apps/web/types/next-auth.d.ts`:
   - Add `role?: "admin" | "member"` to both `Session.user` and `JWT` interfaces

2. Update `apps/web/auth.ts` jwt callback:
   - Import `isFirstUserInTenant` and `setUserRole` from `@everyskill/db/services/user`
   - After the existing tenantId resolution block (the `if (account && profile?.email)` block around line 53), add first-user-admin logic:
     ```
     if (account && user?.id && token.tenantId) {
       const isFirst = await isFirstUserInTenant(token.tenantId as string);
       const role = isFirst ? "admin" as const : "member" as const;
       await setUserRole(user.id, role);
       token.role = role;
     }
     ```
   - In the existing lazy-migration block (the `if (!token.tenantId && token.id)` section around line 72), also lazy-load role:
     - Extend the select to include `role: users.role`
     - After setting tenantId, also set `token.role = dbUser.role`
   - Add a SEPARATE lazy-load block for role if token has tenantId but no role (handles existing sessions after migration):
     ```
     if (!token.role && token.id) {
       try {
         const [dbUser] = await db!.select({ role: users.role }).from(users).where(eq(users.id, token.id as string)).limit(1);
         if (dbUser?.role) token.role = dbUser.role;
       } catch { /* Non-fatal */ }
     }
     ```

3. Update `apps/web/auth.ts` session callback:
   - After setting tenantId on session.user, add: `if (token.role) { session.user.role = token.role as "admin" | "member"; }`

4. Rewrite `apps/web/lib/admin.ts`:
   - Remove the ADMIN_EMAILS env var approach entirely
   - New implementation:
     ```typescript
     import type { Session } from "next-auth";

     export function isAdmin(session: Session | null): boolean {
       return session?.user?.role === "admin";
     }
     ```
   - This changes the signature from `isAdmin(email: string)` to `isAdmin(session: Session | null)`. All callers must be updated in Task 2.
  </action>
  <verify>
`cd /home/dev/projects/relay && pnpm build` — TypeScript compiles. Check that `Session["user"]["role"]` type exists.
  </verify>
  <done>
JWT callback assigns role on first sign-in (first user = admin). Session exposes role. isAdmin() now accepts session object. Type augmentation includes role field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace all isAdmin(email) callers with isAdmin(session)</name>
  <files>
    apps/web/app/(protected)/layout.tsx
    apps/web/app/(protected)/admin/settings/page.tsx
    apps/web/app/(protected)/admin/merge/page.tsx
    apps/web/app/(protected)/admin/keys/page.tsx
    apps/web/app/actions/admin-settings.ts
    apps/web/app/actions/api-keys.ts
    apps/web/app/actions/merge-skills.ts
    apps/web/app/actions/delete-skill.ts
    apps/web/app/(protected)/skills/[slug]/page.tsx
  </files>
  <action>
All files currently call `isAdmin(session.user.email)` or `isAdmin(session?.user?.email)`. Change every call to `isAdmin(session)`.

Specific changes per file:

**Server components (page.tsx files) — already have `const session = await auth()`:**
- `admin/settings/page.tsx` line 9: `if (!session?.user?.id || !isAdmin(session))` (was `!isAdmin(session.user.email)`)
- `admin/merge/page.tsx` line 8: same pattern
- `admin/keys/page.tsx` line 10: same pattern

**Layout** `(protected)/layout.tsx` line 34:
- Change `{isAdmin(user.email) && ...}` to `{isAdmin(session) && ...}` (session is already available from line 12)

**Server actions** (these already call `await auth()` internally):
- `app/actions/admin-settings.ts`: 3 occurrences (lines ~21, ~76, ~116). Change `!isAdmin(session.user.email)` to `!isAdmin(session)`
- `app/actions/api-keys.ts`: 3 occurrences (lines ~43, ~100, ~206). Change `!isAdmin(session.user.email)` to `!isAdmin(session)`. For line ~100 which checks `existing.userId !== session.user.id && !isAdmin(session.user.email)`, change to `!isAdmin(session)`
- `app/actions/merge-skills.ts`: 2 occurrences (lines ~20, ~51). Same pattern
- `app/actions/delete-skill.ts`: 1 occurrence (line ~41). Change `isAdmin(session.user.email)` to `isAdmin(session)`

**Skill detail page** `skills/[slug]/page.tsx` line ~181:
- Change `isAdmin(session.user.email)` to `isAdmin(session)`. Note: session is available from `await auth()` earlier in the component.

After all changes, verify no remaining references to `ADMIN_EMAILS` in the codebase (remove the env var from .env.example if present).
  </action>
  <verify>
`cd /home/dev/projects/relay && pnpm build` compiles without errors. Grep confirms no remaining `isAdmin(session.user.email)` or `isAdmin(user.email)` calls:
`grep -r "isAdmin(session.user.email\|isAdmin(user.email" apps/web/` should return nothing.
Also confirm: `grep -r "ADMIN_EMAILS" apps/web/` should only appear in .env files (if at all), not in code.
  </verify>
  <done>
All ~12 isAdmin callers migrated from email-based to session-based checks. No remaining references to ADMIN_EMAILS in application code. Admin nav link in layout uses session.user.role. Build passes.
  </done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds with zero type errors
- `grep -r "ADMIN_EMAILS" apps/web/app apps/web/lib` returns nothing
- `grep -r "isAdmin(session.user.email" apps/web/` returns nothing
- Auth flow: first user in tenant gets role='admin' in JWT
- Session type includes `role?: "admin" | "member"`
</verification>

<success_criteria>
- JWT carries role claim, session exposes session.user.role
- First sign-in for a tenant auto-assigns admin role
- All 12+ admin check callsites use session-based role check
- ADMIN_EMAILS env var no longer referenced in application code
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/32-admin-panel/32-02-SUMMARY.md`
</output>
