---
phase: 03-mcp-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/db/src/schema/skills.ts
  - packages/db/src/schema/index.ts
  - apps/mcp/src/tools/index.ts
  - apps/mcp/src/tools/list.ts
  - apps/mcp/src/tools/search.ts
  - apps/mcp/src/tracking/events.ts
  - apps/mcp/src/server.ts
autonomous: true

must_haves:
  truths:
    - "list_skills tool returns available skills"
    - "search_skills tool filters by query"
    - "Tool invocations are recorded in usageEvents table"
  artifacts:
    - path: "packages/db/src/schema/skills.ts"
      provides: "Skills table with name, description, category, content"
      contains: "pgTable"
    - path: "apps/mcp/src/tools/list.ts"
      provides: "list_skills MCP tool"
      contains: "registerTool"
    - path: "apps/mcp/src/tools/search.ts"
      provides: "search_skills MCP tool"
      contains: "registerTool"
    - path: "apps/mcp/src/tracking/events.ts"
      provides: "trackUsage function for analytics"
      contains: "usageEvents"
  key_links:
    - from: "apps/mcp/src/tools/list.ts"
      to: "apps/mcp/src/tracking/events.ts"
      via: "trackUsage call"
      pattern: "trackUsage"
    - from: "apps/mcp/src/tools/search.ts"
      to: "packages/db/src/schema/skills.ts"
      via: "database query"
      pattern: "skills"
---

<objective>
Create the skills schema for testing, then implement search_skills and list_skills MCP tools with integrated usage tracking.

Purpose: Users can discover skills from Claude Code - this is the primary read path for the marketplace.
Output: Working list/search tools that query skills and track usage.
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-mcp-integration/03-RESEARCH.md
@.planning/phases/03-mcp-integration/03-01-SUMMARY.md

# Existing code
@packages/db/src/schema/users.ts
@packages/db/src/schema/usage-events.ts
@apps/mcp/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create minimal skills schema</name>
  <files>
    packages/db/src/schema/skills.ts
    packages/db/src/schema/index.ts
  </files>
  <action>
**packages/db/src/schema/skills.ts:**
```typescript
import { pgTable, text, timestamp, integer } from "drizzle-orm/pg-core";
import { users } from "./users";

/**
 * Skills table - minimal schema for MCP testing
 * Full schema will be expanded in Phase 4 (Data Model)
 */
export const skills = pgTable("skills", {
  id: text("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull(),
  slug: text("slug").notNull().unique(),
  description: text("description").notNull(),
  category: text("category").notNull(), // prompt, workflow, agent, mcp
  content: text("content").notNull(), // The actual skill content (markdown)
  hoursSaved: integer("hours_saved").default(1), // Estimated hours saved per use
  authorId: text("author_id").references(() => users.id),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export type Skill = typeof skills.$inferSelect;
export type NewSkill = typeof skills.$inferInsert;
```

**packages/db/src/schema/index.ts:**
Add export: `export * from "./skills";`

Run `pnpm --filter @everyskill/db db:push` to create skills table.

Then seed 3 test skills for development:
```sql
-- Run via psql or db:studio
INSERT INTO skills (id, name, slug, description, category, content, hours_saved) VALUES
  (gen_random_uuid(), 'Code Review Assistant', 'code-review', 'Automated code review with best practices', 'prompt', '# Code Review\n\nReview this code for...', 2),
  (gen_random_uuid(), 'API Documentation Generator', 'api-docs', 'Generate OpenAPI docs from code', 'workflow', '# API Docs Workflow\n\n1. Analyze endpoints...', 4),
  (gen_random_uuid(), 'Test Writer', 'test-writer', 'Generate comprehensive test cases', 'prompt', '# Test Writer\n\nWrite tests for...', 3);
```
  </action>
  <verify>
    `pnpm --filter @everyskill/db typecheck` passes
    `pnpm --filter @everyskill/db db:push` shows skills table created
  </verify>
  <done>
    skills table exists with test data for MCP tool development
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement usage tracking helper</name>
  <files>
    apps/mcp/src/tracking/events.ts
  </files>
  <action>
**apps/mcp/src/tracking/events.ts:**
```typescript
import { db } from "@everyskill/db";
import { usageEvents, type NewUsageEvent } from "@everyskill/db/schema";

/**
 * Track MCP tool usage for analytics
 * Called within each tool handler after successful execution
 */
export async function trackUsage(event: Omit<NewUsageEvent, "id" | "createdAt">): Promise<void> {
  try {
    await db.insert(usageEvents).values(event);
  } catch (error) {
    // Log but don't fail the tool call - tracking is non-critical
    console.error("Failed to track usage:", error);
  }
}

export type { NewUsageEvent };
```

This provides a simple `trackUsage()` function that all tools will call. Tracking failures are logged but don't break tool execution.
  </action>
  <verify>
    `pnpm --filter @everyskill/mcp typecheck` passes
    Import resolves: @everyskill/db and @everyskill/db/schema
  </verify>
  <done>
    trackUsage helper exists and can insert usage events
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement list_skills and search_skills tools</name>
  <files>
    apps/mcp/src/tools/list.ts
    apps/mcp/src/tools/search.ts
    apps/mcp/src/tools/index.ts
    apps/mcp/src/server.ts
  </files>
  <action>
**apps/mcp/src/tools/list.ts:**
```typescript
import { z } from "zod";
import { server } from "../server.js";
import { db } from "@everyskill/db";
import { skills } from "@everyskill/db/schema";
import { trackUsage } from "../tracking/events.js";

server.registerTool(
  "list_skills",
  {
    description: "List all available skills in the Relay marketplace. Returns skill ID, name, description, category, and estimated hours saved.",
    inputSchema: {
      category: z.enum(["prompt", "workflow", "agent", "mcp"]).optional()
        .describe("Filter by skill category"),
      limit: z.number().min(1).max(50).default(20)
        .describe("Maximum number of results"),
    },
  },
  async ({ category, limit }) => {
    const results = await db.query.skills.findMany({
      where: category ? (s, { eq }) => eq(s.category, category) : undefined,
      limit,
      columns: {
        id: true,
        name: true,
        description: true,
        category: true,
        hoursSaved: true,
      },
    });

    await trackUsage({
      toolName: "list_skills",
      metadata: { category, limit, resultCount: results.length },
    });

    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          count: results.length,
          skills: results,
        }, null, 2),
      }],
    };
  }
);
```

**apps/mcp/src/tools/search.ts:**
```typescript
import { z } from "zod";
import { server } from "../server.js";
import { db } from "@everyskill/db";
import { skills } from "@everyskill/db/schema";
import { ilike, or } from "drizzle-orm";
import { trackUsage } from "../tracking/events.js";

server.registerTool(
  "search_skills",
  {
    description: "Search for skills in the Relay marketplace by query. Matches against name and description.",
    inputSchema: {
      query: z.string().min(1).describe("Search query (matches name, description)"),
      category: z.enum(["prompt", "workflow", "agent", "mcp"]).optional()
        .describe("Filter by skill category"),
      limit: z.number().min(1).max(25).default(10)
        .describe("Maximum number of results"),
    },
  },
  async ({ query, category, limit }) => {
    const searchPattern = `%${query}%`;

    let whereClause = or(
      ilike(skills.name, searchPattern),
      ilike(skills.description, searchPattern)
    );

    // Note: Category filter would require AND with the or() clause
    // For simplicity, we filter in-memory for now
    const allResults = await db.query.skills.findMany({
      where: whereClause,
      limit: limit * 2, // Over-fetch for category filter
      columns: {
        id: true,
        name: true,
        description: true,
        category: true,
        hoursSaved: true,
      },
    });

    const results = category
      ? allResults.filter(s => s.category === category).slice(0, limit)
      : allResults.slice(0, limit);

    await trackUsage({
      toolName: "search_skills",
      metadata: { query, category, resultCount: results.length },
    });

    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          query,
          count: results.length,
          skills: results,
        }, null, 2),
      }],
    };
  }
);
```

**apps/mcp/src/tools/index.ts:**
```typescript
// Import tools to register them with the server
import "./list.js";
import "./search.js";
```

**Update apps/mcp/src/server.ts:**
Add after server creation: `import "./tools/index.js";`

The final server.ts should look like:
```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

export const server = new McpServer({
  name: "everyskill-skills",
  version: "1.0.0",
});

// Register all tools
import "./tools/index.js";
```
  </action>
  <verify>
    `pnpm --filter @everyskill/mcp typecheck` passes
    `pnpm --filter @everyskill/mcp dev` starts without errors
  </verify>
  <done>
    list_skills and search_skills tools registered and track usage
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @everyskill/db typecheck` - DB compiles with skills schema
2. `pnpm --filter @everyskill/mcp typecheck` - MCP compiles with tools
3. `pnpm --filter @everyskill/mcp dev` starts server (tools registered)
4. Database has skills table with seed data
</verification>

<success_criteria>
- skills table exists in database with test data
- list_skills tool returns skills (filterable by category)
- search_skills tool filters by query string
- Both tools log usage events to database
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-integration/03-02-SUMMARY.md`
</output>
