---
phase: 37-review-notifications
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/emails/review-notification.tsx
  - apps/web/lib/notifications.ts
autonomous: true

must_haves:
  truths:
    - "notifyReviewEvent dispatches in-app and email notifications respecting reviewNotificationsInApp and reviewNotificationsEmail preferences"
    - "ReviewNotificationEmail renders differently for each of the 5 review event types"
    - "Notification dispatch is fire-and-forget (catches errors, never throws)"
  artifacts:
    - path: "apps/web/emails/review-notification.tsx"
      provides: "Email template for review notifications"
      exports: ["default"]
    - path: "apps/web/lib/notifications.ts"
      provides: "notifyReviewEvent dispatch function"
      exports: ["notifyReviewEvent"]
  key_links:
    - from: "apps/web/lib/notifications.ts"
      to: "@everyskill/db"
      via: "createNotification and getOrCreatePreferences imports"
      pattern: "createNotification|getOrCreatePreferences"
    - from: "apps/web/lib/notifications.ts"
      to: "apps/web/emails/review-notification.tsx"
      via: "import and render()"
      pattern: "ReviewNotificationEmail"
---

<objective>
Create the review notification email template and the notifyReviewEvent dispatch function.

Purpose: This is the core dispatch logic that wiring (Plan 03) will call. Follows the exact notifyGroupingProposal pattern.
Output: ReviewNotificationEmail component, notifyReviewEvent function added to apps/web/lib/notifications.ts.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ReviewNotificationEmail template</name>
  <files>apps/web/emails/review-notification.tsx</files>
  <action>
Create `apps/web/emails/review-notification.tsx` following the exact pattern of `apps/web/emails/grouping-proposal.tsx`.

The template uses `EmailLayout` from `./components/email-layout`, `Section`, `Text`, `Button`, `Link`, `Hr` from `@react-email/components`.

Props interface:
```typescript
export interface ReviewNotificationEmailProps {
  recipientName: string;
  type: "review_submitted" | "review_approved" | "review_rejected"
      | "review_changes_requested" | "review_published";
  skillName: string;
  notes?: string;        // admin feedback (for rejected, changes_requested)
  reviewerName?: string; // admin who took action
  actionUrl: string;
}
```

Conditional rendering based on `type`:
- `review_submitted`: Heading "Skill Submitted for Review", body "**{skillName}** has been submitted for review by {reviewerName}.", CTA "Review Now" linking to actionUrl
- `review_approved`: Heading "Skill Approved", body "Your skill **{skillName}** has been approved by {reviewerName}.", if notes: show notes in quote block, CTA "View Skill"
- `review_rejected`: Heading "Skill Rejected", body "Your skill **{skillName}** has been rejected by {reviewerName}.", show notes in quote block (required for rejections), CTA "Edit Skill"
- `review_changes_requested`: Heading "Changes Requested", body "Changes have been requested for your skill **{skillName}** by {reviewerName}.", show notes in quote block, CTA "Edit Skill"
- `review_published`: Heading "Skill Published", body "Your skill **{skillName}** is now published and available to everyone.", CTA "View Skill"

Use the same CSS-in-JS style objects as grouping-proposal.tsx (headingStyle, paragraphStyle, hrStyle, quoteBlockStyle, quoteTextStyle, ctaSectionStyle, buttonStyle, footerNoteStyle, linkStyle). Copy them exactly.

Use `previewText` that summarizes the event, e.g., for review_submitted: `"${skillName} submitted for review"`.
  </action>
  <verify>
    Run `pnpm --filter web exec tsc --noEmit` to check the template compiles.
  </verify>
  <done>ReviewNotificationEmail renders conditionally for all 5 review event types with proper heading, body, optional notes block, and CTA button.</done>
</task>

<task type="auto">
  <name>Task 2: notifyReviewEvent dispatch function</name>
  <files>apps/web/lib/notifications.ts</files>
  <action>
Add `notifyReviewEvent` to `apps/web/lib/notifications.ts`, following the exact pattern of `notifyGroupingProposal`.

Add imports at the top of the file:
```typescript
import ReviewNotificationEmail from "@/emails/review-notification";
```

Add these constants:
```typescript
const REVIEW_TITLES: Record<string, string> = {
  review_submitted: "Skill Submitted for Review",
  review_approved: "Skill Approved",
  review_rejected: "Skill Rejected",
  review_changes_requested: "Changes Requested",
  review_published: "Skill Published",
};

function buildReviewMessage(type: string, skillName: string, reviewerName?: string): string {
  switch (type) {
    case "review_submitted":
      return `"${skillName}" has been submitted for review${reviewerName ? ` by ${reviewerName}` : ""}`;
    case "review_approved":
      return `Your skill "${skillName}" has been approved${reviewerName ? ` by ${reviewerName}` : ""}`;
    case "review_rejected":
      return `Your skill "${skillName}" has been rejected${reviewerName ? ` by ${reviewerName}` : ""}`;
    case "review_changes_requested":
      return `Changes requested on your skill "${skillName}"${reviewerName ? ` by ${reviewerName}` : ""}`;
    case "review_published":
      return `Your skill "${skillName}" is now published`;
    default:
      return `Update on "${skillName}"`;
  }
}

function buildReviewActionUrl(type: string, skillSlug: string): string {
  switch (type) {
    case "review_submitted":
      return "/admin/reviews";
    case "review_approved":
    case "review_published":
      return `/skills/${skillSlug}`;
    case "review_rejected":
    case "review_changes_requested":
      return "/my-skills";
    default:
      return "/";
  }
}
```

Add the dispatch function:
```typescript
export async function notifyReviewEvent(params: {
  tenantId: string;
  recipientId: string;
  recipientEmail: string;
  recipientName: string;
  type: "review_submitted" | "review_approved" | "review_rejected"
      | "review_changes_requested" | "review_published";
  skillName: string;
  skillSlug: string;
  notes?: string;
  reviewerName?: string;
}): Promise<void> {
  try {
    const preferences = await getOrCreatePreferences(params.recipientId, params.tenantId);

    // In-app notification (respects single toggle for all review types per RVNT-06)
    if (preferences?.reviewNotificationsInApp !== false) {
      await createNotification({
        tenantId: params.tenantId,
        userId: params.recipientId,
        type: params.type,
        title: REVIEW_TITLES[params.type] || "Review Update",
        message: buildReviewMessage(params.type, params.skillName, params.reviewerName),
        actionUrl: buildReviewActionUrl(params.type, params.skillSlug),
        metadata: { skillName: params.skillName, notes: params.notes },
      });
    }

    // Email notification (respects single toggle per RVNT-06)
    if (preferences?.reviewNotificationsEmail !== false) {
      const actionUrl = `${process.env.NEXT_PUBLIC_APP_URL || "http://localhost:2000"}${buildReviewActionUrl(params.type, params.skillSlug)}`;
      const html = await render(
        ReviewNotificationEmail({
          recipientName: params.recipientName || "there",
          type: params.type,
          skillName: params.skillName,
          notes: params.notes,
          reviewerName: params.reviewerName,
          actionUrl,
        })
      );

      await sendEmail({
        to: params.recipientEmail,
        subject: REVIEW_TITLES[params.type] || "Review Update",
        html,
      });
    }
  } catch (error) {
    console.error("[NOTIFICATION ERROR] Failed to dispatch review notification:", error);
  }
}
```

Key points:
- Fire-and-forget: catch errors, never throw
- Checks `reviewNotificationsInApp` / `reviewNotificationsEmail` preferences (single toggle for all review types per RVNT-06)
- Uses `getOrCreatePreferences` (already imported at top of file)
- Uses `createNotification` (already imported at top of file)
- Uses `sendEmail` (already imported at top of file)
- Uses `render` (already imported at top of file)
  </action>
  <verify>
    Run `pnpm --filter web exec tsc --noEmit` to confirm the function and all imports compile cleanly.
  </verify>
  <done>notifyReviewEvent function exists in apps/web/lib/notifications.ts, handles all 5 review types, respects preferences, and follows fire-and-forget pattern.</done>
</task>

</tasks>

<verification>
- `pnpm --filter web exec tsc --noEmit` passes
- ReviewNotificationEmail template exists and exports a default function
- notifyReviewEvent is exported from apps/web/lib/notifications.ts
- Both functions reference the correct preference fields (reviewNotificationsInApp, reviewNotificationsEmail)
</verification>

<success_criteria>
The dispatch function and email template are ready for wiring into server actions. notifyReviewEvent handles all 5 event types with preference checks and fire-and-forget error handling.
</success_criteria>

<output>
After completion, create `.planning/phases/37-review-notifications/37-02-SUMMARY.md`
</output>
