---
phase: 56-in-claude-feedback-collection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/services/skill-feedback.ts
  - packages/db/src/services/index.ts
  - apps/web/app/api/feedback/route.ts
  - apps/web/middleware.ts
  - apps/mcp/src/tools/feedback.ts
  - apps/mcp/src/tools/everyskill.ts
autonomous: true

must_haves:
  truths:
    - "MCP feedback action accepts thumbs_up/thumbs_down with optional comment and persists to skill_feedback table"
    - "/api/feedback endpoint validates with Zod, requires Bearer auth, enforces rate limiting, and sanitizes comments"
    - "Middleware exempts /api/feedback path so external clients can reach it without session auth"
    - "Feedback insertion updates denormalized totalFeedback and positiveFeedbackPct on skills table"
  artifacts:
    - path: "packages/db/src/services/skill-feedback.ts"
      provides: "insertFeedback and updateSkillFeedbackAggregates functions"
      exports: ["insertFeedback", "updateSkillFeedbackAggregates"]
    - path: "apps/web/app/api/feedback/route.ts"
      provides: "POST endpoint with Bearer auth, Zod, rate limiting, sanitization"
      exports: ["POST"]
    - path: "apps/mcp/src/tools/feedback.ts"
      provides: "handleFeedback MCP action handler"
      exports: ["handleFeedback"]
    - path: "apps/mcp/src/tools/everyskill.ts"
      provides: "Unified tool with feedback action added to ACTIONS enum and router"
  key_links:
    - from: "apps/mcp/src/tools/everyskill.ts"
      to: "apps/mcp/src/tools/feedback.ts"
      via: "import and route in switch statement"
      pattern: "case \"feedback\":"
    - from: "apps/web/app/api/feedback/route.ts"
      to: "packages/db/src/services/skill-feedback.ts"
      via: "insertFeedback call"
      pattern: "insertFeedback"
    - from: "apps/mcp/src/tools/feedback.ts"
      to: "packages/db/src/services/skill-feedback.ts"
      via: "direct DB insertion via service"
      pattern: "insertFeedback"
    - from: "apps/web/middleware.ts"
      to: "apps/web/app/api/feedback/route.ts"
      via: "path exemption"
      pattern: "pathname === \"/api/feedback\""
---

<objective>
Create the feedback data service, API endpoint, and MCP action so users can submit thumbs up/down feedback on skills from Claude or external clients.

Purpose: FDBK-01, FDBK-03, FDBK-04 -- the core data pipeline for feedback collection. MCP handler inserts directly to DB; API endpoint serves external clients with auth, validation, and rate limiting.
Output: Feedback service, API route, MCP action handler, middleware exemption.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Pattern references:
@apps/web/app/api/track/route.ts
@apps/mcp/src/tools/everyskill.ts
@apps/mcp/src/auth.ts
@packages/db/src/schema/skill-feedback.ts
@packages/db/src/schema/skills.ts
@apps/web/middleware.ts
@packages/db/src/services/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill-feedback DB service with insert + aggregate update</name>
  <files>
    packages/db/src/services/skill-feedback.ts
    packages/db/src/services/index.ts
  </files>
  <action>
Create `packages/db/src/services/skill-feedback.ts` with two exported functions:

**1. `insertFeedback(params)`** -- Insert a row into `skill_feedback` and update aggregates:
```typescript
interface InsertFeedbackParams {
  tenantId: string;
  skillId: string;
  userId?: string | null;
  feedbackType: "thumbs_up" | "thumbs_down";
  comment?: string | null;
  source?: string; // default "web"
  usageEventId?: string | null;
}
```
- Import `db` from `@everyskill/db` (use `import { db } from "../client.js"` since this is inside the package)
- Import `skillFeedback` from `../schema/skill-feedback.js` and `skills` from `../schema/skills.js`
- Import `eq, sql` from `drizzle-orm`
- Calculate `sentiment`: thumbs_up = 1, thumbs_down = -1
- Insert into `skillFeedback` using `db.insert(skillFeedback).values({...})`
- After insert, call `updateSkillFeedbackAggregates(skillId)`
- Return the inserted feedback id

**2. `updateSkillFeedbackAggregates(skillId: string)`** -- Recalculate denormalized columns:
- Query `skill_feedback` for the given skillId using:
  ```sql
  count(*)::int as total
  count(*) FILTER (WHERE feedback_type IN ('thumbs_up', 'thumbs_down'))::int as votesTotal
  count(*) FILTER (WHERE feedback_type = 'thumbs_up')::int as positive
  ```
  Note: Only count thumbs_up/thumbs_down for percentage (not suggestions, bug reports, etc.)
- Calculate `positiveFeedbackPct = votesTotal > 0 ? Math.round((positive / votesTotal) * 100) : null`
- Update `skills` set `totalFeedback = total, positiveFeedbackPct = pct, updatedAt = new Date()` where `id = skillId`
- Handle `db` being null (return early)

Follow the exact pattern of existing services like `skill-metrics.ts` (`updateSkillRating` does the same recalculate-and-update pattern).

**Update `packages/db/src/services/index.ts`** -- Add exports at the bottom:
```typescript
export { insertFeedback, updateSkillFeedbackAggregates } from "./skill-feedback";
```
  </action>
  <verify>Run `cd /home/dev/projects/relay && npx tsc --noEmit -p packages/db/tsconfig.json 2>&1 | head -20` -- must compile with zero errors</verify>
  <done>skill-feedback.ts service exists with insertFeedback and updateSkillFeedbackAggregates, both exported from services/index.ts, TypeScript compiles cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Create /api/feedback endpoint, add middleware exemption, create MCP feedback action handler, wire into everyskill tool</name>
  <files>
    apps/web/app/api/feedback/route.ts
    apps/web/middleware.ts
    apps/mcp/src/tools/feedback.ts
    apps/mcp/src/tools/everyskill.ts
  </files>
  <action>
**1. Create `apps/web/app/api/feedback/route.ts`** -- Mirror `/api/track/route.ts` exactly:
- Import: `NextRequest`, `NextResponse` from `next/server`; `validateApiKey` from `@everyskill/db/services/api-keys`; `insertFeedback` from `@everyskill/db/services/skill-feedback`; `checkRateLimit` from `@/lib/rate-limiter`; `sanitizePayload` from `@/lib/sanitize-payload`; `z` from `zod`
- Define Zod schema:
  ```typescript
  const feedbackSchema = z.object({
    skill_id: z.string().min(1, "skill_id required"),
    feedback_type: z.enum(["thumbs_up", "thumbs_down"]),
    comment: z.string().max(2000).optional(),
  });
  ```
- Export `POST` handler following the exact `/api/track` pattern:
  1. Extract Bearer token from Authorization header (401 if missing)
  2. `validateApiKey(apiKey)` (401 if invalid)
  3. `checkRateLimit(keyResult.keyId)` (429 if limited)
  4. Parse JSON body (400 if invalid)
  5. Validate with `feedbackSchema.safeParse(body)` (400 if invalid, return `parsed.error.flatten().fieldErrors`)
  6. Sanitize comment: `if (parsed.data.comment) sanitizePayload(parsed.data.comment).sanitized` -- use the `.sanitized` property
  7. Call `insertFeedback({ tenantId: keyResult.tenantId, skillId: parsed.data.skill_id, userId: keyResult.userId, feedbackType: parsed.data.feedback_type, comment: sanitizedComment, source: "api" })`
  8. Return `new NextResponse(null, { status: 200 })`

**2. Update `apps/web/middleware.ts`** -- Add `/api/feedback` to exempt paths:
Add `pathname === "/api/feedback"` to the existing if block, right after the `pathname === "/api/track"` line. Follow the exact same pattern.

**3. Create `apps/mcp/src/tools/feedback.ts`** -- MCP action handler:
- Import `db` from `@everyskill/db` (same pattern as other MCP handlers)
- Import `skillFeedback` from `@everyskill/db/schema/skill-feedback`
- Import `skills` from `@everyskill/db/schema/skills`
- Import `eq, sql` from `drizzle-orm`
- Import `getUserId, getTenantId` from `../auth.js`
- Import `trackUsage` from `../tracking/events.js`
- Import `sanitizePayload` from the web app? No -- MCP server can't import from web app. Instead, inline a minimal sanitization or skip (the API endpoint already sanitizes for that path). For MCP direct DB path: import sanitizePayload from `@everyskill/db` if available, otherwise just do basic validation (trim, max 2000 chars).

Actually, check: does the MCP server have access to `sanitizePayload`? The sanitize-payload utility is in `apps/web/lib/sanitize-payload.ts`. Since MCP can't import from web, do a lightweight inline sanitization: trim the comment, truncate to 2000 chars. The comment is low-risk since it comes from the user intentionally. The API endpoint handles full sanitization for its path.

Export `handleFeedback`:
```typescript
export async function handleFeedback({
  skillId,
  feedbackType,
  comment,
  userId,
}: {
  skillId: string;
  feedbackType: "thumbs_up" | "thumbs_down";
  comment?: string;
  userId?: string;
})
```

Implementation:
- Check `db` not null (return error content if null)
- Get `tenantId` from `getTenantId()` (return error if null)
- Sanitize comment: `comment?.trim().slice(0, 2000)` (simple truncation)
- Insert directly into `skillFeedback` table:
  ```typescript
  await db.insert(skillFeedback).values({
    tenantId,
    skillId,
    userId: userId ?? null,
    feedbackType,
    sentiment: feedbackType === "thumbs_up" ? 1 : -1,
    comment: sanitizedComment ?? null,
    source: "mcp",
  });
  ```
- Update denormalized aggregates -- inline the recalculation (same logic as the DB service):
  ```typescript
  const stats = await db.select({
    total: sql<number>`count(*)::int`,
    positive: sql<number>`count(*) FILTER (WHERE feedback_type = 'thumbs_up')::int`,
    votes: sql<number>`count(*) FILTER (WHERE feedback_type IN ('thumbs_up', 'thumbs_down'))::int`,
  }).from(skillFeedback).where(eq(skillFeedback.skillId, skillId));

  const total = stats[0]?.total ?? 0;
  const votes = stats[0]?.votes ?? 0;
  const positive = stats[0]?.positive ?? 0;
  const pct = votes > 0 ? Math.round((positive / votes) * 100) : null;

  await db.update(skills).set({
    totalFeedback: total,
    positiveFeedbackPct: pct,
    updatedAt: new Date(),
  }).where(eq(skills.id, skillId));
  ```
- Track usage via `trackUsage({ toolName: "feedback", skillId, userId: getUserId() ?? undefined, metadata: { feedbackType, hasComment: !!comment } }, { skipIncrement: true })` -- check if trackUsage accepts skipIncrement, if not just call without it.
- Return success content:
  ```typescript
  return {
    content: [{
      type: "text" as const,
      text: JSON.stringify({
        success: true,
        message: `Feedback recorded: ${feedbackType === "thumbs_up" ? "thumbs up" : "thumbs down"}${comment ? " with comment" : ""}`,
      }),
    }],
  };
  ```

**4. Update `apps/mcp/src/tools/everyskill.ts`** -- Wire feedback action:
- Add `import { handleFeedback } from "./feedback.js";` to imports
- Add `"feedback"` to the ACTIONS array (after "check_status")
- Update the `z.enum(ACTIONS).describe(...)` description string to include "feedback" in the list
- Add to EverySkillInputSchema: `feedbackType: z.enum(["thumbs_up", "thumbs_down"]).optional().describe("Feedback type (required for: feedback)")` and `comment: z.string().optional().describe("Optional feedback comment (used by: feedback, create)")` -- note `comment` already exists as a concept in the create flow? Check if it exists. If not, add it.
- Add `feedbackType` and `comment` to the `EverySkillArgs` type interface
- Add case to switch:
  ```typescript
  case "feedback": {
    if (!args.skillId) return missingParam(action, "skillId");
    if (!args.feedbackType) return missingParam(action, "feedbackType");
    return handleFeedback({
      skillId: args.skillId,
      feedbackType: args.feedbackType,
      comment: args.comment,
      userId,
    });
  }
  ```
  Place this case before the `default` case.
  </action>
  <verify>
1. Run `cd /home/dev/projects/relay && npx tsc --noEmit -p apps/mcp/tsconfig.json 2>&1 | head -20` -- MCP compiles
2. Run `cd /home/dev/projects/relay && npx tsc --noEmit -p apps/web/tsconfig.json 2>&1 | head -30` -- Web app compiles
3. Verify middleware exemption: `grep -n "api/feedback" /home/dev/projects/relay/apps/web/middleware.ts`
4. Verify ACTIONS includes feedback: `grep -n "feedback" /home/dev/projects/relay/apps/mcp/src/tools/everyskill.ts`
  </verify>
  <done>
- /api/feedback endpoint exists with Bearer auth, Zod validation, rate limiting, and comment sanitization
- Middleware exempts /api/feedback from session auth
- MCP feedback action handler inserts directly to DB with aggregate updates
- everyskill tool routes "feedback" action with required skillId and feedbackType params
- Both apps/mcp and apps/web compile cleanly
  </done>
</task>

</tasks>

<verification>
1. MCP: `everyskill action:feedback skillId:xxx feedbackType:thumbs_up` routes to handleFeedback and inserts a row
2. API: `curl -X POST http://localhost:2002/api/feedback -H "Authorization: Bearer $KEY" -H "Content-Type: application/json" -d '{"skill_id":"xxx","feedback_type":"thumbs_up","comment":"great skill"}' ` returns 200
3. API: Missing auth returns 401, invalid payload returns 400, rate limited returns 429
4. After feedback insert, `skills.totalFeedback` and `skills.positiveFeedbackPct` are updated
5. Middleware passes through `/api/feedback` without redirect
</verification>

<success_criteria>
- MCP feedback action handles thumbs_up/thumbs_down with optional comment, persists to skill_feedback table
- /api/feedback endpoint validates, authenticates, rate-limits, sanitizes, and persists feedback
- Denormalized aggregates on skills table update after each feedback insert
- TypeScript compiles cleanly for both apps/mcp and apps/web
</success_criteria>

<output>
After completion, create `.planning/phases/56-in-claude-feedback-collection/56-01-SUMMARY.md`
</output>
