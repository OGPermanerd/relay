"use server";

import { auth } from "@/auth";
import { db, skills } from "@everyskill/db";
import { getOrCreateUserPreferences } from "@everyskill/db/services/user-preferences";
import { PREFERENCES_DEFAULTS } from "@/lib/preferences-defaults";
import { eq, and, desc } from "drizzle-orm";

/** Human-readable labels for sort options */
const SORT_LABELS: Record<string, string> = {
  uses: "Most Used",
  quality: "Highest Quality",
  rating: "Best Rated",
  days_saved: "Most Time Saved",
};

export async function generateClaudeMd(): Promise<{ markdown: string } | { error: string }> {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return { error: "Must be signed in" };
    }

    const tenantId = session.user.tenantId;
    if (!tenantId) {
      return { error: "Tenant not resolved" };
    }

    const userId = session.user.id;
    const userName = session.user.name || "User";

    // Fetch user preferences
    const prefs = await getOrCreateUserPreferences(userId, tenantId);
    const preferences = prefs ? { ...PREFERENCES_DEFAULTS, ...prefs } : PREFERENCES_DEFAULTS;

    // Query published skills ordered by most used
    if (!db) {
      return { error: "Database not configured" };
    }

    const publishedSkills = await db
      .select({
        name: skills.name,
        category: skills.category,
        description: skills.description,
        tags: skills.tags,
        totalUses: skills.totalUses,
        hoursSaved: skills.hoursSaved,
      })
      .from(skills)
      .where(and(eq(skills.authorId, userId), eq(skills.status, "published")))
      .orderBy(desc(skills.totalUses));

    // Build markdown
    const date = new Date().toISOString().split("T")[0];
    const sections: string[] = [];

    sections.push(`# ${userName}'s AI Configuration`);
    sections.push("");
    sections.push(`Generated from EverySkill profile on ${date}.`);

    // About Me section (only if workflow notes exist)
    if (preferences.claudeMdWorkflowNotes.trim()) {
      sections.push("");
      sections.push("## About Me");
      sections.push("");
      sections.push(preferences.claudeMdWorkflowNotes.trim());
    }

    // My Skill Areas section (only if preferred categories set)
    if (preferences.preferredCategories.length > 0) {
      sections.push("");
      sections.push("## My Skill Areas");
      sections.push("");
      const cats = preferences.preferredCategories;
      if (cats.length === 1) {
        sections.push(`I primarily work with ${cats[0]}.`);
      } else {
        const last = cats[cats.length - 1];
        const rest = cats.slice(0, -1);
        sections.push(`I primarily work with ${rest.join(", ")} and ${last}.`);
      }
    }

    // Skills Portfolio section
    sections.push("");
    sections.push("## Skills Portfolio");

    if (publishedSkills.length === 0) {
      sections.push("");
      sections.push("No published skills yet.");
    } else {
      for (const skill of publishedSkills) {
        sections.push("");
        sections.push(`### ${skill.name}`);
        sections.push(`- **Category:** ${skill.category}`);
        sections.push(`- **Description:** ${skill.description}`);
        const tagList = skill.tags && skill.tags.length > 0 ? skill.tags.join(", ") : "None";
        sections.push(`- **Tags:** ${tagList}`);
        const hours = skill.hoursSaved ?? 1;
        sections.push(`- **Impact:** ${skill.totalUses} uses, ${hours}h saved per use`);
      }
    }

    // Workflow Preferences section
    sections.push("");
    sections.push("## Workflow Preferences");
    const sortLabel = SORT_LABELS[preferences.defaultSort] || "Most Time Saved";
    sections.push(`- Default skill sort: ${sortLabel}`);
    const catDisplay =
      preferences.preferredCategories.length > 0
        ? preferences.preferredCategories.join(", ")
        : "All categories";
    sections.push(`- Preferred categories: ${catDisplay}`);

    // Footer
    sections.push("");
    sections.push("---");
    sections.push("*Generated by EverySkill (everyskill.ai)*");

    const markdown = sections.join("\n");
    return { markdown };
  } catch (err) {
    console.error("Failed to generate CLAUDE.md:", err);
    return { error: "Failed to generate CLAUDE.md" };
  }
}
